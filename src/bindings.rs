/* automatically generated by rust-bindgen 0.71.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const FLT_ROUNDS: u32 = 1;
pub const G_GINT16_MODIFIER: &[u8; 2] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINT64_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINT64_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSSIZE_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GSIZE_FORMAT: &[u8; 3] = b"lu\0";
pub const G_GSSIZE_FORMAT: &[u8; 3] = b"li\0";
pub const G_GOFFSET_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GOFFSET_FORMAT: &[u8; 3] = b"li\0";
pub const G_POLLFD_FORMAT: &[u8; 3] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &[u8; 2] = b"l\0";
pub const G_GINTPTR_FORMAT: &[u8; 3] = b"li\0";
pub const G_GUINTPTR_FORMAT: &[u8; 3] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 80;
pub const GLIB_MICRO_VERSION: u32 = 0;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &[u8; 3] = b"so\0";
pub const G_PID_FORMAT: &[u8; 2] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2] = b":\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_STR_DELIMITERS: &[u8; 8] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11] = b"0123456789\0";
pub const G_CSET_LATINC : & [u8 ; 31] = b"\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD8\xD9\xDA\xDB\xDC\xDD\xDE\0" ;
pub const G_CSET_LATINS : & [u8 ; 33] = b"\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF\0" ;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _SYS_STAT_H: u32 = 1;
pub const _BITS_STAT_H: u32 = 1;
pub const _BITS_STRUCT_STAT_H: u32 = 1;
pub const __S_IFMT: u32 = 61440;
pub const __S_IFDIR: u32 = 16384;
pub const __S_IFCHR: u32 = 8192;
pub const __S_IFBLK: u32 = 24576;
pub const __S_IFREG: u32 = 32768;
pub const __S_IFIFO: u32 = 4096;
pub const __S_IFLNK: u32 = 40960;
pub const __S_IFSOCK: u32 = 49152;
pub const __S_ISUID: u32 = 2048;
pub const __S_ISGID: u32 = 1024;
pub const __S_ISVTX: u32 = 512;
pub const __S_IREAD: u32 = 256;
pub const __S_IWRITE: u32 = 128;
pub const __S_IEXEC: u32 = 64;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const S_IFMT: u32 = 61440;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFBLK: u32 = 24576;
pub const S_IFREG: u32 = 32768;
pub const S_IFIFO: u32 = 4096;
pub const S_IFLNK: u32 = 40960;
pub const S_IFSOCK: u32 = 49152;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXU: u32 = 448;
pub const S_IREAD: u32 = 256;
pub const S_IWRITE: u32 = 128;
pub const S_IEXEC: u32 = 64;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXG: u32 = 56;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const S_IRWXO: u32 = 7;
pub const ACCESSPERMS: u32 = 511;
pub const ALLPERMS: u32 = 4095;
pub const DEFFILEMODE: u32 = 438;
pub const S_BLKSIZE: u32 = 512;
pub const G_TYPE_FUNDAMENTAL_SHIFT: u32 = 2;
pub const G_TYPE_FUNDAMENTAL_MAX: u32 = 1020;
pub const G_TYPE_RESERVED_GLIB_FIRST: u32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: u32 = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: u32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: u32 = 48;
pub const G_TYPE_RESERVED_USER_FIRST: u32 = 49;
pub const G_VALUE_NOCOPY_CONTENTS: u32 = 134217728;
pub const G_PARAM_MASK: u32 = 255;
pub const G_PARAM_USER_SHIFT: u32 = 8;
pub const G_SIGNAL_FLAGS_MASK: u32 = 511;
pub const G_SIGNAL_MATCH_MASK: u32 = 63;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME: &[u8; 21] = b"gio-debug-controller\0";
pub const G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: &[u8; 12] = b"unix-device\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE: &[u8; 15] = b"standard::type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: &[u8; 20] = b"standard::is-hidden\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP: &[u8; 20] = b"standard::is-backup\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: &[u8; 21] = b"standard::is-symlink\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: &[u8; 21] = b"standard::is-virtual\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: &[u8; 22] = b"standard::is-volatile\0";
pub const G_FILE_ATTRIBUTE_STANDARD_NAME: &[u8; 15] = b"standard::name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: &[u8; 23] = b"standard::display-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME: &[u8; 20] = b"standard::edit-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME: &[u8; 20] = b"standard::copy-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION: &[u8; 22] = b"standard::description\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ICON: &[u8; 15] = b"standard::icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: &[u8; 24] = b"standard::symbolic-icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: &[u8; 23] = b"standard::content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: &[u8; 28] = b"standard::fast-content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE: &[u8; 15] = b"standard::size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: &[u8; 25] = b"standard::allocated-size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: &[u8; 25] = b"standard::symlink-target\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI: &[u8; 21] = b"standard::target-uri\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER: &[u8; 21] = b"standard::sort-order\0";
pub const G_FILE_ATTRIBUTE_ETAG_VALUE: &[u8; 12] = b"etag::value\0";
pub const G_FILE_ATTRIBUTE_ID_FILE: &[u8; 9] = b"id::file\0";
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM: &[u8; 15] = b"id::filesystem\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ: &[u8; 17] = b"access::can-read\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE: &[u8; 18] = b"access::can-write\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: &[u8; 20] = b"access::can-execute\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE: &[u8; 19] = b"access::can-delete\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH: &[u8; 18] = b"access::can-trash\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME: &[u8; 19] = b"access::can-rename\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: &[u8; 21] = b"mountable::can-mount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: &[u8; 23] = b"mountable::can-unmount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: &[u8; 21] = b"mountable::can-eject\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: &[u8; 23] = b"mountable::unix-device\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: &[u8; 28] = b"mountable::unix-device-file\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: &[u8; 19] = b"mountable::hal-udi\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START: &[u8; 21] = b"mountable::can-start\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: &[u8; 30] =
    b"mountable::can-start-degraded\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: &[u8; 20] = b"mountable::can-stop\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: &[u8; 27] = b"mountable::start-stop-type\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: &[u8; 20] = b"mountable::can-poll\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: &[u8; 36] =
    b"mountable::is-media-check-automatic\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED: &[u8; 15] = b"time::modified\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC: &[u8; 20] = b"time::modified-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: &[u8; 20] = b"time::modified-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS: &[u8; 13] = b"time::access\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC: &[u8; 18] = b"time::access-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC: &[u8; 18] = b"time::access-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED: &[u8; 14] = b"time::changed\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC: &[u8; 19] = b"time::changed-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_NSEC: &[u8; 19] = b"time::changed-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED: &[u8; 14] = b"time::created\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC: &[u8; 19] = b"time::created-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_NSEC: &[u8; 19] = b"time::created-nsec\0";
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE: &[u8; 13] = b"unix::device\0";
pub const G_FILE_ATTRIBUTE_UNIX_INODE: &[u8; 12] = b"unix::inode\0";
pub const G_FILE_ATTRIBUTE_UNIX_MODE: &[u8; 11] = b"unix::mode\0";
pub const G_FILE_ATTRIBUTE_UNIX_NLINK: &[u8; 12] = b"unix::nlink\0";
pub const G_FILE_ATTRIBUTE_UNIX_UID: &[u8; 10] = b"unix::uid\0";
pub const G_FILE_ATTRIBUTE_UNIX_GID: &[u8; 10] = b"unix::gid\0";
pub const G_FILE_ATTRIBUTE_UNIX_RDEV: &[u8; 11] = b"unix::rdev\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: &[u8; 17] = b"unix::block-size\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS: &[u8; 13] = b"unix::blocks\0";
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: &[u8; 20] = b"unix::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE: &[u8; 16] = b"dos::is-archive\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM: &[u8; 15] = b"dos::is-system\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: &[u8; 19] = b"dos::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: &[u8; 23] = b"dos::reparse-point-tag\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER: &[u8; 12] = b"owner::user\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL: &[u8; 17] = b"owner::user-real\0";
pub const G_FILE_ATTRIBUTE_OWNER_GROUP: &[u8; 13] = b"owner::group\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH: &[u8; 16] = b"thumbnail::path\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED: &[u8; 18] = b"thumbnail::failed\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: &[u8; 20] = b"thumbnail::is-valid\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: &[u8; 23] = b"thumbnail::path-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: &[u8; 25] = b"thumbnail::failed-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: &[u8; 27] = b"thumbnail::is-valid-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: &[u8; 22] = b"thumbnail::path-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: &[u8; 24] = b"thumbnail::failed-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: &[u8; 26] = b"thumbnail::is-valid-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: &[u8; 23] = b"thumbnail::path-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: &[u8; 25] = b"thumbnail::failed-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: &[u8; 27] = b"thumbnail::is-valid-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: &[u8; 24] = b"thumbnail::path-xxlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: &[u8; 26] = b"thumbnail::failed-xxlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: &[u8; 28] = b"thumbnail::is-valid-xxlarge\0";
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON: &[u8; 14] = b"preview::icon\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE: &[u8; 17] = b"filesystem::size\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE: &[u8; 17] = b"filesystem::free\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED: &[u8; 17] = b"filesystem::used\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE: &[u8; 17] = b"filesystem::type\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY: &[u8; 21] = b"filesystem::readonly\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: &[u8; 24] = b"filesystem::use-preview\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE: &[u8; 19] = b"filesystem::remote\0";
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND: &[u8; 14] = b"gvfs::backend\0";
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT: &[u8; 17] = b"selinux::context\0";
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT: &[u8; 18] = b"trash::item-count\0";
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH: &[u8; 17] = b"trash::orig-path\0";
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE: &[u8; 21] = b"trash::deletion-date\0";
pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED: &[u8; 17] = b"recent::modified\0";
pub const G_MEMORY_MONITOR_EXTENSION_POINT_NAME: &[u8; 19] = b"gio-memory-monitor\0";
pub const G_MENU_ATTRIBUTE_ACTION: &[u8; 7] = b"action\0";
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE: &[u8; 17] = b"action-namespace\0";
pub const G_MENU_ATTRIBUTE_TARGET: &[u8; 7] = b"target\0";
pub const G_MENU_ATTRIBUTE_LABEL: &[u8; 6] = b"label\0";
pub const G_MENU_ATTRIBUTE_ICON: &[u8; 5] = b"icon\0";
pub const G_MENU_LINK_SUBMENU: &[u8; 8] = b"submenu\0";
pub const G_MENU_LINK_SECTION: &[u8; 8] = b"section\0";
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME: &[u8; 19] = b"gio-volume-monitor\0";
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: &[u8; 26] = b"gio-native-volume-monitor\0";
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME: &[u8; 20] = b"gio-network-monitor\0";
pub const G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: &[u8; 26] = b"gio-power-profile-monitor\0";
pub const G_PROXY_EXTENSION_POINT_NAME: &[u8; 10] = b"gio-proxy\0";
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME: &[u8; 19] = b"gio-proxy-resolver\0";
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME: &[u8; 16] = b"gio-tls-backend\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: &[u8; 18] = b"1.3.6.1.5.5.7.3.1\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: &[u8; 18] = b"1.3.6.1.5.5.7.3.2\0";
pub const G_VFS_EXTENSION_POINT_NAME: &[u8; 8] = b"gio-vfs\0";
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: &[u8; 12] = b"unix-device\0";
pub const G_VOLUME_IDENTIFIER_KIND_LABEL: &[u8; 6] = b"label\0";
pub const G_VOLUME_IDENTIFIER_KIND_UUID: &[u8; 5] = b"uuid\0";
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT: &[u8; 10] = b"nfs-mount\0";
pub const G_VOLUME_IDENTIFIER_KIND_CLASS: &[u8; 6] = b"class\0";
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const VIPS_PI: f64 = 3.141592653589793;
pub const VIPS_PATH_MAX: u32 = 4096;
pub const VIPS_TARGET_BUFFER_SIZE: u32 = 8500;
pub const VIPS_TARGET_CUSTOM_BUFFER_SIZE: u32 = 4096;
pub const VIPS_SBUF_BUFFER_SIZE: u32 = 4096;
pub const VIPS_VERSION: &[u8; 7] = b"8.15.1\0";
pub const VIPS_VERSION_STRING: &[u8; 7] = b"8.15.1\0";
pub const VIPS_MAJOR_VERSION: u32 = 8;
pub const VIPS_MINOR_VERSION: u32 = 15;
pub const VIPS_MICRO_VERSION: u32 = 1;
pub const VIPS_LIBRARY_CURRENT: u32 = 59;
pub const VIPS_LIBRARY_REVISION: u32 = 1;
pub const VIPS_LIBRARY_AGE: u32 = 17;
pub const VIPS_CONFIG : & [u8 ; 1291] = b"enable debug: false\nenable deprecated: true\nenable modules: true\nenable cplusplus: true\nenable RAD load/save: true\nenable Analyze7 load/save: true\nenable PPM load/save: true\nenable GIF load: true\nuse fftw for FFTs: true\nSIMD support with highway: true\naccelerate loops with ORC: false\nICC profile support with lcms: true\nzlib: true\ntext rendering with pangocairo: true\nfont file support with fontconfig: true\nEXIF metadata support with libexif: true\nJPEG load/save with libjpeg: true\nJXL load/save with libjxl: true (dynamic module: true)\nJPEG2000 load/save with OpenJPEG: true\nPNG load/save with libspng: true\nPNG load/save with libpng: false\nselected quantisation package: imagequant\nTIFF load/save with libtiff: true\nimage pyramid save with libarchive: true\nHEIC/AVIF load/save with libheif: true (dynamic module: true)\nWebP load/save with libwebp: true\nPDF load with PDFium: false\nPDF load with poppler-glib: true (dynamic module: true)\nSVG load with librsvg: true\nEXR load with OpenEXR: true\nOpenSlide load: true (dynamic module: true)\nMatlab load with libmatio: true\nNIfTI load/save with niftiio: false\nFITS load/save with cfitsio: true\nGIF save with cgif: true\nselected Magick package: MagickCore (dynamic module: true)\nMagick API version: magick6\nMagick load: true\nMagick save: true\0" ;
pub const VIPS_ENABLE_DEPRECATED: u32 = 1;
pub const VIPS_SPARE: u32 = 8;
pub const VIPS__WINDOW_MARGIN_PIXELS: u32 = 128;
pub const VIPS__WINDOW_MARGIN_BYTES: u32 = 10485760;
pub const VIPS_SIZEOF_HEADER: u32 = 64;
pub const VIPS__TILE_WIDTH: u32 = 128;
pub const VIPS__TILE_HEIGHT: u32 = 128;
pub const VIPS__THINSTRIP_HEIGHT: u32 = 1;
pub const VIPS__FATSTRIP_HEIGHT: u32 = 16;
pub const VIPS_MAGIC_INTEL: u32 = 3064394248;
pub const VIPS_MAGIC_SPARC: u32 = 150120118;
pub const VIPS_MAX_COORD: u32 = 10000000;
pub const VIPS_TRANSFORM_SHIFT: u32 = 6;
pub const VIPS_TRANSFORM_SCALE: u32 = 64;
pub const VIPS_INTERPOLATE_SHIFT: u32 = 12;
pub const VIPS_INTERPOLATE_SCALE: u32 = 4096;
pub const VIPS_META_EXIF_NAME: &[u8; 10] = b"exif-data\0";
pub const VIPS_META_XMP_NAME: &[u8; 9] = b"xmp-data\0";
pub const VIPS_META_IPTC_NAME: &[u8; 10] = b"iptc-data\0";
pub const VIPS_META_PHOTOSHOP_NAME: &[u8; 15] = b"photoshop-data\0";
pub const VIPS_META_ICC_NAME: &[u8; 17] = b"icc-profile-data\0";
pub const VIPS_META_IMAGEDESCRIPTION: &[u8; 18] = b"image-description\0";
pub const VIPS_META_RESOLUTION_UNIT: &[u8; 16] = b"resolution-unit\0";
pub const VIPS_META_BITS_PER_SAMPLE: &[u8; 16] = b"bits-per-sample\0";
pub const VIPS_META_LOADER: &[u8; 12] = b"vips-loader\0";
pub const VIPS_META_SEQUENTIAL: &[u8; 16] = b"vips-sequential\0";
pub const VIPS_META_ORIENTATION: &[u8; 12] = b"orientation\0";
pub const VIPS_META_PAGE_HEIGHT: &[u8; 12] = b"page-height\0";
pub const VIPS_META_N_PAGES: &[u8; 8] = b"n-pages\0";
pub const VIPS_META_N_SUBIFDS: &[u8; 10] = b"n-subifds\0";
pub const VIPS_META_CONCURRENCY: &[u8; 12] = b"concurrency\0";
pub const VIPS_D93_X0: f64 = 89.74;
pub const VIPS_D93_Y0: f64 = 100.0;
pub const VIPS_D93_Z0: f64 = 130.77;
pub const VIPS_D75_X0: f64 = 94.9682;
pub const VIPS_D75_Y0: f64 = 100.0;
pub const VIPS_D75_Z0: f64 = 122.571;
pub const VIPS_D65_X0: f64 = 95.047;
pub const VIPS_D65_Y0: f64 = 100.0;
pub const VIPS_D65_Z0: f64 = 108.8827;
pub const VIPS_D55_X0: f64 = 95.6831;
pub const VIPS_D55_Y0: f64 = 100.0;
pub const VIPS_D55_Z0: f64 = 92.0871;
pub const VIPS_D50_X0: f64 = 96.425;
pub const VIPS_D50_Y0: f64 = 100.0;
pub const VIPS_D50_Z0: f64 = 82.468;
pub const VIPS_A_X0: f64 = 109.8503;
pub const VIPS_A_Y0: f64 = 100.0;
pub const VIPS_A_Z0: f64 = 35.5849;
pub const VIPS_B_X0: f64 = 99.072;
pub const VIPS_B_Y0: f64 = 100.0;
pub const VIPS_B_Z0: f64 = 85.223;
pub const VIPS_C_X0: f64 = 98.07;
pub const VIPS_C_Y0: f64 = 100.0;
pub const VIPS_C_Z0: f64 = 118.23;
pub const VIPS_E_X0: f64 = 100.0;
pub const VIPS_E_Y0: f64 = 100.0;
pub const VIPS_E_Z0: f64 = 100.0;
pub const VIPS_D3250_X0: f64 = 105.659;
pub const VIPS_D3250_Y0: f64 = 100.0;
pub const VIPS_D3250_Z0: f64 = 45.8501;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__max_align_ll"]
        [::std::mem::offset_of!(max_align_t, __max_align_ll) - 0usize];
    ["Offset of field: max_align_t::__max_align_ld"]
        [::std::mem::offset_of!(max_align_t, __max_align_ld) - 16usize];
};
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of tm"][::std::mem::size_of::<tm>() - 56usize];
    ["Alignment of tm"][::std::mem::align_of::<tm>() - 8usize];
    ["Offset of field: tm::tm_sec"][::std::mem::offset_of!(tm, tm_sec) - 0usize];
    ["Offset of field: tm::tm_min"][::std::mem::offset_of!(tm, tm_min) - 4usize];
    ["Offset of field: tm::tm_hour"][::std::mem::offset_of!(tm, tm_hour) - 8usize];
    ["Offset of field: tm::tm_mday"][::std::mem::offset_of!(tm, tm_mday) - 12usize];
    ["Offset of field: tm::tm_mon"][::std::mem::offset_of!(tm, tm_mon) - 16usize];
    ["Offset of field: tm::tm_year"][::std::mem::offset_of!(tm, tm_year) - 20usize];
    ["Offset of field: tm::tm_wday"][::std::mem::offset_of!(tm, tm_wday) - 24usize];
    ["Offset of field: tm::tm_yday"][::std::mem::offset_of!(tm, tm_yday) - 28usize];
    ["Offset of field: tm::tm_isdst"][::std::mem::offset_of!(tm, tm_isdst) - 32usize];
    ["Offset of field: tm::tm_gmtoff"][::std::mem::offset_of!(tm, tm_gmtoff) - 40usize];
    ["Offset of field: tm::tm_zone"][::std::mem::offset_of!(tm, tm_zone) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __locale_struct"][::std::mem::size_of::<__locale_struct>() - 232usize];
    ["Alignment of __locale_struct"][::std::mem::align_of::<__locale_struct>() - 8usize];
    ["Offset of field: __locale_struct::__locales"]
        [::std::mem::offset_of!(__locale_struct, __locales) - 0usize];
    ["Offset of field: __locale_struct::__ctype_b"]
        [::std::mem::offset_of!(__locale_struct, __ctype_b) - 104usize];
    ["Offset of field: __locale_struct::__ctype_tolower"]
        [::std::mem::offset_of!(__locale_struct, __ctype_tolower) - 112usize];
    ["Offset of field: __locale_struct::__ctype_toupper"]
        [::std::mem::offset_of!(__locale_struct, __ctype_toupper) - 120usize];
    ["Offset of field: __locale_struct::__names"]
        [::std::mem::offset_of!(__locale_struct, __names) - 128usize];
};
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
unsafe extern "C" {
    pub fn clock() -> clock_t;
}
unsafe extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
unsafe extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
unsafe extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
unsafe extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
unsafe extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
unsafe extern "C" {
    pub fn tzset();
}
unsafe extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
unsafe extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
#[doc = " GEqualFuncFull:\n @a: a value\n @b: a value to compare with\n @user_data: user data provided by the caller\n\n Specifies the type of a function used to test two values for\n equality. The function should return %TRUE if both values are equal\n and %FALSE otherwise.\n\n This is a version of #GEqualFunc which provides a @user_data closure from\n the caller.\n\n Returns: %TRUE if @a = @b; %FALSE otherwise\n Since: 2.74"]
pub type GEqualFuncFull = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gboolean,
>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:\n @data: a data pointer\n\n Declares a type of function which takes an arbitrary\n data pointer argument and has no return value. It is\n not currently used in GLib or GTK."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:\n @str: the untranslated string\n @data: user data specified when installing the function, e.g.\n  in g_option_group_set_translate_func()\n\n The type of functions which are used to translate user-visible\n strings, for <option>--help</option> output.\n\n Returns: a translation of the string for the current locale.\n  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFloatIEEE754__bindgen_ty_1"]
        [::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>() - 4usize];
    ["Alignment of _GFloatIEEE754__bindgen_ty_1"]
        [::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>() - 4usize];
};
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                23u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                23u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                23usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                23usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFloatIEEE754"][::std::mem::size_of::<_GFloatIEEE754>() - 4usize];
    ["Alignment of _GFloatIEEE754"][::std::mem::align_of::<_GFloatIEEE754>() - 4usize];
    ["Offset of field: _GFloatIEEE754::v_float"]
        [::std::mem::offset_of!(_GFloatIEEE754, v_float) - 0usize];
    ["Offset of field: _GFloatIEEE754::mpn"][::std::mem::offset_of!(_GFloatIEEE754, mpn) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDoubleIEEE754__bindgen_ty_1"]
        [::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>() - 8usize];
    ["Alignment of _GDoubleIEEE754__bindgen_ty_1"]
        [::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>() - 4usize];
};
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_low_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_low_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn mantissa_high_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                20u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_mantissa_high_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                20u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn biased_exponent_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                52usize,
                11u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_biased_exponent_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                52usize,
                11u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn sign_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                63usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_sign_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                63usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDoubleIEEE754"][::std::mem::size_of::<_GDoubleIEEE754>() - 8usize];
    ["Alignment of _GDoubleIEEE754"][::std::mem::align_of::<_GDoubleIEEE754>() - 8usize];
    ["Offset of field: _GDoubleIEEE754::v_double"]
        [::std::mem::offset_of!(_GDoubleIEEE754, v_double) - 0usize];
    ["Offset of field: _GDoubleIEEE754::mpn"]
        [::std::mem::offset_of!(_GDoubleIEEE754, mpn) - 0usize];
};
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTimeVal"][::std::mem::size_of::<_GTimeVal>() - 16usize];
    ["Alignment of _GTimeVal"][::std::mem::align_of::<_GTimeVal>() - 8usize];
    ["Offset of field: _GTimeVal::tv_sec"][::std::mem::offset_of!(_GTimeVal, tv_sec) - 0usize];
    ["Offset of field: _GTimeVal::tv_usec"][::std::mem::offset_of!(_GTimeVal, tv_usec) - 8usize];
};
pub type grefcount = gint;
pub type gatomicrefcount = gint;
unsafe extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strchrnul(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strcasestr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn memmem(
        __haystack: *const ::std::os::raw::c_void,
        __haystacklen: usize,
        __needle: *const ::std::os::raw::c_void,
        __needlelen: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn __mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn mempcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
unsafe extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    );
}
unsafe extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
unsafe extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
unsafe extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn strlcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn strlcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GArray"][::std::mem::size_of::<_GArray>() - 16usize];
    ["Alignment of _GArray"][::std::mem::align_of::<_GArray>() - 8usize];
    ["Offset of field: _GArray::data"][::std::mem::offset_of!(_GArray, data) - 0usize];
    ["Offset of field: _GArray::len"][::std::mem::offset_of!(_GArray, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GByteArray"][::std::mem::size_of::<_GByteArray>() - 16usize];
    ["Alignment of _GByteArray"][::std::mem::align_of::<_GByteArray>() - 8usize];
    ["Offset of field: _GByteArray::data"][::std::mem::offset_of!(_GByteArray, data) - 0usize];
    ["Offset of field: _GByteArray::len"][::std::mem::offset_of!(_GByteArray, len) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPtrArray"][::std::mem::size_of::<_GPtrArray>() - 16usize];
    ["Alignment of _GPtrArray"][::std::mem::align_of::<_GPtrArray>() - 8usize];
    ["Offset of field: _GPtrArray::pdata"][::std::mem::offset_of!(_GPtrArray, pdata) - 0usize];
    ["Offset of field: _GPtrArray::len"][::std::mem::offset_of!(_GPtrArray, len) - 8usize];
};
unsafe extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_new_take(
        data: gpointer,
        len: gsize,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_new_take_zero_terminated(
        data: gpointer,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
unsafe extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
unsafe extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
unsafe extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_take(
        data: *mut gpointer,
        len: gsize,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_from_array(
        data: *mut gpointer,
        len: gsize,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_take_null_terminated(
        data: *mut gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_new_from_null_terminated_array(
        data: *mut gpointer,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
unsafe extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_values(array: *mut GPtrArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_ptr_array_sort_values_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
}
unsafe extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
unsafe extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
unsafe extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
unsafe extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
unsafe extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
        preval: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
unsafe extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_exchange(
        atomic: *mut ::std::os::raw::c_void,
        newval: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gintptr;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> guintptr;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> guintptr;
}
unsafe extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> guintptr;
}
unsafe extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type GQuark = guint32;
unsafe extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
unsafe extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GError"][::std::mem::size_of::<_GError>() - 16usize];
    ["Alignment of _GError"][::std::mem::align_of::<_GError>() - 8usize];
    ["Offset of field: _GError::domain"][::std::mem::offset_of!(_GError, domain) - 0usize];
    ["Offset of field: _GError::code"][::std::mem::offset_of!(_GError, code) - 4usize];
    ["Offset of field: _GError::message"][::std::mem::offset_of!(_GError, message) - 8usize];
};
#[doc = " GErrorInitFunc:\n @error: extended error\n\n Specifies the type of function which is called just after an\n extended error instance is created and its fields filled. It should\n only initialize the fields in the private data, which can be\n received with the generated `*_get_private()` function.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorInitFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
#[doc = " GErrorCopyFunc:\n @src_error: source extended error\n @dest_error: destination extended error\n\n Specifies the type of function which is called when an extended\n error instance is copied. It is passed the pointer to the\n destination error and source error, and should copy only the fields\n of the private data from @src_error to @dest_error.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @src_error and\n @dest_error.\n\n Since: 2.68"]
pub type GErrorCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
#[doc = " GErrorClearFunc:\n @error: extended error to clear\n\n Specifies the type of function which is called when an extended\n error instance is freed. It is passed the error pointer about to be\n freed, and should free the error's private data fields.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorClearFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
unsafe extern "C" {
    pub fn g_error_domain_register_static(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
unsafe extern "C" {
    pub fn g_error_domain_register(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
unsafe extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_free(error: *mut GError);
}
unsafe extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
unsafe extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
unsafe extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
}
unsafe extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
unsafe extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
unsafe extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_state_dir() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:\n @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory\n @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory\n @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory\n @G_USER_DIRECTORY_MUSIC: the user's Music directory\n @G_USER_DIRECTORY_PICTURES: the user's Pictures directory\n @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory\n @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory\n @G_USER_DIRECTORY_VIDEOS: the user's Movies directory\n @G_USER_N_DIRECTORIES: the number of enum values\n\n These are logical ids for special directories which are defined\n depending on the platform used. You should use g_get_user_special_dir()\n to retrieve the full path associated to the logical id.\n\n The #GUserDirectory enumeration can be extended at later date. Not\n every platform has a directory for every logical id in this\n enumeration.\n\n Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:\n @key: the string\n @value: the flag\n\n Associates a string with a bit flag.\n Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDebugKey"][::std::mem::size_of::<_GDebugKey>() - 16usize];
    ["Alignment of _GDebugKey"][::std::mem::align_of::<_GDebugKey>() - 8usize];
    ["Offset of field: _GDebugKey::key"][::std::mem::offset_of!(_GDebugKey, key) - 0usize];
    ["Offset of field: _GDebugKey::value"][::std::mem::offset_of!(_GDebugKey, value) - 8usize];
};
unsafe extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
unsafe extern "C" {
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:\n\n Declares a type of function which takes no arguments\n and has no return value. It is used to specify the type\n function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
unsafe extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
unsafe extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of div_t"][::std::mem::size_of::<div_t>() - 8usize];
    ["Alignment of div_t"][::std::mem::align_of::<div_t>() - 4usize];
    ["Offset of field: div_t::quot"][::std::mem::offset_of!(div_t, quot) - 0usize];
    ["Offset of field: div_t::rem"][::std::mem::offset_of!(div_t, rem) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ldiv_t"][::std::mem::size_of::<ldiv_t>() - 16usize];
    ["Alignment of ldiv_t"][::std::mem::align_of::<ldiv_t>() - 8usize];
    ["Offset of field: ldiv_t::quot"][::std::mem::offset_of!(ldiv_t, quot) - 0usize];
    ["Offset of field: ldiv_t::rem"][::std::mem::offset_of!(ldiv_t, rem) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of lldiv_t"][::std::mem::size_of::<lldiv_t>() - 16usize];
    ["Alignment of lldiv_t"][::std::mem::align_of::<lldiv_t>() - 8usize];
    ["Offset of field: lldiv_t::quot"][::std::mem::offset_of!(lldiv_t, quot) - 0usize];
    ["Offset of field: lldiv_t::rem"][::std::mem::offset_of!(lldiv_t, rem) - 8usize];
};
unsafe extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
unsafe extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
unsafe extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
unsafe extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __sigset_t"][::std::mem::size_of::<__sigset_t>() - 128usize];
    ["Alignment of __sigset_t"][::std::mem::align_of::<__sigset_t>() - 8usize];
    ["Offset of field: __sigset_t::__val"][::std::mem::offset_of!(__sigset_t, __val) - 0usize];
};
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timeval"][::std::mem::size_of::<timeval>() - 16usize];
    ["Alignment of timeval"][::std::mem::align_of::<timeval>() - 8usize];
    ["Offset of field: timeval::tv_sec"][::std::mem::offset_of!(timeval, tv_sec) - 0usize];
    ["Offset of field: timeval::tv_usec"][::std::mem::offset_of!(timeval, tv_usec) - 8usize];
};
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 8usize];
    ["Offset of field: fd_set::__fds_bits"][::std::mem::offset_of!(fd_set, __fds_bits) - 0usize];
};
pub type fd_mask = __fd_mask;
unsafe extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>() - 8usize];
    ["Alignment of __atomic_wide_counter__bindgen_ty_1"]
        [::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>() - 4usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__low"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __low) - 0usize];
    ["Offset of field: __atomic_wide_counter__bindgen_ty_1::__high"]
        [::std::mem::offset_of!(__atomic_wide_counter__bindgen_ty_1, __high) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __atomic_wide_counter"][::std::mem::size_of::<__atomic_wide_counter>() - 8usize];
    ["Alignment of __atomic_wide_counter"]
        [::std::mem::align_of::<__atomic_wide_counter>() - 8usize];
    ["Offset of field: __atomic_wide_counter::__value64"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value64) - 0usize];
    ["Offset of field: __atomic_wide_counter::__value32"]
        [::std::mem::offset_of!(__atomic_wide_counter, __value32) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_list"][::std::mem::size_of::<__pthread_internal_list>() - 16usize];
    ["Alignment of __pthread_internal_list"]
        [::std::mem::align_of::<__pthread_internal_list>() - 8usize];
    ["Offset of field: __pthread_internal_list::__prev"]
        [::std::mem::offset_of!(__pthread_internal_list, __prev) - 0usize];
    ["Offset of field: __pthread_internal_list::__next"]
        [::std::mem::offset_of!(__pthread_internal_list, __next) - 8usize];
};
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_internal_slist"]
        [::std::mem::size_of::<__pthread_internal_slist>() - 8usize];
    ["Alignment of __pthread_internal_slist"]
        [::std::mem::align_of::<__pthread_internal_slist>() - 8usize];
    ["Offset of field: __pthread_internal_slist::__next"]
        [::std::mem::offset_of!(__pthread_internal_slist, __next) - 0usize];
};
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_mutex_s"][::std::mem::size_of::<__pthread_mutex_s>() - 40usize];
    ["Alignment of __pthread_mutex_s"][::std::mem::align_of::<__pthread_mutex_s>() - 8usize];
    ["Offset of field: __pthread_mutex_s::__lock"]
        [::std::mem::offset_of!(__pthread_mutex_s, __lock) - 0usize];
    ["Offset of field: __pthread_mutex_s::__count"]
        [::std::mem::offset_of!(__pthread_mutex_s, __count) - 4usize];
    ["Offset of field: __pthread_mutex_s::__owner"]
        [::std::mem::offset_of!(__pthread_mutex_s, __owner) - 8usize];
    ["Offset of field: __pthread_mutex_s::__nusers"]
        [::std::mem::offset_of!(__pthread_mutex_s, __nusers) - 12usize];
    ["Offset of field: __pthread_mutex_s::__kind"]
        [::std::mem::offset_of!(__pthread_mutex_s, __kind) - 16usize];
    ["Offset of field: __pthread_mutex_s::__spins"]
        [::std::mem::offset_of!(__pthread_mutex_s, __spins) - 20usize];
    ["Offset of field: __pthread_mutex_s::__elision"]
        [::std::mem::offset_of!(__pthread_mutex_s, __elision) - 22usize];
    ["Offset of field: __pthread_mutex_s::__list"]
        [::std::mem::offset_of!(__pthread_mutex_s, __list) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_rwlock_arch_t"][::std::mem::size_of::<__pthread_rwlock_arch_t>() - 56usize];
    ["Alignment of __pthread_rwlock_arch_t"]
        [::std::mem::align_of::<__pthread_rwlock_arch_t>() - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__readers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __readers) - 0usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers) - 4usize];
    ["Offset of field: __pthread_rwlock_arch_t::__wrphase_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __wrphase_futex) - 8usize];
    ["Offset of field: __pthread_rwlock_arch_t::__writers_futex"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __writers_futex) - 12usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad3"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad3) - 16usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad4"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad4) - 20usize];
    ["Offset of field: __pthread_rwlock_arch_t::__cur_writer"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __cur_writer) - 24usize];
    ["Offset of field: __pthread_rwlock_arch_t::__shared"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __shared) - 28usize];
    ["Offset of field: __pthread_rwlock_arch_t::__rwelision"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __rwelision) - 32usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad1"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad1) - 33usize];
    ["Offset of field: __pthread_rwlock_arch_t::__pad2"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __pad2) - 40usize];
    ["Offset of field: __pthread_rwlock_arch_t::__flags"]
        [::std::mem::offset_of!(__pthread_rwlock_arch_t, __flags) - 48usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cond_s"][::std::mem::size_of::<__pthread_cond_s>() - 48usize];
    ["Alignment of __pthread_cond_s"][::std::mem::align_of::<__pthread_cond_s>() - 8usize];
    ["Offset of field: __pthread_cond_s::__wseq"]
        [::std::mem::offset_of!(__pthread_cond_s, __wseq) - 0usize];
    ["Offset of field: __pthread_cond_s::__g1_start"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_start) - 8usize];
    ["Offset of field: __pthread_cond_s::__g_refs"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_refs) - 16usize];
    ["Offset of field: __pthread_cond_s::__g_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_size) - 24usize];
    ["Offset of field: __pthread_cond_s::__g1_orig_size"]
        [::std::mem::offset_of!(__pthread_cond_s, __g1_orig_size) - 32usize];
    ["Offset of field: __pthread_cond_s::__wrefs"]
        [::std::mem::offset_of!(__pthread_cond_s, __wrefs) - 36usize];
    ["Offset of field: __pthread_cond_s::__g_signals"]
        [::std::mem::offset_of!(__pthread_cond_s, __g_signals) - 40usize];
};
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __once_flag"][::std::mem::size_of::<__once_flag>() - 4usize];
    ["Alignment of __once_flag"][::std::mem::align_of::<__once_flag>() - 4usize];
    ["Offset of field: __once_flag::__data"][::std::mem::offset_of!(__once_flag, __data) - 0usize];
};
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutexattr_t"][::std::mem::size_of::<pthread_mutexattr_t>() - 4usize];
    ["Alignment of pthread_mutexattr_t"][::std::mem::align_of::<pthread_mutexattr_t>() - 4usize];
    ["Offset of field: pthread_mutexattr_t::__size"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __size) - 0usize];
    ["Offset of field: pthread_mutexattr_t::__align"]
        [::std::mem::offset_of!(pthread_mutexattr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_condattr_t"][::std::mem::size_of::<pthread_condattr_t>() - 4usize];
    ["Alignment of pthread_condattr_t"][::std::mem::align_of::<pthread_condattr_t>() - 4usize];
    ["Offset of field: pthread_condattr_t::__size"]
        [::std::mem::offset_of!(pthread_condattr_t, __size) - 0usize];
    ["Offset of field: pthread_condattr_t::__align"]
        [::std::mem::offset_of!(pthread_condattr_t, __align) - 0usize];
};
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_attr_t"][::std::mem::size_of::<pthread_attr_t>() - 56usize];
    ["Alignment of pthread_attr_t"][::std::mem::align_of::<pthread_attr_t>() - 8usize];
    ["Offset of field: pthread_attr_t::__size"]
        [::std::mem::offset_of!(pthread_attr_t, __size) - 0usize];
    ["Offset of field: pthread_attr_t::__align"]
        [::std::mem::offset_of!(pthread_attr_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_mutex_t"][::std::mem::size_of::<pthread_mutex_t>() - 40usize];
    ["Alignment of pthread_mutex_t"][::std::mem::align_of::<pthread_mutex_t>() - 8usize];
    ["Offset of field: pthread_mutex_t::__data"]
        [::std::mem::offset_of!(pthread_mutex_t, __data) - 0usize];
    ["Offset of field: pthread_mutex_t::__size"]
        [::std::mem::offset_of!(pthread_mutex_t, __size) - 0usize];
    ["Offset of field: pthread_mutex_t::__align"]
        [::std::mem::offset_of!(pthread_mutex_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_cond_t"][::std::mem::size_of::<pthread_cond_t>() - 48usize];
    ["Alignment of pthread_cond_t"][::std::mem::align_of::<pthread_cond_t>() - 8usize];
    ["Offset of field: pthread_cond_t::__data"]
        [::std::mem::offset_of!(pthread_cond_t, __data) - 0usize];
    ["Offset of field: pthread_cond_t::__size"]
        [::std::mem::offset_of!(pthread_cond_t, __size) - 0usize];
    ["Offset of field: pthread_cond_t::__align"]
        [::std::mem::offset_of!(pthread_cond_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlock_t"][::std::mem::size_of::<pthread_rwlock_t>() - 56usize];
    ["Alignment of pthread_rwlock_t"][::std::mem::align_of::<pthread_rwlock_t>() - 8usize];
    ["Offset of field: pthread_rwlock_t::__data"]
        [::std::mem::offset_of!(pthread_rwlock_t, __data) - 0usize];
    ["Offset of field: pthread_rwlock_t::__size"]
        [::std::mem::offset_of!(pthread_rwlock_t, __size) - 0usize];
    ["Offset of field: pthread_rwlock_t::__align"]
        [::std::mem::offset_of!(pthread_rwlock_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_rwlockattr_t"][::std::mem::size_of::<pthread_rwlockattr_t>() - 8usize];
    ["Alignment of pthread_rwlockattr_t"][::std::mem::align_of::<pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: pthread_rwlockattr_t::__size"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __size) - 0usize];
    ["Offset of field: pthread_rwlockattr_t::__align"]
        [::std::mem::offset_of!(pthread_rwlockattr_t, __align) - 0usize];
};
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrier_t"][::std::mem::size_of::<pthread_barrier_t>() - 32usize];
    ["Alignment of pthread_barrier_t"][::std::mem::align_of::<pthread_barrier_t>() - 8usize];
    ["Offset of field: pthread_barrier_t::__size"]
        [::std::mem::offset_of!(pthread_barrier_t, __size) - 0usize];
    ["Offset of field: pthread_barrier_t::__align"]
        [::std::mem::offset_of!(pthread_barrier_t, __align) - 0usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pthread_barrierattr_t"][::std::mem::size_of::<pthread_barrierattr_t>() - 4usize];
    ["Alignment of pthread_barrierattr_t"]
        [::std::mem::align_of::<pthread_barrierattr_t>() - 4usize];
    ["Offset of field: pthread_barrierattr_t::__size"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __size) - 0usize];
    ["Offset of field: pthread_barrierattr_t::__align"]
        [::std::mem::offset_of!(pthread_barrierattr_t, __align) - 0usize];
};
unsafe extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of random_data"][::std::mem::size_of::<random_data>() - 48usize];
    ["Alignment of random_data"][::std::mem::align_of::<random_data>() - 8usize];
    ["Offset of field: random_data::fptr"][::std::mem::offset_of!(random_data, fptr) - 0usize];
    ["Offset of field: random_data::rptr"][::std::mem::offset_of!(random_data, rptr) - 8usize];
    ["Offset of field: random_data::state"][::std::mem::offset_of!(random_data, state) - 16usize];
    ["Offset of field: random_data::rand_type"]
        [::std::mem::offset_of!(random_data, rand_type) - 24usize];
    ["Offset of field: random_data::rand_deg"]
        [::std::mem::offset_of!(random_data, rand_deg) - 28usize];
    ["Offset of field: random_data::rand_sep"]
        [::std::mem::offset_of!(random_data, rand_sep) - 32usize];
    ["Offset of field: random_data::end_ptr"]
        [::std::mem::offset_of!(random_data, end_ptr) - 40usize];
};
unsafe extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drand48() -> f64;
}
unsafe extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
unsafe extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
unsafe extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of drand48_data"][::std::mem::size_of::<drand48_data>() - 24usize];
    ["Alignment of drand48_data"][::std::mem::align_of::<drand48_data>() - 8usize];
    ["Offset of field: drand48_data::__x"][::std::mem::offset_of!(drand48_data, __x) - 0usize];
    ["Offset of field: drand48_data::__old_x"]
        [::std::mem::offset_of!(drand48_data, __old_x) - 6usize];
    ["Offset of field: drand48_data::__c"][::std::mem::offset_of!(drand48_data, __c) - 12usize];
    ["Offset of field: drand48_data::__init"]
        [::std::mem::offset_of!(drand48_data, __init) - 14usize];
    ["Offset of field: drand48_data::__a"][::std::mem::offset_of!(drand48_data, __a) - 16usize];
};
unsafe extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn arc4random() -> __uint32_t;
}
unsafe extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
unsafe extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
unsafe extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn abort() -> !;
}
unsafe extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
unsafe extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
unsafe extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
unsafe extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
unsafe extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
unsafe extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
unsafe extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMutex"][::std::mem::size_of::<_GMutex>() - 8usize];
    ["Alignment of _GMutex"][::std::mem::align_of::<_GMutex>() - 8usize];
    ["Offset of field: _GMutex::p"][::std::mem::offset_of!(_GMutex, p) - 0usize];
    ["Offset of field: _GMutex::i"][::std::mem::offset_of!(_GMutex, i) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRWLock"][::std::mem::size_of::<_GRWLock>() - 16usize];
    ["Alignment of _GRWLock"][::std::mem::align_of::<_GRWLock>() - 8usize];
    ["Offset of field: _GRWLock::p"][::std::mem::offset_of!(_GRWLock, p) - 0usize];
    ["Offset of field: _GRWLock::i"][::std::mem::offset_of!(_GRWLock, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCond"][::std::mem::size_of::<_GCond>() - 16usize];
    ["Alignment of _GCond"][::std::mem::align_of::<_GCond>() - 8usize];
    ["Offset of field: _GCond::p"][::std::mem::offset_of!(_GCond, p) - 0usize];
    ["Offset of field: _GCond::i"][::std::mem::offset_of!(_GCond, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRecMutex"][::std::mem::size_of::<_GRecMutex>() - 16usize];
    ["Alignment of _GRecMutex"][::std::mem::align_of::<_GRecMutex>() - 8usize];
    ["Offset of field: _GRecMutex::p"][::std::mem::offset_of!(_GRecMutex, p) - 0usize];
    ["Offset of field: _GRecMutex::i"][::std::mem::offset_of!(_GRecMutex, i) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPrivate"][::std::mem::size_of::<_GPrivate>() - 32usize];
    ["Alignment of _GPrivate"][::std::mem::align_of::<_GPrivate>() - 8usize];
    ["Offset of field: _GPrivate::p"][::std::mem::offset_of!(_GPrivate, p) - 0usize];
    ["Offset of field: _GPrivate::notify"][::std::mem::offset_of!(_GPrivate, notify) - 8usize];
    ["Offset of field: _GPrivate::future"][::std::mem::offset_of!(_GPrivate, future) - 16usize];
};
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOnce"][::std::mem::size_of::<_GOnce>() - 16usize];
    ["Alignment of _GOnce"][::std::mem::align_of::<_GOnce>() - 8usize];
    ["Offset of field: _GOnce::status"][::std::mem::offset_of!(_GOnce, status) - 0usize];
    ["Offset of field: _GOnce::retval"][::std::mem::offset_of!(_GOnce, retval) - 8usize];
};
unsafe extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
unsafe extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_exit(retval: gpointer) -> !;
}
unsafe extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
unsafe extern "C" {
    pub fn g_thread_yield();
}
unsafe extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
unsafe extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
unsafe extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
unsafe extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
unsafe extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
unsafe extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
unsafe extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
unsafe extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
unsafe extern "C" {
    pub fn g_once_init_enter_pointer(location: *mut ::std::os::raw::c_void) -> gboolean;
}
unsafe extern "C" {
    pub fn g_once_init_leave_pointer(location: *mut ::std::os::raw::c_void, result: gpointer);
}
unsafe extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:\n\n Opaque type. See g_mutex_locker_new() for details.\n Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:\n\n Opaque type. See g_rec_mutex_locker_new() for details.\n Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:\n\n Opaque type. See g_rw_lock_writer_locker_new() for details.\n Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:\n\n Opaque type. See g_rw_lock_reader_locker_new() for details.\n Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
unsafe extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
unsafe extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
unsafe extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
unsafe extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
unsafe extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
unsafe extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigval"][::std::mem::size_of::<sigval>() - 8usize];
    ["Alignment of sigval"][::std::mem::align_of::<sigval>() - 8usize];
    ["Offset of field: sigval::sival_int"][::std::mem::offset_of!(sigval, sival_int) - 0usize];
    ["Offset of field: sigval::sival_ptr"][::std::mem::offset_of!(sigval, sival_ptr) - 0usize];
};
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>() - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_1::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_1, si_uid) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_2"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_tid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_tid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_overrun"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_overrun) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_2::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_2, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_3"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_3::si_sigval"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_3, si_sigval) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_4"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_pid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_pid) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_uid"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_uid) - 4usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_status"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_status) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_utime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_utime) - 16usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_4::si_stime"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_4, si_stime) - 24usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_lower"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _lower) - 0usize] ;
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1::_upper"] [:: std :: mem :: offset_of ! (siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 , _upper) - 8usize] ;
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_addr_bnd"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _addr_bnd
    ) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1::_pkey"][::std::mem::offset_of!(
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
        _pkey
    ) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 32usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_5"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::si_addr_lsb"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, si_addr_lsb) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_5::_bounds"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_5, _bounds) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_6"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_band"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_band) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_6::si_fd"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_6, si_fd) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 16usize];
    ["Alignment of siginfo_t__bindgen_ty_1__bindgen_ty_7"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_call_addr"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _call_addr) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_syscall"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _syscall) - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1__bindgen_ty_7::_arch"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1__bindgen_ty_7, _arch) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t__bindgen_ty_1"]
        [::std::mem::size_of::<siginfo_t__bindgen_ty_1>() - 112usize];
    ["Alignment of siginfo_t__bindgen_ty_1"]
        [::std::mem::align_of::<siginfo_t__bindgen_ty_1>() - 8usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_kill"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _kill) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_timer"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _timer) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_rt"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _rt) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigchld"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigchld) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigfault"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigfault) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigpoll"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigpoll) - 0usize];
    ["Offset of field: siginfo_t__bindgen_ty_1::_sigsys"]
        [::std::mem::offset_of!(siginfo_t__bindgen_ty_1, _sigsys) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of siginfo_t"][::std::mem::size_of::<siginfo_t>() - 128usize];
    ["Alignment of siginfo_t"][::std::mem::align_of::<siginfo_t>() - 8usize];
    ["Offset of field: siginfo_t::si_signo"][::std::mem::offset_of!(siginfo_t, si_signo) - 0usize];
    ["Offset of field: siginfo_t::si_errno"][::std::mem::offset_of!(siginfo_t, si_errno) - 4usize];
    ["Offset of field: siginfo_t::si_code"][::std::mem::offset_of!(siginfo_t, si_code) - 8usize];
    ["Offset of field: siginfo_t::__pad0"][::std::mem::offset_of!(siginfo_t, __pad0) - 12usize];
    ["Offset of field: siginfo_t::_sifields"]
        [::std::mem::offset_of!(siginfo_t, _sifields) - 16usize];
};
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_4 = 8;
pub const SEGV_MTESERR: _bindgen_ty_4 = 9;
pub const SEGV_CPERR: _bindgen_ty_4 = 10;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 16usize];
    ["Alignment of sigevent__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_function"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _function) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1__bindgen_ty_1::_attribute"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1__bindgen_ty_1, _attribute) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent__bindgen_ty_1"][::std::mem::size_of::<sigevent__bindgen_ty_1>() - 48usize];
    ["Alignment of sigevent__bindgen_ty_1"]
        [::std::mem::align_of::<sigevent__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigevent__bindgen_ty_1::_pad"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _pad) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_tid"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _tid) - 0usize];
    ["Offset of field: sigevent__bindgen_ty_1::_sigev_thread"]
        [::std::mem::offset_of!(sigevent__bindgen_ty_1, _sigev_thread) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigevent"][::std::mem::size_of::<sigevent>() - 64usize];
    ["Alignment of sigevent"][::std::mem::align_of::<sigevent>() - 8usize];
    ["Offset of field: sigevent::sigev_value"]
        [::std::mem::offset_of!(sigevent, sigev_value) - 0usize];
    ["Offset of field: sigevent::sigev_signo"]
        [::std::mem::offset_of!(sigevent, sigev_signo) - 8usize];
    ["Offset of field: sigevent::sigev_notify"]
        [::std::mem::offset_of!(sigevent, sigev_notify) - 12usize];
    ["Offset of field: sigevent::_sigev_un"][::std::mem::offset_of!(sigevent, _sigev_un) - 16usize];
};
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
unsafe extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
unsafe extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
unsafe extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
unsafe extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction__bindgen_ty_1"][::std::mem::size_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Alignment of sigaction__bindgen_ty_1"]
        [::std::mem::align_of::<sigaction__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_handler"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_handler) - 0usize];
    ["Offset of field: sigaction__bindgen_ty_1::sa_sigaction"]
        [::std::mem::offset_of!(sigaction__bindgen_ty_1, sa_sigaction) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigaction"][::std::mem::size_of::<sigaction>() - 152usize];
    ["Alignment of sigaction"][::std::mem::align_of::<sigaction>() - 8usize];
    ["Offset of field: sigaction::__sigaction_handler"]
        [::std::mem::offset_of!(sigaction, __sigaction_handler) - 0usize];
    ["Offset of field: sigaction::sa_mask"][::std::mem::offset_of!(sigaction, sa_mask) - 8usize];
    ["Offset of field: sigaction::sa_flags"]
        [::std::mem::offset_of!(sigaction, sa_flags) - 136usize];
    ["Offset of field: sigaction::sa_restorer"]
        [::std::mem::offset_of!(sigaction, sa_restorer) - 144usize];
};
unsafe extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpx_sw_bytes"][::std::mem::size_of::<_fpx_sw_bytes>() - 48usize];
    ["Alignment of _fpx_sw_bytes"][::std::mem::align_of::<_fpx_sw_bytes>() - 8usize];
    ["Offset of field: _fpx_sw_bytes::magic1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, magic1) - 0usize];
    ["Offset of field: _fpx_sw_bytes::extended_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, extended_size) - 4usize];
    ["Offset of field: _fpx_sw_bytes::xstate_bv"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_bv) - 8usize];
    ["Offset of field: _fpx_sw_bytes::xstate_size"]
        [::std::mem::offset_of!(_fpx_sw_bytes, xstate_size) - 16usize];
    ["Offset of field: _fpx_sw_bytes::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpx_sw_bytes, __glibc_reserved1) - 20usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpreg"][::std::mem::size_of::<_fpreg>() - 10usize];
    ["Alignment of _fpreg"][::std::mem::align_of::<_fpreg>() - 2usize];
    ["Offset of field: _fpreg::significand"][::std::mem::offset_of!(_fpreg, significand) - 0usize];
    ["Offset of field: _fpreg::exponent"][::std::mem::offset_of!(_fpreg, exponent) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpxreg"][::std::mem::size_of::<_fpxreg>() - 16usize];
    ["Alignment of _fpxreg"][::std::mem::align_of::<_fpxreg>() - 2usize];
    ["Offset of field: _fpxreg::significand"]
        [::std::mem::offset_of!(_fpxreg, significand) - 0usize];
    ["Offset of field: _fpxreg::exponent"][::std::mem::offset_of!(_fpxreg, exponent) - 8usize];
    ["Offset of field: _fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xmmreg"][::std::mem::size_of::<_xmmreg>() - 16usize];
    ["Alignment of _xmmreg"][::std::mem::align_of::<_xmmreg>() - 4usize];
    ["Offset of field: _xmmreg::element"][::std::mem::offset_of!(_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _fpstate"][::std::mem::size_of::<_fpstate>() - 512usize];
    ["Alignment of _fpstate"][::std::mem::align_of::<_fpstate>() - 8usize];
    ["Offset of field: _fpstate::cwd"][::std::mem::offset_of!(_fpstate, cwd) - 0usize];
    ["Offset of field: _fpstate::swd"][::std::mem::offset_of!(_fpstate, swd) - 2usize];
    ["Offset of field: _fpstate::ftw"][::std::mem::offset_of!(_fpstate, ftw) - 4usize];
    ["Offset of field: _fpstate::fop"][::std::mem::offset_of!(_fpstate, fop) - 6usize];
    ["Offset of field: _fpstate::rip"][::std::mem::offset_of!(_fpstate, rip) - 8usize];
    ["Offset of field: _fpstate::rdp"][::std::mem::offset_of!(_fpstate, rdp) - 16usize];
    ["Offset of field: _fpstate::mxcsr"][::std::mem::offset_of!(_fpstate, mxcsr) - 24usize];
    ["Offset of field: _fpstate::mxcr_mask"][::std::mem::offset_of!(_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _fpstate::_st"][::std::mem::offset_of!(_fpstate, _st) - 32usize];
    ["Offset of field: _fpstate::_xmm"][::std::mem::offset_of!(_fpstate, _xmm) - 160usize];
    ["Offset of field: _fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_fpstate, __glibc_reserved1) - 416usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext__bindgen_ty_1"]
        [::std::mem::size_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Alignment of sigcontext__bindgen_ty_1"]
        [::std::mem::align_of::<sigcontext__bindgen_ty_1>() - 8usize];
    ["Offset of field: sigcontext__bindgen_ty_1::fpstate"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, fpstate) - 0usize];
    ["Offset of field: sigcontext__bindgen_ty_1::__fpstate_word"]
        [::std::mem::offset_of!(sigcontext__bindgen_ty_1, __fpstate_word) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigcontext"][::std::mem::size_of::<sigcontext>() - 256usize];
    ["Alignment of sigcontext"][::std::mem::align_of::<sigcontext>() - 8usize];
    ["Offset of field: sigcontext::r8"][::std::mem::offset_of!(sigcontext, r8) - 0usize];
    ["Offset of field: sigcontext::r9"][::std::mem::offset_of!(sigcontext, r9) - 8usize];
    ["Offset of field: sigcontext::r10"][::std::mem::offset_of!(sigcontext, r10) - 16usize];
    ["Offset of field: sigcontext::r11"][::std::mem::offset_of!(sigcontext, r11) - 24usize];
    ["Offset of field: sigcontext::r12"][::std::mem::offset_of!(sigcontext, r12) - 32usize];
    ["Offset of field: sigcontext::r13"][::std::mem::offset_of!(sigcontext, r13) - 40usize];
    ["Offset of field: sigcontext::r14"][::std::mem::offset_of!(sigcontext, r14) - 48usize];
    ["Offset of field: sigcontext::r15"][::std::mem::offset_of!(sigcontext, r15) - 56usize];
    ["Offset of field: sigcontext::rdi"][::std::mem::offset_of!(sigcontext, rdi) - 64usize];
    ["Offset of field: sigcontext::rsi"][::std::mem::offset_of!(sigcontext, rsi) - 72usize];
    ["Offset of field: sigcontext::rbp"][::std::mem::offset_of!(sigcontext, rbp) - 80usize];
    ["Offset of field: sigcontext::rbx"][::std::mem::offset_of!(sigcontext, rbx) - 88usize];
    ["Offset of field: sigcontext::rdx"][::std::mem::offset_of!(sigcontext, rdx) - 96usize];
    ["Offset of field: sigcontext::rax"][::std::mem::offset_of!(sigcontext, rax) - 104usize];
    ["Offset of field: sigcontext::rcx"][::std::mem::offset_of!(sigcontext, rcx) - 112usize];
    ["Offset of field: sigcontext::rsp"][::std::mem::offset_of!(sigcontext, rsp) - 120usize];
    ["Offset of field: sigcontext::rip"][::std::mem::offset_of!(sigcontext, rip) - 128usize];
    ["Offset of field: sigcontext::eflags"][::std::mem::offset_of!(sigcontext, eflags) - 136usize];
    ["Offset of field: sigcontext::cs"][::std::mem::offset_of!(sigcontext, cs) - 144usize];
    ["Offset of field: sigcontext::gs"][::std::mem::offset_of!(sigcontext, gs) - 146usize];
    ["Offset of field: sigcontext::fs"][::std::mem::offset_of!(sigcontext, fs) - 148usize];
    ["Offset of field: sigcontext::__pad0"][::std::mem::offset_of!(sigcontext, __pad0) - 150usize];
    ["Offset of field: sigcontext::err"][::std::mem::offset_of!(sigcontext, err) - 152usize];
    ["Offset of field: sigcontext::trapno"][::std::mem::offset_of!(sigcontext, trapno) - 160usize];
    ["Offset of field: sigcontext::oldmask"]
        [::std::mem::offset_of!(sigcontext, oldmask) - 168usize];
    ["Offset of field: sigcontext::cr2"][::std::mem::offset_of!(sigcontext, cr2) - 176usize];
    ["Offset of field: sigcontext::__reserved1"]
        [::std::mem::offset_of!(sigcontext, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xsave_hdr"][::std::mem::size_of::<_xsave_hdr>() - 64usize];
    ["Alignment of _xsave_hdr"][::std::mem::align_of::<_xsave_hdr>() - 8usize];
    ["Offset of field: _xsave_hdr::xstate_bv"]
        [::std::mem::offset_of!(_xsave_hdr, xstate_bv) - 0usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved1"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved1) - 8usize];
    ["Offset of field: _xsave_hdr::__glibc_reserved2"]
        [::std::mem::offset_of!(_xsave_hdr, __glibc_reserved2) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _ymmh_state"][::std::mem::size_of::<_ymmh_state>() - 256usize];
    ["Alignment of _ymmh_state"][::std::mem::align_of::<_ymmh_state>() - 4usize];
    ["Offset of field: _ymmh_state::ymmh_space"]
        [::std::mem::offset_of!(_ymmh_state, ymmh_space) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _xstate"][::std::mem::size_of::<_xstate>() - 832usize];
    ["Alignment of _xstate"][::std::mem::align_of::<_xstate>() - 8usize];
    ["Offset of field: _xstate::fpstate"][::std::mem::offset_of!(_xstate, fpstate) - 0usize];
    ["Offset of field: _xstate::xstate_hdr"]
        [::std::mem::offset_of!(_xstate, xstate_hdr) - 512usize];
    ["Offset of field: _xstate::ymmh"][::std::mem::offset_of!(_xstate, ymmh) - 576usize];
};
unsafe extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stack_t"][::std::mem::size_of::<stack_t>() - 24usize];
    ["Alignment of stack_t"][::std::mem::align_of::<stack_t>() - 8usize];
    ["Offset of field: stack_t::ss_sp"][::std::mem::offset_of!(stack_t, ss_sp) - 0usize];
    ["Offset of field: stack_t::ss_flags"][::std::mem::offset_of!(stack_t, ss_flags) - 8usize];
    ["Offset of field: stack_t::ss_size"][::std::mem::offset_of!(stack_t, ss_size) - 16usize];
};
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpxreg"][::std::mem::size_of::<_libc_fpxreg>() - 16usize];
    ["Alignment of _libc_fpxreg"][::std::mem::align_of::<_libc_fpxreg>() - 2usize];
    ["Offset of field: _libc_fpxreg::significand"]
        [::std::mem::offset_of!(_libc_fpxreg, significand) - 0usize];
    ["Offset of field: _libc_fpxreg::exponent"]
        [::std::mem::offset_of!(_libc_fpxreg, exponent) - 8usize];
    ["Offset of field: _libc_fpxreg::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpxreg, __glibc_reserved1) - 10usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_xmmreg"][::std::mem::size_of::<_libc_xmmreg>() - 16usize];
    ["Alignment of _libc_xmmreg"][::std::mem::align_of::<_libc_xmmreg>() - 4usize];
    ["Offset of field: _libc_xmmreg::element"]
        [::std::mem::offset_of!(_libc_xmmreg, element) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _libc_fpstate"][::std::mem::size_of::<_libc_fpstate>() - 512usize];
    ["Alignment of _libc_fpstate"][::std::mem::align_of::<_libc_fpstate>() - 8usize];
    ["Offset of field: _libc_fpstate::cwd"][::std::mem::offset_of!(_libc_fpstate, cwd) - 0usize];
    ["Offset of field: _libc_fpstate::swd"][::std::mem::offset_of!(_libc_fpstate, swd) - 2usize];
    ["Offset of field: _libc_fpstate::ftw"][::std::mem::offset_of!(_libc_fpstate, ftw) - 4usize];
    ["Offset of field: _libc_fpstate::fop"][::std::mem::offset_of!(_libc_fpstate, fop) - 6usize];
    ["Offset of field: _libc_fpstate::rip"][::std::mem::offset_of!(_libc_fpstate, rip) - 8usize];
    ["Offset of field: _libc_fpstate::rdp"][::std::mem::offset_of!(_libc_fpstate, rdp) - 16usize];
    ["Offset of field: _libc_fpstate::mxcsr"]
        [::std::mem::offset_of!(_libc_fpstate, mxcsr) - 24usize];
    ["Offset of field: _libc_fpstate::mxcr_mask"]
        [::std::mem::offset_of!(_libc_fpstate, mxcr_mask) - 28usize];
    ["Offset of field: _libc_fpstate::_st"][::std::mem::offset_of!(_libc_fpstate, _st) - 32usize];
    ["Offset of field: _libc_fpstate::_xmm"]
        [::std::mem::offset_of!(_libc_fpstate, _xmm) - 160usize];
    ["Offset of field: _libc_fpstate::__glibc_reserved1"]
        [::std::mem::offset_of!(_libc_fpstate, __glibc_reserved1) - 416usize];
};
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of mcontext_t"][::std::mem::size_of::<mcontext_t>() - 256usize];
    ["Alignment of mcontext_t"][::std::mem::align_of::<mcontext_t>() - 8usize];
    ["Offset of field: mcontext_t::gregs"][::std::mem::offset_of!(mcontext_t, gregs) - 0usize];
    ["Offset of field: mcontext_t::fpregs"][::std::mem::offset_of!(mcontext_t, fpregs) - 184usize];
    ["Offset of field: mcontext_t::__reserved1"]
        [::std::mem::offset_of!(mcontext_t, __reserved1) - 192usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ucontext_t"][::std::mem::size_of::<ucontext_t>() - 968usize];
    ["Alignment of ucontext_t"][::std::mem::align_of::<ucontext_t>() - 8usize];
    ["Offset of field: ucontext_t::uc_flags"]
        [::std::mem::offset_of!(ucontext_t, uc_flags) - 0usize];
    ["Offset of field: ucontext_t::uc_link"][::std::mem::offset_of!(ucontext_t, uc_link) - 8usize];
    ["Offset of field: ucontext_t::uc_stack"]
        [::std::mem::offset_of!(ucontext_t, uc_stack) - 16usize];
    ["Offset of field: ucontext_t::uc_mcontext"]
        [::std::mem::offset_of!(ucontext_t, uc_mcontext) - 40usize];
    ["Offset of field: ucontext_t::uc_sigmask"]
        [::std::mem::offset_of!(ucontext_t, uc_sigmask) - 296usize];
    ["Offset of field: ucontext_t::__fpregs_mem"]
        [::std::mem::offset_of!(ucontext_t, __fpregs_mem) - 424usize];
    ["Offset of field: ucontext_t::__ssp"][::std::mem::offset_of!(ucontext_t, __ssp) - 936usize];
};
unsafe extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sigstack"][::std::mem::size_of::<sigstack>() - 16usize];
    ["Alignment of sigstack"][::std::mem::align_of::<sigstack>() - 8usize];
    ["Offset of field: sigstack::ss_sp"][::std::mem::offset_of!(sigstack, ss_sp) - 0usize];
    ["Offset of field: sigstack::ss_onstack"]
        [::std::mem::offset_of!(sigstack, ss_onstack) - 8usize];
};
unsafe extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_lock_and_get(address: gpointer, lock_bit: guint, out_ptr: *mut guintptr);
}
unsafe extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
unsafe extern "C" {
    pub fn g_pointer_bit_lock_mask_ptr(
        ptr: gpointer,
        lock_bit: guint,
        set: gboolean,
        preserve_mask: guintptr,
        preserve_ptr: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_pointer_bit_unlock_and_set(
        address: *mut ::std::os::raw::c_void,
        lock_bit: guint,
        ptr: gpointer,
        preserve_mask: guintptr,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:\n @G_TIME_TYPE_STANDARD: the time is in local standard time\n @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time\n @G_TIME_TYPE_UNIVERSAL: the time is in UTC\n\n Disambiguates a given time in two ways.\n\n First, specifies if the given time is in universal or local time.\n\n Second, if the time is in local time, specifies if it is local\n standard time or local daylight time.  This is important for the case\n where the same local time occurs twice (during daylight savings time\n transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
unsafe extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
unsafe extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
unsafe extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n `GDateTime` is a structure that combines a Gregorian date and time\n into a single structure.\n\n `GDateTime` provides many conversion and methods to manipulate dates and times.\n Time precision is provided down to microseconds and the time can range\n (proleptically) from 0001-01-01 00:00:00 to 9999-12-31 23:59:59.999999.\n `GDateTime` follows POSIX time in the sense that it is oblivious to leap\n seconds.\n\n `GDateTime` is an immutable object; once it has been created it cannot\n be modified further. All modifiers will create a new `GDateTime`.\n Nearly all such functions can fail due to the date or time going out\n of range, in which case %NULL will be returned.\n\n `GDateTime` is reference counted: the reference count is increased by calling\n [method@GLib.DateTime.ref] and decreased by calling [method@GLib.DateTime.unref].\n When the reference count drops to 0, the resources allocated by the `GDateTime`\n structure are released.\n\n Many parts of the API may produce non-obvious results. As an\n example, adding two months to January 31st will yield March 31st\n whereas adding one month and then one month again will yield either\n March 28th or March 29th.  Also note that adding 24 hours is not\n always the same as adding one day (since days containing daylight\n savings time transitions are either 23 or 25 hours in length).\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
unsafe extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_local_usec(usecs: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_unix_utc_usec(usecs: gint64) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
unsafe extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
unsafe extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
unsafe extern "C" {
    pub fn g_date_time_to_unix_usec(datetime: *mut GDateTime) -> gint64;
}
unsafe extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
unsafe extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:\n @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed\n @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found\n @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did\n     not register a bookmark\n @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found\n @G_BOOKMARK_FILE_ERROR_READ: document was ill formed\n @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was\n     in an unknown encoding\n @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing\n @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found\n\n Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:\n\n `GBookmarkFile` lets you parse, edit or create files containing bookmarks.\n\n Bookmarks refer to a URI, along with some meta-data about the resource\n pointed by the URI like its MIME type, the application that is registering\n the bookmark and the icon that should be used to represent the bookmark.\n The data is stored using the\n [Desktop Bookmark Specification](http://www.gnome.org/~ebassi/bookmark-spec).\n\n The syntax of the bookmark files is described in detail inside the\n Desktop Bookmark Specification, here is a quick summary: bookmark\n files use a sub-class of the XML Bookmark Exchange Language\n specification, consisting of valid UTF-8 encoded XML, under the\n `<xbel>` root element; each bookmark is stored inside a\n `<bookmark>` element, using its URI: no relative paths can\n be used inside a bookmark file. The bookmark may have a user defined\n title and description, to be used instead of the URI. Under the\n `<metadata>` element, with its owner attribute set to\n `http://freedesktop.org`, is stored the meta-data about a resource\n pointed by its URI. The meta-data consists of the resource's MIME\n type; the applications that have registered a bookmark; the groups\n to which a bookmark belongs to; a visibility flag, used to set the\n bookmark as \"private\" to the applications and groups that has it\n registered; the URI and MIME type of an icon, to be used when\n displaying the bookmark inside a GUI.\n\n Here is an example of a bookmark file:\n [bookmarks.xbel](https://gitlab.gnome.org/GNOME/glib/-/blob/HEAD/glib/tests/bookmarks.xbel)\n\n A bookmark file might contain more than one bookmark; each bookmark\n is accessed through its URI.\n\n The important caveat of bookmark files is that when you add a new\n bookmark you must also add the application that is registering it, using\n [method@GLib.BookmarkFile.add_application] or [method@GLib.BookmarkFile.set_application_info].\n If a bookmark has no applications then it won't be dumped when creating\n the on disk representation, using [method@GLib.BookmarkFile.to_data] or\n [method@GLib.BookmarkFile.to_file].\n\n Since: 2.12"]
pub type GBookmarkFile = _GBookmarkFile;
unsafe extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
unsafe extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
unsafe extern "C" {
    pub fn g_bookmark_file_copy(bookmark: *mut GBookmarkFile) -> *mut GBookmarkFile;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        added: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        modified: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        visited: *mut GDateTime,
    );
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
unsafe extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
unsafe extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
unsafe extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:\n @G_CHECKSUM_MD5: Use the MD5 hashing algorithm\n @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm\n @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm\n @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)\n @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)\n\n The hashing algorithm to be used by #GChecksum when performing the\n digest of some data.\n\n Note that the #GChecksumType enumeration may be extended at a later\n date to include new hashing algorithm types.\n\n Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
pub type GChecksum = _GChecksum;
unsafe extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
unsafe extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
unsafe extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
unsafe extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
unsafe extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
unsafe extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
unsafe extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:\n @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character\n     sets is not supported.\n @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;\n    or the character sequence could not be represented in the target\n    character set.\n @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.\n @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.\n @G_CONVERT_ERROR_BAD_URI: URI is invalid.\n @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.\n @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40\n @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in\n     conversion output where a NUL-terminated string is expected.\n     Since: 2.56\n\n Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)\n\n The GIConv struct wraps an iconv() conversion descriptor. It contains\n private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
unsafe extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
unsafe extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
unsafe extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
unsafe extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
unsafe extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
unsafe extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: gsize,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
unsafe extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
unsafe extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
unsafe extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
unsafe extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
unsafe extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDate"][::std::mem::size_of::<_GDate>() - 8usize];
    ["Alignment of _GDate"][::std::mem::align_of::<_GDate>() - 4usize];
};
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_days_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                32u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_days_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                32u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn julian_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                32usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_julian_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                32usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn dmy_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                33usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_dmy_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                33usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn day_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                34usize,
                6u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_day_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                34usize,
                6u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn month_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                40usize,
                4u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_month_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                40usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn year_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 8usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                44usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_year_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 8usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                44usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
unsafe extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
unsafe extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
unsafe extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
unsafe extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
unsafe extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
unsafe extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
unsafe extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
unsafe extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
unsafe extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
unsafe extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
unsafe extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
unsafe extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
unsafe extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
unsafe extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
unsafe extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
unsafe extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
unsafe extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
unsafe extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
unsafe extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
unsafe extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
unsafe extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
unsafe extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
unsafe extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
unsafe extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dirent"][::std::mem::size_of::<dirent>() - 280usize];
    ["Alignment of dirent"][::std::mem::align_of::<dirent>() - 8usize];
    ["Offset of field: dirent::d_ino"][::std::mem::offset_of!(dirent, d_ino) - 0usize];
    ["Offset of field: dirent::d_off"][::std::mem::offset_of!(dirent, d_off) - 8usize];
    ["Offset of field: dirent::d_reclen"][::std::mem::offset_of!(dirent, d_reclen) - 16usize];
    ["Offset of field: dirent::d_type"][::std::mem::offset_of!(dirent, d_type) - 18usize];
    ["Offset of field: dirent::d_name"][::std::mem::offset_of!(dirent, d_name) - 19usize];
};
pub const DT_UNKNOWN: _bindgen_ty_10 = 0;
pub const DT_FIFO: _bindgen_ty_10 = 1;
pub const DT_CHR: _bindgen_ty_10 = 2;
pub const DT_DIR: _bindgen_ty_10 = 4;
pub const DT_BLK: _bindgen_ty_10 = 6;
pub const DT_REG: _bindgen_ty_10 = 8;
pub const DT_LNK: _bindgen_ty_10 = 10;
pub const DT_SOCK: _bindgen_ty_10 = 12;
pub const DT_WHT: _bindgen_ty_10 = 14;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
unsafe extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
unsafe extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
unsafe extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
unsafe extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
unsafe extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
unsafe extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
unsafe extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
unsafe extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_dir_ref(dir: *mut GDir) -> *mut GDir;
}
unsafe extern "C" {
    pub fn g_dir_unref(dir: *mut GDir);
}
unsafe extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
unsafe extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
#[doc = " GFileSetContentsFlags:\n @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.\n   The most dangerous setting, which is slightly faster than other settings.\n @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,\n   either the old version of the file or the new version of the file will be\n   available, but not a mixture. On Unix systems this equates to an `fsync()`\n   on the file and use of an atomic `rename()` of the new version of the file\n   over the old.\n @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the\n   new version of the file will be available. On Unix systems this equates to\n   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or\n   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the\n   directory containing the file after calling `rename()`.\n @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability\n   guarantees if the file already exists. This may speed up file operations\n   if the file doesn’t currently exist, but may result in a corrupted version\n   of the new file if the system crashes while writing it.\n\n Flags to pass to g_file_set_contents_full() to affect its safety and\n performance.\n\n Since: 2.66"]
pub type GFileSetContentsFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
unsafe extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:\n @malloc: function to use for allocating memory.\n @realloc: function to use for reallocating memory.\n @free: function to use to free memory.\n @calloc: function to use for allocating zero-filled memory.\n @try_malloc: function to use for allocating memory without a default error handler.\n @try_realloc: function to use for reallocating memory without a default error handler.\n\n A set of functions used to perform memory allocation. The same #GMemVTable must\n be used for all allocations in the same program; a call to g_mem_set_vtable(),\n if it exists, should be prior to any use of GLib.\n\n This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
unsafe extern "C" {
    pub fn g_free(mem: gpointer);
}
unsafe extern "C" {
    pub fn g_free_sized(mem: gpointer, size: usize);
}
unsafe extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_aligned_free(mem: gpointer);
}
unsafe extern "C" {
    pub fn g_aligned_free_sized(mem: gpointer, alignment: usize, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemVTable"][::std::mem::size_of::<_GMemVTable>() - 48usize];
    ["Alignment of _GMemVTable"][::std::mem::align_of::<_GMemVTable>() - 8usize];
    ["Offset of field: _GMemVTable::malloc"][::std::mem::offset_of!(_GMemVTable, malloc) - 0usize];
    ["Offset of field: _GMemVTable::realloc"]
        [::std::mem::offset_of!(_GMemVTable, realloc) - 8usize];
    ["Offset of field: _GMemVTable::free"][::std::mem::offset_of!(_GMemVTable, free) - 16usize];
    ["Offset of field: _GMemVTable::calloc"][::std::mem::offset_of!(_GMemVTable, calloc) - 24usize];
    ["Offset of field: _GMemVTable::try_malloc"]
        [::std::mem::offset_of!(_GMemVTable, try_malloc) - 32usize];
    ["Offset of field: _GMemVTable::try_realloc"]
        [::std::mem::offset_of!(_GMemVTable, try_realloc) - 40usize];
};
unsafe extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
unsafe extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
unsafe extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
unsafe extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
unsafe extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNode"][::std::mem::size_of::<_GNode>() - 40usize];
    ["Alignment of _GNode"][::std::mem::align_of::<_GNode>() - 8usize];
    ["Offset of field: _GNode::data"][::std::mem::offset_of!(_GNode, data) - 0usize];
    ["Offset of field: _GNode::next"][::std::mem::offset_of!(_GNode, next) - 8usize];
    ["Offset of field: _GNode::prev"][::std::mem::offset_of!(_GNode, prev) - 16usize];
    ["Offset of field: _GNode::parent"][::std::mem::offset_of!(_GNode, parent) - 24usize];
    ["Offset of field: _GNode::children"][::std::mem::offset_of!(_GNode, children) - 32usize];
};
unsafe extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
unsafe extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
unsafe extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
unsafe extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
unsafe extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
unsafe extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
unsafe extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GList"][::std::mem::size_of::<_GList>() - 24usize];
    ["Alignment of _GList"][::std::mem::align_of::<_GList>() - 8usize];
    ["Offset of field: _GList::data"][::std::mem::offset_of!(_GList, data) - 0usize];
    ["Offset of field: _GList::next"][::std::mem::offset_of!(_GList, next) - 8usize];
    ["Offset of field: _GList::prev"][::std::mem::offset_of!(_GList, prev) - 16usize];
};
unsafe extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_free(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
unsafe extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
unsafe extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHashTableIter"][::std::mem::size_of::<_GHashTableIter>() - 40usize];
    ["Alignment of _GHashTableIter"][::std::mem::align_of::<_GHashTableIter>() - 8usize];
    ["Offset of field: _GHashTableIter::dummy1"]
        [::std::mem::offset_of!(_GHashTableIter, dummy1) - 0usize];
    ["Offset of field: _GHashTableIter::dummy2"]
        [::std::mem::offset_of!(_GHashTableIter, dummy2) - 8usize];
    ["Offset of field: _GHashTableIter::dummy3"]
        [::std::mem::offset_of!(_GHashTableIter, dummy3) - 16usize];
    ["Offset of field: _GHashTableIter::dummy4"]
        [::std::mem::offset_of!(_GHashTableIter, dummy4) - 24usize];
    ["Offset of field: _GHashTableIter::dummy5"]
        [::std::mem::offset_of!(_GHashTableIter, dummy5) - 28usize];
    ["Offset of field: _GHashTableIter::dummy6"]
        [::std::mem::offset_of!(_GHashTableIter, dummy6) - 32usize];
};
unsafe extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all_keys(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_steal_all_values(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
unsafe extern "C" {
    pub fn g_hash_table_get_keys_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_get_values_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
unsafe extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
unsafe extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
unsafe extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
unsafe extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
pub type GHmac = _GHmac;
unsafe extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
unsafe extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
unsafe extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
unsafe extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHookList"][::std::mem::size_of::<_GHookList>() - 56usize];
    ["Alignment of _GHookList"][::std::mem::align_of::<_GHookList>() - 8usize];
    ["Offset of field: _GHookList::seq_id"][::std::mem::offset_of!(_GHookList, seq_id) - 0usize];
    ["Offset of field: _GHookList::hooks"][::std::mem::offset_of!(_GHookList, hooks) - 16usize];
    ["Offset of field: _GHookList::dummy3"][::std::mem::offset_of!(_GHookList, dummy3) - 24usize];
    ["Offset of field: _GHookList::finalize_hook"]
        [::std::mem::offset_of!(_GHookList, finalize_hook) - 32usize];
    ["Offset of field: _GHookList::dummy"][::std::mem::offset_of!(_GHookList, dummy) - 40usize];
};
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn hook_size_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                16u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_hook_size_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                16u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_setup_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_setup_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GHook"][::std::mem::size_of::<_GHook>() - 64usize];
    ["Alignment of _GHook"][::std::mem::align_of::<_GHook>() - 8usize];
    ["Offset of field: _GHook::data"][::std::mem::offset_of!(_GHook, data) - 0usize];
    ["Offset of field: _GHook::next"][::std::mem::offset_of!(_GHook, next) - 8usize];
    ["Offset of field: _GHook::prev"][::std::mem::offset_of!(_GHook, prev) - 16usize];
    ["Offset of field: _GHook::ref_count"][::std::mem::offset_of!(_GHook, ref_count) - 24usize];
    ["Offset of field: _GHook::hook_id"][::std::mem::offset_of!(_GHook, hook_id) - 32usize];
    ["Offset of field: _GHook::flags"][::std::mem::offset_of!(_GHook, flags) - 40usize];
    ["Offset of field: _GHook::func"][::std::mem::offset_of!(_GHook, func) - 48usize];
    ["Offset of field: _GHook::destroy"][::std::mem::offset_of!(_GHook, destroy) - 56usize];
};
unsafe extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
unsafe extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
unsafe extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
unsafe extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
unsafe extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
unsafe extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
unsafe extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:\n @ufds: an array of #GPollFD elements\n @nfsd: the number of elements in @ufds\n @timeout_: the maximum time to wait for an event of the file descriptors.\n     A negative value indicates an infinite timeout.\n\n Specifies the type of function passed to g_main_context_set_poll_func().\n The semantics of the function should match those of the poll() system call.\n\n Returns: the number of #GPollFD elements which have events or errors\n     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPollFD"][::std::mem::size_of::<_GPollFD>() - 8usize];
    ["Alignment of _GPollFD"][::std::mem::align_of::<_GPollFD>() - 4usize];
    ["Offset of field: _GPollFD::fd"][::std::mem::offset_of!(_GPollFD, fd) - 0usize];
    ["Offset of field: _GPollFD::events"][::std::mem::offset_of!(_GPollFD, events) - 4usize];
    ["Offset of field: _GPollFD::revents"][::std::mem::offset_of!(_GPollFD, revents) - 6usize];
};
unsafe extern "C" {
    #[doc = " G_POLLFD_FORMAT:\n\n A format specifier that can be used in printf()-style format strings\n when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSList"][::std::mem::size_of::<_GSList>() - 16usize];
    ["Alignment of _GSList"][::std::mem::align_of::<_GSList>() - 8usize];
    ["Offset of field: _GSList::data"][::std::mem::offset_of!(_GSList, data) - 0usize];
    ["Offset of field: _GSList::next"][::std::mem::offset_of!(_GSList, next) - 8usize];
};
unsafe extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
unsafe extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
unsafe extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
#[doc = " GMainContextFlags:\n @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.\n @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will\n free the thread to process other jobs. That's useful if you're using\n `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in\n other event loops.\n\n Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n of a #GMainContext.\n\n Since: 2.72"]
pub type GMainContextFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:\n\n The `GMainContext` struct is an opaque data\n type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:\n\n The `GMainLoop` struct is an opaque data type\n representing the main event loop of a GLib or GTK application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:\n\n The `GSource` struct is an opaque data type\n representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:\n @ref: Called when a reference is added to the callback object\n @unref: Called when a reference to the callback object is dropped\n @get: Called to extract the callback function and data from the\n     callback object.\n\n The `GSourceCallbackFuncs` struct contains\n functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:\n @prepare: Called before all the file descriptors are polled. If the\n     source can determine that it is ready here (without waiting for the\n     results of the poll() call) it should return %TRUE. It can also return\n     a @timeout_ value which should be the maximum timeout (in milliseconds)\n     which should be passed to the poll() call. The actual timeout used will\n     be -1 if all sources returned -1, or it will be the minimum of all\n     the @timeout_ values returned which were >= 0.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE with a timeout of -1.  If @prepare returns a\n     timeout and the source also has a ready time set, then the\n     lower of the two will be used.\n @check: Called after all the file descriptors are polled. The source\n     should return %TRUE if it is ready to be dispatched. Note that some\n     time may have passed since the previous prepare function was called,\n     so the source should be checked again here.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE.\n @dispatch: Called to dispatch the event source, after it has returned\n     %TRUE in either its @prepare or its @check function, or if a ready time\n     has been reached. The @dispatch function receives a callback function and\n     user data. The callback function may be %NULL if the source was never\n     connected to a callback using g_source_set_callback(). The @dispatch\n     function should call the callback function with @user_data and whatever\n     additional parameters are needed for this type of event source. The\n     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n     source should be removed or %G_SOURCE_CONTINUE to keep it.\n @finalize: Called when the source is finalized. At this point, the source\n     will have been destroyed, had its callback cleared, and have been removed\n     from its #GMainContext, but it will still have its final reference count,\n     so methods can be called on it from within this function.\n\n The `GSourceFuncs` struct contains a table of\n functions used to handle event sources in a generic manner.\n\n For idle sources, the prepare and check functions always return %TRUE\n to indicate that the source is always ready to be processed. The prepare\n function also returns a timeout value of 0 to ensure that the poll() call\n doesn't block (since that would be time wasted which could have been spent\n running the idle function).\n\n For timeout sources, the prepare and check functions both return %TRUE\n if the timeout interval has expired. The prepare function also returns\n a timeout value to ensure that the poll() call doesn't block too long\n and miss the next timeout.\n\n For file descriptor sources, the prepare function typically returns %FALSE,\n since it must wait until poll() has been called before it knows whether\n any events need to be processed. It sets the returned timeout to -1 to\n indicate that it doesn't mind how long the poll() call blocks. In the\n check function, it tests the results of the poll() call to see if the\n required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:\n @user_data: data passed to the function, set when the source was\n     created with one of the above functions\n\n Specifies the type of function passed to g_timeout_add(),\n g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n\n When calling g_source_set_callback(), you may need to cast a function of a\n different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n incompatible function types.\n\n Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n %G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GSourceOnceFunc:\n @user_data: data passed to the function, set when the source was\n   created\n\n A source function that is only called once before being removed from the main\n context automatically.\n\n See: g_idle_add_once(), g_timeout_add_once()\n\n Since: 2.74"]
pub type GSourceOnceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[doc = " GChildWatchFunc:\n @pid: the process id of the child process\n @wait_status: Status information about the child process, encoded\n               in a platform-specific manner\n @user_data: user data passed to g_child_watch_add()\n\n Prototype of a #GChildWatchSource callback, called when a child\n process has exited.\n\n To interpret @wait_status, see the documentation\n for g_spawn_check_wait_status(). In particular,\n on Unix platforms, note that it is usually not equal\n to the integer passed to `exit()` or returned from `main()`."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:\n @source: #GSource that is currently being disposed\n\n Dispose function for @source. See g_source_set_dispose_function() for\n details.\n\n Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSource"][::std::mem::size_of::<_GSource>() - 96usize];
    ["Alignment of _GSource"][::std::mem::align_of::<_GSource>() - 8usize];
    ["Offset of field: _GSource::callback_data"]
        [::std::mem::offset_of!(_GSource, callback_data) - 0usize];
    ["Offset of field: _GSource::callback_funcs"]
        [::std::mem::offset_of!(_GSource, callback_funcs) - 8usize];
    ["Offset of field: _GSource::source_funcs"]
        [::std::mem::offset_of!(_GSource, source_funcs) - 16usize];
    ["Offset of field: _GSource::ref_count"][::std::mem::offset_of!(_GSource, ref_count) - 24usize];
    ["Offset of field: _GSource::context"][::std::mem::offset_of!(_GSource, context) - 32usize];
    ["Offset of field: _GSource::priority"][::std::mem::offset_of!(_GSource, priority) - 40usize];
    ["Offset of field: _GSource::flags"][::std::mem::offset_of!(_GSource, flags) - 44usize];
    ["Offset of field: _GSource::source_id"][::std::mem::offset_of!(_GSource, source_id) - 48usize];
    ["Offset of field: _GSource::poll_fds"][::std::mem::offset_of!(_GSource, poll_fds) - 56usize];
    ["Offset of field: _GSource::prev"][::std::mem::offset_of!(_GSource, prev) - 64usize];
    ["Offset of field: _GSource::next"][::std::mem::offset_of!(_GSource, next) - 72usize];
    ["Offset of field: _GSource::name"][::std::mem::offset_of!(_GSource, name) - 80usize];
    ["Offset of field: _GSource::priv_"][::std::mem::offset_of!(_GSource, priv_) - 88usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSourceCallbackFuncs"][::std::mem::size_of::<_GSourceCallbackFuncs>() - 24usize];
    ["Alignment of _GSourceCallbackFuncs"]
        [::std::mem::align_of::<_GSourceCallbackFuncs>() - 8usize];
    ["Offset of field: _GSourceCallbackFuncs::ref_"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, ref_) - 0usize];
    ["Offset of field: _GSourceCallbackFuncs::unref"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, unref) - 8usize];
    ["Offset of field: _GSourceCallbackFuncs::get"]
        [::std::mem::offset_of!(_GSourceCallbackFuncs, get) - 16usize];
};
#[doc = " GSourceDummyMarshal:\n\n This is just a placeholder for #GClosureMarshal,\n which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSourceFuncs"][::std::mem::size_of::<_GSourceFuncs>() - 48usize];
    ["Alignment of _GSourceFuncs"][::std::mem::align_of::<_GSourceFuncs>() - 8usize];
    ["Offset of field: _GSourceFuncs::prepare"]
        [::std::mem::offset_of!(_GSourceFuncs, prepare) - 0usize];
    ["Offset of field: _GSourceFuncs::check"]
        [::std::mem::offset_of!(_GSourceFuncs, check) - 8usize];
    ["Offset of field: _GSourceFuncs::dispatch"]
        [::std::mem::offset_of!(_GSourceFuncs, dispatch) - 16usize];
    ["Offset of field: _GSourceFuncs::finalize"]
        [::std::mem::offset_of!(_GSourceFuncs, finalize) - 24usize];
    ["Offset of field: _GSourceFuncs::closure_callback"]
        [::std::mem::offset_of!(_GSourceFuncs, closure_callback) - 32usize];
    ["Offset of field: _GSourceFuncs::closure_marshal"]
        [::std::mem::offset_of!(_GSourceFuncs, closure_marshal) - 40usize];
};
unsafe extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
unsafe extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
unsafe extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
unsafe extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_main_depth() -> gint;
}
unsafe extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
unsafe extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:\n\n Opaque type. See g_main_context_pusher_new() for details.\n\n Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
unsafe extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
unsafe extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
unsafe extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
unsafe extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
unsafe extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
unsafe extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
unsafe extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
unsafe extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
unsafe extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
unsafe extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
unsafe extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_set_static_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
unsafe extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
unsafe extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
unsafe extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
unsafe extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
unsafe extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
unsafe extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
unsafe extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
unsafe extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
unsafe extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
unsafe extern "C" {
    pub fn g_get_real_time() -> gint64;
}
unsafe extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:\n @handle_id: the handle ID to clear\n\n Specifies the type of function passed to g_clear_handle_id().\n The implementation is expected to free the resource identified\n by @handle_id; for instance, if @handle_id is a #GSource ID,\n g_source_remove() can be used.\n\n Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
unsafe extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
unsafe extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_timeout_add_seconds_once(
        interval: guint,
        function: GSourceOnceFunc,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
unsafe extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
unsafe extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:\n\n A type which can hold any UTF-16 code\n point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called\n <firstterm>surrogate pairs</firstterm> to encode characters beyond\n the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored\n in a single gunichar2 field, but all GLib functions accepting gunichar2\n arrays will correctly interpret surrogate pairs.</footnote>.\n\n To print/scan values of this type to/from text you need to convert\n to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().\n\n To print/scan values of this type as integer, use\n %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:\n @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)\n @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)\n @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)\n @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)\n @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)\n @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)\n @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)\n @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)\n @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)\n @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)\n @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)\n @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)\n @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)\n @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)\n @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)\n @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)\n @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)\n @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)\n @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)\n @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)\n @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)\n @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)\n @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)\n @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)\n @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)\n @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)\n @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)\n @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)\n @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)\n @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)\n\n These are the possible character classifications from the\n Unicode specification.\n See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AKSARA: GUnicodeBreakType = 43;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AKSARA_PRE_BASE: GUnicodeBreakType = 44;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AKSARA_START: GUnicodeBreakType = 45;
pub const GUnicodeBreakType_G_UNICODE_BREAK_VIRAMA_FINAL: GUnicodeBreakType = 46;
pub const GUnicodeBreakType_G_UNICODE_BREAK_VIRAMA: GUnicodeBreakType = 47;
#[doc = " GUnicodeBreakType:\n @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)\n @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)\n @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)\n @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)\n @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)\n @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)\n @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)\n @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)\n @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)\n @G_UNICODE_BREAK_SPACE: Space (SP)\n @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)\n @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)\n @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)\n @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)\n @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)\n @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)\n @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)\n @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)\n @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)\n @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)\n @G_UNICODE_BREAK_NUMERIC: Numeric (NU)\n @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)\n @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)\n @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)\n @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)\n @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)\n @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)\n @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)\n @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)\n @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)\n @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)\n @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)\n @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)\n @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)\n @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)\n @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)\n @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.\n @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70\n @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32\n @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32\n @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36\n @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50\n @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50\n @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50\n @G_UNICODE_BREAK_AKSARA: Aksara (AK). Since: 2.80\n @G_UNICODE_BREAK_AKSARA_PRE_BASE (AP). Since: 2.80\n @G_UNICODE_BREAK_AKSARA_START (AS). Since: 2.80\n @G_UNICODE_BREAK_VIRAMA_FINAL (VF). Since: 2.80\n @G_UNICODE_BREAK_VIRAMA (VI). Since: 2.80\n\n These are the possible line break classifications.\n\n Since new Unicode versions may add new types here, applications should be ready\n to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.\n\n See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n @G_UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74\n @G_UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
unsafe extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
unsafe extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
unsafe extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
unsafe extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
unsafe extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
unsafe extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
unsafe extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
unsafe extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
unsafe extern "C" {
    pub static g_utf8_skip: *const gchar;
}
unsafe extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
unsafe extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
unsafe extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_truncate_middle(string: *const gchar, truncate_length: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
unsafe extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
unsafe extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
unsafe extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
unsafe extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:\n @G_NORMALIZE_DEFAULT: standardize differences that do not affect the\n     text content, such as the above-mentioned accent representation\n @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT\n @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with\n     composed forms rather than a maximally decomposed form\n @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE\n @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the\n     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE\n     to the standard forms (in this case DIGIT THREE). Formatting\n     information may be lost but for most text operations such\n     characters should be considered the same\n @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL\n @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed\n     forms rather than a maximally decomposed form\n @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE\n\n Defines how a Unicode string is transformed in a canonical\n form, standardizing such issues as whether a character with\n an accent is represented as a base character and combining\n accent or as a single precomposed character. Unicode strings\n should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub static g_ascii_table: *const guint16;
}
unsafe extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
unsafe extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
unsafe extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
unsafe extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
unsafe extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
unsafe extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
unsafe extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
unsafe extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
unsafe extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
unsafe extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:\n @G_NUMBER_PARSER_ERROR_INVALID: string was not a valid number\n @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: string was a number, but out of bounds\n\n Error codes returned by functions converting a string to a number.\n\n Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GString"][::std::mem::size_of::<_GString>() - 24usize];
    ["Alignment of _GString"][::std::mem::align_of::<_GString>() - 8usize];
    ["Offset of field: _GString::str_"][::std::mem::offset_of!(_GString, str_) - 0usize];
    ["Offset of field: _GString::len"][::std::mem::offset_of!(_GString, len) - 8usize];
    ["Offset of field: _GString::allocated_len"]
        [::std::mem::offset_of!(_GString, allocated_len) - 16usize];
};
unsafe extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_new_take(init: *mut gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_free_and_steal(string: *mut GString) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
unsafe extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
unsafe extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
unsafe extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const GIOFlags_G_IO_FLAG_NONE: GIOFlags = 0;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOChannel"][::std::mem::size_of::<_GIOChannel>() - 112usize];
    ["Alignment of _GIOChannel"][::std::mem::align_of::<_GIOChannel>() - 8usize];
    ["Offset of field: _GIOChannel::ref_count"]
        [::std::mem::offset_of!(_GIOChannel, ref_count) - 0usize];
    ["Offset of field: _GIOChannel::funcs"][::std::mem::offset_of!(_GIOChannel, funcs) - 8usize];
    ["Offset of field: _GIOChannel::encoding"]
        [::std::mem::offset_of!(_GIOChannel, encoding) - 16usize];
    ["Offset of field: _GIOChannel::read_cd"]
        [::std::mem::offset_of!(_GIOChannel, read_cd) - 24usize];
    ["Offset of field: _GIOChannel::write_cd"]
        [::std::mem::offset_of!(_GIOChannel, write_cd) - 32usize];
    ["Offset of field: _GIOChannel::line_term"]
        [::std::mem::offset_of!(_GIOChannel, line_term) - 40usize];
    ["Offset of field: _GIOChannel::line_term_len"]
        [::std::mem::offset_of!(_GIOChannel, line_term_len) - 48usize];
    ["Offset of field: _GIOChannel::buf_size"]
        [::std::mem::offset_of!(_GIOChannel, buf_size) - 56usize];
    ["Offset of field: _GIOChannel::read_buf"]
        [::std::mem::offset_of!(_GIOChannel, read_buf) - 64usize];
    ["Offset of field: _GIOChannel::encoded_read_buf"]
        [::std::mem::offset_of!(_GIOChannel, encoded_read_buf) - 72usize];
    ["Offset of field: _GIOChannel::write_buf"]
        [::std::mem::offset_of!(_GIOChannel, write_buf) - 80usize];
    ["Offset of field: _GIOChannel::partial_write_buf"]
        [::std::mem::offset_of!(_GIOChannel, partial_write_buf) - 88usize];
    ["Offset of field: _GIOChannel::reserved1"]
        [::std::mem::offset_of!(_GIOChannel, reserved1) - 96usize];
    ["Offset of field: _GIOChannel::reserved2"]
        [::std::mem::offset_of!(_GIOChannel, reserved2) - 104usize];
};
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn use_buffer_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_use_buffer_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn do_encode_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_do_encode_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn close_on_unref_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_close_on_unref_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_readable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_readable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_writeable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_writeable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_seekable_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_seekable_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOFuncs"][::std::mem::size_of::<_GIOFuncs>() - 64usize];
    ["Alignment of _GIOFuncs"][::std::mem::align_of::<_GIOFuncs>() - 8usize];
    ["Offset of field: _GIOFuncs::io_read"][::std::mem::offset_of!(_GIOFuncs, io_read) - 0usize];
    ["Offset of field: _GIOFuncs::io_write"][::std::mem::offset_of!(_GIOFuncs, io_write) - 8usize];
    ["Offset of field: _GIOFuncs::io_seek"][::std::mem::offset_of!(_GIOFuncs, io_seek) - 16usize];
    ["Offset of field: _GIOFuncs::io_close"][::std::mem::offset_of!(_GIOFuncs, io_close) - 24usize];
    ["Offset of field: _GIOFuncs::io_create_watch"]
        [::std::mem::offset_of!(_GIOFuncs, io_create_watch) - 32usize];
    ["Offset of field: _GIOFuncs::io_free"][::std::mem::offset_of!(_GIOFuncs, io_free) - 40usize];
    ["Offset of field: _GIOFuncs::io_set_flags"]
        [::std::mem::offset_of!(_GIOFuncs, io_set_flags) - 48usize];
    ["Offset of field: _GIOFuncs::io_get_flags"]
        [::std::mem::offset_of!(_GIOFuncs, io_get_flags) - 56usize];
};
unsafe extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
unsafe extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
unsafe extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
unsafe extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
unsafe extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
unsafe extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
unsafe extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
unsafe extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
unsafe extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
unsafe extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
unsafe extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
unsafe extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
unsafe extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
unsafe extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
unsafe extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
unsafe extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
unsafe extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
unsafe extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
unsafe extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
unsafe extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
unsafe extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
unsafe extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
unsafe extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:\n @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8\n @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace\n @G_MARKUP_ERROR_PARSE: document was ill-formed\n @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser\n     functions; element wasn't known\n @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; attribute wasn't known\n @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser\n     functions; content was invalid\n @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; a required attribute was missing\n\n Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:\n @G_MARKUP_DEFAULT_FLAGS: No special behaviour. Since: 2.74\n @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use\n @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked\n     sections are not passed literally to the @passthrough function of\n     the parser. Instead, the content of the section (without the\n     `<![CDATA[` and `]]>`) is\n     passed to the @text function. This flag was added in GLib 2.12\n @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup\n     itself have line/column information prefixed to them to let the\n     caller know the location of the error. When this flag is set the\n     location information is also prefixed to errors generated by the\n     #GMarkupParser implementation functions\n @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified\n     attributes and tags, along with their contents.  A qualified\n     attribute or tag is one that contains ':' in its name (ie: is in\n     another namespace).  Since: 2.40.\n\n Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMarkupParser"][::std::mem::size_of::<_GMarkupParser>() - 40usize];
    ["Alignment of _GMarkupParser"][::std::mem::align_of::<_GMarkupParser>() - 8usize];
    ["Offset of field: _GMarkupParser::start_element"]
        [::std::mem::offset_of!(_GMarkupParser, start_element) - 0usize];
    ["Offset of field: _GMarkupParser::end_element"]
        [::std::mem::offset_of!(_GMarkupParser, end_element) - 8usize];
    ["Offset of field: _GMarkupParser::text"]
        [::std::mem::offset_of!(_GMarkupParser, text) - 16usize];
    ["Offset of field: _GMarkupParser::passthrough"]
        [::std::mem::offset_of!(_GMarkupParser, passthrough) - 24usize];
    ["Offset of field: _GMarkupParser::error"]
        [::std::mem::offset_of!(_GMarkupParser, error) - 32usize];
};
unsafe extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
unsafe extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
unsafe extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
unsafe extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
pub type GVariantType = _GVariantType;
unsafe extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_checked_(type_string: *const gchar) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
unsafe extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
unsafe extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
unsafe extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
unsafe extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
unsafe extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
unsafe extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
unsafe extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
unsafe extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
unsafe extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
unsafe extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
unsafe extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
unsafe extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
unsafe extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
unsafe extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [guintptr; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantIter"][::std::mem::size_of::<_GVariantIter>() - 128usize];
    ["Alignment of _GVariantIter"][::std::mem::align_of::<_GVariantIter>() - 8usize];
    ["Offset of field: _GVariantIter::x"][::std::mem::offset_of!(_GVariantIter, x) - 0usize];
};
unsafe extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
unsafe extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
unsafe extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
unsafe extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
unsafe extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [guintptr; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [guintptr; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantBuilder__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::partial_magic"][::std::mem::offset_of!(
        _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
        partial_magic
    ) - 0usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::type_"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1, type_) - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1::y"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1, y) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantBuilder__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1::s"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1, s) - 0usize];
    ["Offset of field: _GVariantBuilder__bindgen_ty_1::x"]
        [::std::mem::offset_of!(_GVariantBuilder__bindgen_ty_1, x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantBuilder"][::std::mem::size_of::<_GVariantBuilder>() - 128usize];
    ["Alignment of _GVariantBuilder"][::std::mem::align_of::<_GVariantBuilder>() - 8usize];
    ["Offset of field: _GVariantBuilder::u"][::std::mem::offset_of!(_GVariantBuilder, u) - 0usize];
};
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
unsafe extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
unsafe extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
unsafe extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
unsafe extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
unsafe extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [guintptr; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [guintptr; 14usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantDict__bindgen_ty_1__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::asv"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, asv) - 0usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::partial_magic"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, partial_magic) - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1__bindgen_ty_1::y"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1__bindgen_ty_1, y) - 16usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict__bindgen_ty_1"]
        [::std::mem::size_of::<_GVariantDict__bindgen_ty_1>() - 128usize];
    ["Alignment of _GVariantDict__bindgen_ty_1"]
        [::std::mem::align_of::<_GVariantDict__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1::s"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1, s) - 0usize];
    ["Offset of field: _GVariantDict__bindgen_ty_1::x"]
        [::std::mem::offset_of!(_GVariantDict__bindgen_ty_1, x) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVariantDict"][::std::mem::size_of::<_GVariantDict>() - 128usize];
    ["Alignment of _GVariantDict"][::std::mem::align_of::<_GVariantDict>() - 8usize];
    ["Offset of field: _GVariantDict::u"][::std::mem::offset_of!(_GVariantDict, u) - 0usize];
};
unsafe extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
unsafe extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
unsafe extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
unsafe extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
unsafe extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
unsafe extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
unsafe extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:\n @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.\n @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.\n\n Return values from #GLogWriterFuncs to indicate whether the given log entry\n was successfully handled by the writer, or whether there was an error in\n handling it (and hence a fallback writer should be used).\n\n If a #GLogWriterFunc ignores a log entry, it should return\n %G_LOG_WRITER_HANDLED.\n\n Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_uint;
#[doc = " GLogField:\n @key: field name (UTF-8 string)\n @value: field value (arbitrary bytes)\n @length: length of @value, in bytes, or -1 if it is nul-terminated\n\n Structure representing a single field in a structured log entry. See\n g_log_structured() for details.\n\n Log fields may contain arbitrary values, including binary with embedded nul\n bytes. If the field contains a string, the string must be UTF-8 encoded and\n have a trailing nul byte. Otherwise, @length must be set to a non-negative\n value.\n\n Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GLogField"][::std::mem::size_of::<_GLogField>() - 24usize];
    ["Alignment of _GLogField"][::std::mem::align_of::<_GLogField>() - 8usize];
    ["Offset of field: _GLogField::key"][::std::mem::offset_of!(_GLogField, key) - 0usize];
    ["Offset of field: _GLogField::value"][::std::mem::offset_of!(_GLogField, value) - 8usize];
    ["Offset of field: _GLogField::length"][::std::mem::offset_of!(_GLogField, length) - 16usize];
};
#[doc = " GLogWriterFunc:\n @log_level: log level of the message\n @fields: (array length=n_fields): fields forming the message\n @n_fields: number of @fields\n @user_data: user data passed to g_log_set_writer_func()\n\n Writer function for log entries. A log entry is a collection of one or more\n #GLogFields, using the standard [field names from journal\n specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).\n See g_log_structured() for more information.\n\n Writer functions must ignore fields which they do not recognise, unless they\n can write arbitrary binary output, as field values may be arbitrary binary.\n\n @log_level is guaranteed to be included in @fields as the `PRIORITY` field,\n but is provided separately for convenience of deciding whether or where to\n output the log entry.\n\n Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log\n message successfully or if they deliberately ignored it. If there was an\n error handling the message (for example, if the writer function is meant to\n send messages to a remote logging server and there is a network error), it\n should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be\n chained and fall back to simpler handlers in case of failure.\n\n Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;\n   %G_LOG_WRITER_UNHANDLED otherwise\n\n Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
unsafe extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
unsafe extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
unsafe extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_log_writer_syslog(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
unsafe extern "C" {
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
}
unsafe extern "C" {
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_writer_default_set_debug_domains(domains: *const *const gchar);
}
unsafe extern "C" {
    pub fn g_log_get_debug_enabled() -> gboolean;
}
unsafe extern "C" {
    pub fn g_log_set_debug_enabled(enabled: gboolean);
}
unsafe extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:\n @string: the message to output\n\n Specifies the type of the print handler functions.\n These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
unsafe extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
unsafe extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:\n\n A `GOptionContext` struct defines which options\n are accepted by the commandline option parser. The struct has only private\n fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:\n\n A `GOptionGroup` struct defines the options in a single\n group. The struct has only private fields and should not be directly accessed.\n\n All options in a group share the same translation function. Libraries which\n need to parse commandline options are expected to provide a function for\n getting a `GOptionGroup` holding their options, which\n the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n      - %G_OPTION_ARG_NONE: %gboolean\n      - %G_OPTION_ARG_STRING: %gchar*\n      - %G_OPTION_ARG_INT: %gint\n      - %G_OPTION_ARG_FILENAME: %gchar*\n      - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n      - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n      - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:\n @G_OPTION_FLAG_NONE: No flags. Since: 2.42.\n @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.\n @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the\n     `--help` output, even if it is defined in a group.\n @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this\n     flag indicates that the sense of the option is reversed. i.e. %FALSE will\n     be stored into the argument rather than %TRUE.\n @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,\n     this flag indicates that the callback does not take any argument\n     (like a %G_OPTION_ARG_NONE option). Since 2.8\n @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument should be passed to the\n     callback in the GLib filename encoding rather than UTF-8. Since 2.8\n @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument supply is optional.\n     If no argument is given then data of %GOptionParseFunc will be\n     set to NULL. Since 2.8\n @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict\n     resolution which prefixes long option names with `groupname-` if\n     there is a conflict. This option should only be used in situations\n     where aliasing is necessary to model some legacy commandline interface.\n     It is not safe to use this option, unless all option groups are under\n     your direct control. Since 2.8.\n\n Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:\n @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags or booleans.\n @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.\n @G_OPTION_ARG_INT: The option takes an integer argument.\n @G_OPTION_ARG_CALLBACK: The option provides a callback (of type\n     #GOptionArgFunc) to parse the extra argument.\n @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will\nbe in the GLib filename encoding rather than UTF-8.\n @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple\n     uses of the option are collected into an array of strings.\n @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,\n     multiple uses of the option are collected into an array of strings.\n @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument\n     can be formatted either for the user's locale or for the \"C\" locale.\n     Since 2.12\n @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like\n     %G_OPTION_ARG_INT but for larger numbers. The number can be in\n     decimal base, or in hexadecimal (when prefixed with `0x`, for\n     example, `0xffffffff`). Since 2.12\n\n The #GOptionArg enum values determine which type of extra argument the\n options expect to find. If an option expects an extra argument, it can\n be specified in several ways; with a short option: `-x arg`, with a long\n option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_uint;
#[doc = " GOptionArgFunc:\n @option_name: The name of the option being parsed. This will be either a\n  single dash followed by a single letter (for a short name) or two dashes\n  followed by a long option name.\n @value: The value to be parsed.\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED\n  is intended to be used for errors in #GOptionArgFunc callbacks.\n\n The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK\n options.\n\n Returns: %TRUE if the option was successfully parsed, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for error details\n\n The type of function that can be called before and after parsing.\n\n Returns: %TRUE if the function completed successfully, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: The #GError containing details about the parse error\n\n The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:\n @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.\n  This error will only be reported, if the parser hasn't been instructed\n  to ignore unknown options, see g_option_context_set_ignore_unknown_options().\n @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.\n @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.\n\n Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n      - %G_OPTION_ARG_NONE: %gboolean\n      - %G_OPTION_ARG_STRING: %gchar*\n      - %G_OPTION_ARG_INT: %gint\n      - %G_OPTION_ARG_FILENAME: %gchar*\n      - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n      - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n      - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOptionEntry"][::std::mem::size_of::<_GOptionEntry>() - 48usize];
    ["Alignment of _GOptionEntry"][::std::mem::align_of::<_GOptionEntry>() - 8usize];
    ["Offset of field: _GOptionEntry::long_name"]
        [::std::mem::offset_of!(_GOptionEntry, long_name) - 0usize];
    ["Offset of field: _GOptionEntry::short_name"]
        [::std::mem::offset_of!(_GOptionEntry, short_name) - 8usize];
    ["Offset of field: _GOptionEntry::flags"]
        [::std::mem::offset_of!(_GOptionEntry, flags) - 12usize];
    ["Offset of field: _GOptionEntry::arg"][::std::mem::offset_of!(_GOptionEntry, arg) - 16usize];
    ["Offset of field: _GOptionEntry::arg_data"]
        [::std::mem::offset_of!(_GOptionEntry, arg_data) - 24usize];
    ["Offset of field: _GOptionEntry::description"]
        [::std::mem::offset_of!(_GOptionEntry, description) - 32usize];
    ["Offset of field: _GOptionEntry::arg_description"]
        [::std::mem::offset_of!(_GOptionEntry, arg_description) - 40usize];
};
unsafe extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
unsafe extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
unsafe extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
unsafe extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
unsafe extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
unsafe extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
unsafe extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
unsafe extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
unsafe extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
unsafe extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
pub type GPathBuf = _GPathBuf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPathBuf {
    pub dummy: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPathBuf"][::std::mem::size_of::<_GPathBuf>() - 64usize];
    ["Alignment of _GPathBuf"][::std::mem::align_of::<_GPathBuf>() - 8usize];
    ["Offset of field: _GPathBuf::dummy"][::std::mem::offset_of!(_GPathBuf, dummy) - 0usize];
};
unsafe extern "C" {
    pub fn g_path_buf_new() -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_new_from_path(path: *const ::std::os::raw::c_char) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_init(buf: *mut GPathBuf) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_init_from_path(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_clear(buf: *mut GPathBuf);
}
unsafe extern "C" {
    pub fn g_path_buf_clear_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_path_buf_free(buf: *mut GPathBuf);
}
unsafe extern "C" {
    pub fn g_path_buf_free_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_path_buf_copy(buf: *mut GPathBuf) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_push(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
unsafe extern "C" {
    pub fn g_path_buf_pop(buf: *mut GPathBuf) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_buf_set_filename(
        buf: *mut GPathBuf,
        file_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_buf_set_extension(
        buf: *mut GPathBuf,
        extension: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_path_buf_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
unsafe extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
unsafe extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
unsafe extern "C" {
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
}
unsafe extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GQueue"][::std::mem::size_of::<_GQueue>() - 24usize];
    ["Alignment of _GQueue"][::std::mem::align_of::<_GQueue>() - 8usize];
    ["Offset of field: _GQueue::head"][::std::mem::offset_of!(_GQueue, head) - 0usize];
    ["Offset of field: _GQueue::tail"][::std::mem::offset_of!(_GQueue, tail) - 8usize];
    ["Offset of field: _GQueue::length"][::std::mem::offset_of!(_GQueue, length) - 16usize];
};
unsafe extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
unsafe extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
unsafe extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
unsafe extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
unsafe extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
unsafe extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
unsafe extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
unsafe extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
unsafe extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
unsafe extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
unsafe extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
unsafe extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
unsafe extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
unsafe extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
unsafe extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
unsafe extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
unsafe extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
unsafe extern "C" {
    pub fn g_random_int() -> guint32;
}
unsafe extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_random_double() -> gdouble;
}
unsafe extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
unsafe extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
unsafe extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
unsafe extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
unsafe extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:\n\n A typedef for a reference-counted string. A pointer to a #GRefString can be\n treated like a standard `char*` array by all code, but can additionally have\n `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be\n called on `char*` arrays not allocated using g_ref_string_new().\n\n If using #GRefString with autocleanups, g_autoptr() must be used rather than\n g_autofree(), so that the reference counting metadata is also freed.\n\n Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:\n @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.\n @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.\n @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement\n     string.\n @G_REGEX_ERROR_MATCH: The match process failed.\n @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.\n     Since 2.16\n @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\".\n     Since 2.16\n @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\"\n     quantifier. Since 2.16\n @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier.\n     Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for\n     character class. Since 2.16\n @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence\n     in character class. Since 2.16\n @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.\n     Since 2.16\n @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\",\n     \"(?<\" or \"(?P\". Since 2.16\n @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are\n     supported only within a class. Since 2.16\n @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\"\n     without opening \"(\". Since 2.16\n @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent\n     subpattern. Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment.\n     Since 2.16\n @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.\n     Since 2.16\n @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16\n @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not\n     fixed length. Since 2.16\n @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains\n     more than two branches. Since 2.16\n @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.\n     Since 2.16\n @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating\n     elements are not supported. Since 2.16\n @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence\n     is too large. Since 2.16\n @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16\n @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in\n     lookbehind assertion. Since 2.16\n @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator\n     in subpattern name. Since 2.16\n @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have\n     the same name. Since 2.16\n @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence.\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or\n     \"\\\\p\". Since 2.16\n @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long\n     (maximum 32 characters). Since 2.16\n @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum\n     10,000). Since 2.16\n @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more\n     than one branch. Since 2.16\n @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed.\n     This error is never raised. Since: 2.16 Deprecated: 2.34\n @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,\n      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16\n @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing\n     control verb used does not allow an argument. Since: 2.34\n @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing\n     control verb. Since: 2.34\n @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34\n @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34\n @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,\n     \"[\" is an invalid data character. Since: 2.34\n @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the\n     same number are not allowed. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control\n     verb requires an argument. Since: 2.34\n @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII\n     character. Since: 2.34\n @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or\n     quoted name. Since: 2.34\n @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34\n @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34\n @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\",\n     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34\n @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is\n     too large. Since: 2.34\n\n Error codes returned by regular expressions functions.\n\n Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:\n @G_REGEX_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_CASELESS: Letters in the pattern match both upper- and\n     lowercase letters. This option can be changed within a pattern\n     by a \"(?i)\" option setting.\n @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting\n     of a single line of characters (even if it actually contains\n     newlines). The \"start of line\" metacharacter (\"^\") matches only\n     at the start of the string, while the \"end of line\" metacharacter\n     (\"$\") matches only at the end of the string, or before a terminating\n     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When\n     %G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\"\n     constructs match immediately following or immediately before any\n     newline in the string, respectively, as well as at the very start\n     and end. This can be changed within a pattern by a \"(?m)\" option\n     setting.\n @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all\n     characters, including newlines. Without it, newlines are excluded.\n     This option can be changed within a pattern by a (\"?s\") option setting.\n @G_REGEX_EXTENDED: Whitespace data characters in the pattern are\n     totally ignored except when escaped or inside a character class.\n     Whitespace does not include the VT character (code 11). In addition,\n     characters between an unescaped \"#\" outside a character class and\n     the next newline character, inclusive, are also ignored. This can\n     be changed within a pattern by a \"(?x)\" option setting.\n @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern\n     matches only at the end of the string. Without this option, a\n     dollar also matches immediately before the final character if\n     it is a newline (but not before any other newlines). This option\n     is ignored if %G_REGEX_MULTILINE is set.\n @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that\n     they are not greedy by default, but become greedy if followed by \"?\".\n     It can also be set by a \"(?U)\" option setting within the pattern.\n @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this\n     flag they are considered as a raw sequence of bytes.\n @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing\n     parentheses in the pattern. Any opening parenthesis that is not\n     followed by \"?\" behaves as if it were followed by \"?:\" but named\n     parentheses can still be used for capturing (and they acquire numbers\n     in the usual way).\n @G_REGEX_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT\n     compilation, which, if the just-in-time compiler is available, further\n     processes a compiled pattern into machine code that executes much\n     faster. However, it comes at the cost of extra processing before the\n     match is performed, so it is most beneficial to use this when the same\n     compiled pattern is used for matching many times. Before 2.74 this\n     option used the built-in non-JIT optimizations in pcre1.\n @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the\n     first newline. Since: 2.34\n @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not\n     be unique. This can be helpful for certain types of pattern when it\n     is known that only one instance of the named subpattern can ever be\n     matched.\n @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\r'.\n @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\n'.\n @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     sequence is '\\r\\n'.\n @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence\n     is recognized. If this option is set, the only recognized newline character\n     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34\n @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence\n     is recognised. If this option is set, then \"\\R\" only recognizes the newline\n    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34\n @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with\n     JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,\n     as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74\n\n Flags specifying compile-time options.\n\n Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:\n @G_REGEX_MATCH_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is\n     not the beginning of a line, so the circumflex metacharacter should\n     not match before it. Setting this without %G_REGEX_MULTILINE (at\n     compile time) causes circumflex never to match. This option affects\n     only the behaviour of the circumflex metacharacter, it does not\n     affect \"\\A\".\n @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is\n     not the end of a line, so the dollar metacharacter should not match\n     it nor (except in multiline mode) a newline immediately before it.\n     Setting this without %G_REGEX_MULTILINE (at compile time) causes\n     dollar never to match. This option affects only the behaviour of\n     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\".\n @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid\n     match if this option is set. If there are alternatives in the pattern,\n     they are tried. If all the alternatives match the empty string, the\n     entire match fails. For example, if the pattern \"a?b?\" is applied to\n     a string not beginning with \"a\" or \"b\", it matches the empty string\n     at the start of the string. With this flag set, this match is not\n     valid, so GRegex searches further into the string for occurrences\n     of \"a\" or \"b\".\n @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more\n     documentation on partial matching see g_match_info_is_partial_match().\n @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\n' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator.\n @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when\n     creating a new #GRegex, any Unicode newline sequence\n     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR.\n @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when\n     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence\n     is recognized as a newline. Since: 2.34\n @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences\n     are recognized as a newline by \"\\R\". Since: 2.34\n @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; any Unicode newline character or character sequence\n     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to\n     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match\n     is found, without continuing to search for a possible complete match. See\n     g_match_info_is_partial_match() for more information. Since: 2.34\n @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to\n     the start of the matched string. For anchored\n     patterns this can only happen for pattern containing \"\\K\". Since: 2.34\n\n Flags specifying match-time options.\n\n Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:\n\n A GMatchInfo is an opaque struct used to return information about\n matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:\n @match_info: the #GMatchInfo generated by the match.\n     Use g_match_info_get_regex() and g_match_info_get_string() if you\n     need the #GRegex or the matched string.\n @result: a #GString containing the new string\n @user_data: user data passed to g_regex_replace_eval()\n\n Specifies the type of the function passed to g_regex_replace_eval().\n It is called for each occurrence of the pattern in the string passed\n to g_regex_replace_eval(), and it should append the replacement to\n @result.\n\n Returns: %FALSE to continue the replacement process, %TRUE to stop it\n\n Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
unsafe extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
unsafe extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
unsafe extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
unsafe extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
unsafe extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
unsafe extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
unsafe extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
unsafe extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTokenValue"][::std::mem::size_of::<_GTokenValue>() - 8usize];
    ["Alignment of _GTokenValue"][::std::mem::align_of::<_GTokenValue>() - 8usize];
    ["Offset of field: _GTokenValue::v_symbol"]
        [::std::mem::offset_of!(_GTokenValue, v_symbol) - 0usize];
    ["Offset of field: _GTokenValue::v_identifier"]
        [::std::mem::offset_of!(_GTokenValue, v_identifier) - 0usize];
    ["Offset of field: _GTokenValue::v_binary"]
        [::std::mem::offset_of!(_GTokenValue, v_binary) - 0usize];
    ["Offset of field: _GTokenValue::v_octal"]
        [::std::mem::offset_of!(_GTokenValue, v_octal) - 0usize];
    ["Offset of field: _GTokenValue::v_int"][::std::mem::offset_of!(_GTokenValue, v_int) - 0usize];
    ["Offset of field: _GTokenValue::v_int64"]
        [::std::mem::offset_of!(_GTokenValue, v_int64) - 0usize];
    ["Offset of field: _GTokenValue::v_float"]
        [::std::mem::offset_of!(_GTokenValue, v_float) - 0usize];
    ["Offset of field: _GTokenValue::v_hex"][::std::mem::offset_of!(_GTokenValue, v_hex) - 0usize];
    ["Offset of field: _GTokenValue::v_string"]
        [::std::mem::offset_of!(_GTokenValue, v_string) - 0usize];
    ["Offset of field: _GTokenValue::v_comment"]
        [::std::mem::offset_of!(_GTokenValue, v_comment) - 0usize];
    ["Offset of field: _GTokenValue::v_char"]
        [::std::mem::offset_of!(_GTokenValue, v_char) - 0usize];
    ["Offset of field: _GTokenValue::v_error"]
        [::std::mem::offset_of!(_GTokenValue, v_error) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GScannerConfig"][::std::mem::size_of::<_GScannerConfig>() - 40usize];
    ["Alignment of _GScannerConfig"][::std::mem::align_of::<_GScannerConfig>() - 8usize];
    ["Offset of field: _GScannerConfig::cset_skip_characters"]
        [::std::mem::offset_of!(_GScannerConfig, cset_skip_characters) - 0usize];
    ["Offset of field: _GScannerConfig::cset_identifier_first"]
        [::std::mem::offset_of!(_GScannerConfig, cset_identifier_first) - 8usize];
    ["Offset of field: _GScannerConfig::cset_identifier_nth"]
        [::std::mem::offset_of!(_GScannerConfig, cset_identifier_nth) - 16usize];
    ["Offset of field: _GScannerConfig::cpair_comment_single"]
        [::std::mem::offset_of!(_GScannerConfig, cpair_comment_single) - 24usize];
    ["Offset of field: _GScannerConfig::padding_dummy"]
        [::std::mem::offset_of!(_GScannerConfig, padding_dummy) - 36usize];
};
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn case_sensitive_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_case_sensitive_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_comment_multi_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_comment_multi_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn skip_comment_single_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                2usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_skip_comment_single_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                2usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_comment_multi_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                3usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_comment_multi_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                3usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_1char_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                5usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_1char_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                5usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_identifier_NULL_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                6usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_identifier_NULL_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                6usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_symbols_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                7usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_symbols_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                7usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_binary_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                8usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_binary_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                8usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_octal_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                9usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_octal_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                9usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_float_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                10usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_float_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                10usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_hex_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                11usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_hex_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                11usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_hex_dollar_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                12usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_hex_dollar_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                12usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_string_sq_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                13usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_string_sq_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                13usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scan_string_dq_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                14usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scan_string_dq_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                14usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn numbers_2_int_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_numbers_2_int_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn int_2_float_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_int_2_float_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn identifier_2_string_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_identifier_2_string_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn char_2_token_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                18usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_char_2_token_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                18usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn symbol_2_token_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_symbol_2_token_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn scope_0_fallback_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                20usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_scope_0_fallback_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                20usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn store_int64_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                21usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_store_int64_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                21usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GScanner"][::std::mem::size_of::<_GScanner>() - 144usize];
    ["Alignment of _GScanner"][::std::mem::align_of::<_GScanner>() - 8usize];
    ["Offset of field: _GScanner::user_data"]
        [::std::mem::offset_of!(_GScanner, user_data) - 0usize];
    ["Offset of field: _GScanner::max_parse_errors"]
        [::std::mem::offset_of!(_GScanner, max_parse_errors) - 8usize];
    ["Offset of field: _GScanner::parse_errors"]
        [::std::mem::offset_of!(_GScanner, parse_errors) - 12usize];
    ["Offset of field: _GScanner::input_name"]
        [::std::mem::offset_of!(_GScanner, input_name) - 16usize];
    ["Offset of field: _GScanner::qdata"][::std::mem::offset_of!(_GScanner, qdata) - 24usize];
    ["Offset of field: _GScanner::config"][::std::mem::offset_of!(_GScanner, config) - 32usize];
    ["Offset of field: _GScanner::token"][::std::mem::offset_of!(_GScanner, token) - 40usize];
    ["Offset of field: _GScanner::value"][::std::mem::offset_of!(_GScanner, value) - 48usize];
    ["Offset of field: _GScanner::line"][::std::mem::offset_of!(_GScanner, line) - 56usize];
    ["Offset of field: _GScanner::position"][::std::mem::offset_of!(_GScanner, position) - 60usize];
    ["Offset of field: _GScanner::next_token"]
        [::std::mem::offset_of!(_GScanner, next_token) - 64usize];
    ["Offset of field: _GScanner::next_value"]
        [::std::mem::offset_of!(_GScanner, next_value) - 72usize];
    ["Offset of field: _GScanner::next_line"]
        [::std::mem::offset_of!(_GScanner, next_line) - 80usize];
    ["Offset of field: _GScanner::next_position"]
        [::std::mem::offset_of!(_GScanner, next_position) - 84usize];
    ["Offset of field: _GScanner::symbol_table"]
        [::std::mem::offset_of!(_GScanner, symbol_table) - 88usize];
    ["Offset of field: _GScanner::input_fd"][::std::mem::offset_of!(_GScanner, input_fd) - 96usize];
    ["Offset of field: _GScanner::text"][::std::mem::offset_of!(_GScanner, text) - 104usize];
    ["Offset of field: _GScanner::text_end"]
        [::std::mem::offset_of!(_GScanner, text_end) - 112usize];
    ["Offset of field: _GScanner::buffer"][::std::mem::offset_of!(_GScanner, buffer) - 120usize];
    ["Offset of field: _GScanner::scope_id"]
        [::std::mem::offset_of!(_GScanner, scope_id) - 128usize];
    ["Offset of field: _GScanner::msg_handler"]
        [::std::mem::offset_of!(_GScanner, msg_handler) - 136usize];
};
unsafe extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
unsafe extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
unsafe extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
unsafe extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
unsafe extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
unsafe extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
unsafe extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
unsafe extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
unsafe extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
unsafe extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
unsafe extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
unsafe extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
unsafe extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
unsafe extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
unsafe extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
unsafe extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
unsafe extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
unsafe extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
unsafe extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
unsafe extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
unsafe extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
unsafe extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
unsafe extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
unsafe extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:\n @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.\n @G_SPAWN_ERROR_READ: Read or select on pipes failed.\n @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.\n @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`\n @G_SPAWN_ERROR_PERM: execv() returned `EPERM`\n @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`\n @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)\n @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`\n @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`\n @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`\n @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`\n @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`\n @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`\n @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`\n @G_SPAWN_ERROR_IO: execv() returned `EIO`\n @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`\n @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`\n @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`\n @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`\n @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`\n @G_SPAWN_ERROR_FAILED: Some other fatal failure,\n   `error->message` should explain.\n\n Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_uint;
#[doc = " GSpawnChildSetupFunc:\n @data: user data passed to the function.\n\n Specifies the type of the setup function passed to g_spawn_async(),\n g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very\n limited ways, be used to affect the child's execution.\n\n On POSIX platforms, the function is called in the child after GLib\n has performed all the setup it plans to perform, but before calling\n exec(). Actions taken in this function will only affect the child,\n not the parent.\n\n On Windows, the function is called in the parent. Its usefulness on\n Windows is thus questionable. In many cases executing the child setup\n function in the parent can have ill effects, and you should be very\n careful when porting software to Windows that uses child setup\n functions.\n\n However, even on POSIX, you are extremely limited in what you can\n safely do from a #GSpawnChildSetupFunc, because any mutexes that were\n held by other threads in the parent process at the time of the fork()\n will still be locked in the child process, and they will never be\n unlocked (since the threads that held them don't exist in the child).\n POSIX allows only async-signal-safe functions (see signal(7)) to be\n called in the child between fork() and exec(), which drastically limits\n the usefulness of child setup functions.\n\n In particular, it is not safe to call any function which may\n call malloc(), which includes POSIX functions such as setenv().\n If you need to set up the child environment differently from\n the parent, you should use g_get_environ(), g_environ_setenv(),\n and g_environ_unsetenv(), and then pass the complete environment\n list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " G_SPAWN_CHILD_INHERITS_STDOUT:\n\n The child will inherit the parent's standard output.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
#[doc = " G_SPAWN_CHILD_INHERITS_STDERR:\n\n The child will inherit the parent's standard error.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
#[doc = " G_SPAWN_STDIN_FROM_DEV_NULL:\n\n The child's standard input is attached to `/dev/null`.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;
#[doc = " GSpawnFlags:\n @G_SPAWN_DEFAULT: no flags, default behaviour\n @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will\n     be inherited by the child; otherwise all descriptors except stdin,\n     stdout and stderr will be closed before calling exec() in the child.\n @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;\n     you must use g_child_watch_add() yourself (or call waitpid() or handle\n     `SIGCHLD` yourself), or the child will become a zombie.\n @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be\n     looked for in the user's `PATH`.\n @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,\n     instead of going to the same location as the parent's standard output.\n @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.\n @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard\n     input (by default, the child's standard input is attached to `/dev/null`).\n @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to\n     execute, while the remaining elements are the actual argument vector\n     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`\n     as the file to execute, and passes all of `argv` to the child.\n @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,\n     it will be looked for in the `PATH` from the passed child environment.\n     Since: 2.34\n @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.\n     Since: 2.40\n @G_SPAWN_CHILD_INHERITS_STDOUT: the child will inherit the parent's standard output.\n     Since: 2.74\n @G_SPAWN_CHILD_INHERITS_STDERR: the child will inherit the parent's standard error.\n     Since: 2.74\n @G_SPAWN_STDIN_FROM_DEV_NULL: the child's standard input is attached to `/dev/null`.\n     Since: 2.74\n\n Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
unsafe extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
unsafe extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
unsafe extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
unsafe extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
pub type GStrvBuilder = _GStrvBuilder;
unsafe extern "C" {
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
}
unsafe extern "C" {
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
}
unsafe extern "C" {
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
}
unsafe extern "C" {
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_strv_builder_addv(
        builder: *mut GStrvBuilder,
        value: *mut *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
}
unsafe extern "C" {
    pub fn g_strv_builder_take(builder: *mut GStrvBuilder, value: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
}
unsafe extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
unsafe extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
unsafe extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
unsafe extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_test_get_path() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_test_fail();
}
unsafe extern "C" {
    pub fn g_test_fail_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_incomplete_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_skip_printf(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_failed() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
unsafe extern "C" {
    pub fn g_test_disable_crash_reporting();
}
unsafe extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_test_timer_start();
}
unsafe extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
unsafe extern "C" {
    pub fn g_test_timer_last() -> f64;
}
unsafe extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
unsafe extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:\n @G_TEST_TRAP_DEFAULT: Default behaviour. Since: 2.74\n @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stdout().\n @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stderr().\n @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the\n     child process is shared with stdin of its parent process.\n     It is redirected to `/dev/null` otherwise.\n\n Test traps are guards around forked tests.\n These flags determine what traps to set.\n\n Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),\n which is deprecated. g_test_trap_subprocess() uses\n #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
unsafe extern "C" {
    pub fn g_test_trap_subprocess_with_envp(
        test_path: *const ::std::os::raw::c_char,
        envp: *const *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
unsafe extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
unsafe extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
unsafe extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
unsafe extern "C" {
    pub fn g_test_rand_double() -> f64;
}
unsafe extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
unsafe extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
unsafe extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
unsafe extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
unsafe extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
unsafe extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
unsafe extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_test_case_free(test_case: *mut GTestCase);
}
unsafe extern "C" {
    pub fn g_test_suite_free(suite: *mut GTestSuite);
}
unsafe extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpstrv(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        first_wrong_idx: gsize,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpint(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: guint64,
        cmp: *const ::std::os::raw::c_char,
        arg2: guint64,
        numtype: ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: u128,
        cmp: *const ::std::os::raw::c_char,
        arg2: u128,
        numtype: ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestConfig"][::std::mem::size_of::<GTestConfig>() - 24usize];
    ["Alignment of GTestConfig"][::std::mem::align_of::<GTestConfig>() - 4usize];
    ["Offset of field: GTestConfig::test_initialized"]
        [::std::mem::offset_of!(GTestConfig, test_initialized) - 0usize];
    ["Offset of field: GTestConfig::test_quick"]
        [::std::mem::offset_of!(GTestConfig, test_quick) - 4usize];
    ["Offset of field: GTestConfig::test_perf"]
        [::std::mem::offset_of!(GTestConfig, test_perf) - 8usize];
    ["Offset of field: GTestConfig::test_verbose"]
        [::std::mem::offset_of!(GTestConfig, test_verbose) - 12usize];
    ["Offset of field: GTestConfig::test_quiet"]
        [::std::mem::offset_of!(GTestConfig, test_quiet) - 16usize];
    ["Offset of field: GTestConfig::test_undefined"]
        [::std::mem::offset_of!(GTestConfig, test_undefined) - 20usize];
};
unsafe extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_uint;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestLogMsg"][::std::mem::size_of::<GTestLogMsg>() - 32usize];
    ["Alignment of GTestLogMsg"][::std::mem::align_of::<GTestLogMsg>() - 8usize];
    ["Offset of field: GTestLogMsg::log_type"]
        [::std::mem::offset_of!(GTestLogMsg, log_type) - 0usize];
    ["Offset of field: GTestLogMsg::n_strings"]
        [::std::mem::offset_of!(GTestLogMsg, n_strings) - 4usize];
    ["Offset of field: GTestLogMsg::strings"]
        [::std::mem::offset_of!(GTestLogMsg, strings) - 8usize];
    ["Offset of field: GTestLogMsg::n_nums"][::std::mem::offset_of!(GTestLogMsg, n_nums) - 16usize];
    ["Offset of field: GTestLogMsg::nums"][::std::mem::offset_of!(GTestLogMsg, nums) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GTestLogBuffer"][::std::mem::size_of::<GTestLogBuffer>() - 16usize];
    ["Alignment of GTestLogBuffer"][::std::mem::align_of::<GTestLogBuffer>() - 8usize];
    ["Offset of field: GTestLogBuffer::data"]
        [::std::mem::offset_of!(GTestLogBuffer, data) - 0usize];
    ["Offset of field: GTestLogBuffer::msgs"]
        [::std::mem::offset_of!(GTestLogBuffer, msgs) - 8usize];
};
unsafe extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
unsafe extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
unsafe extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
unsafe extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
unsafe extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:\n @log_domain: the log domain of the message\n @log_level: the log level of the message (including the fatal and recursion flags)\n @message: the message to process\n @user_data: user data, set in g_test_log_set_fatal_handler()\n\n Specifies the prototype of fatal log handler functions.\n\n Returns: %TRUE if the program should abort, %FALSE otherwise\n\n Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
unsafe extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadPool"][::std::mem::size_of::<_GThreadPool>() - 24usize];
    ["Alignment of _GThreadPool"][::std::mem::align_of::<_GThreadPool>() - 8usize];
    ["Offset of field: _GThreadPool::func"][::std::mem::offset_of!(_GThreadPool, func) - 0usize];
    ["Offset of field: _GThreadPool::user_data"]
        [::std::mem::offset_of!(_GThreadPool, user_data) - 8usize];
    ["Offset of field: _GThreadPool::exclusive"]
        [::std::mem::offset_of!(_GThreadPool, exclusive) - 16usize];
};
unsafe extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
unsafe extern "C" {
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
unsafe extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
unsafe extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
unsafe extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
unsafe extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
unsafe extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
unsafe extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
unsafe extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
unsafe extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
unsafe extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
unsafe extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
unsafe extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
unsafe extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
unsafe extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTrashStack"][::std::mem::size_of::<_GTrashStack>() - 8usize];
    ["Alignment of _GTrashStack"][::std::mem::align_of::<_GTrashStack>() - 8usize];
    ["Offset of field: _GTrashStack::next"][::std::mem::offset_of!(_GTrashStack, next) - 0usize];
};
unsafe extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
unsafe extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
unsafe extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
unsafe extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
#[doc = " GTreeNode:\n\n An opaque type which identifies a specific node in a #GTree.\n\n Since: 2.68"]
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
#[doc = " GTraverseNodeFunc:\n @node: a #GTreeNode\n @data: user data passed to g_tree_foreach_node()\n\n Specifies the type of function passed to g_tree_foreach_node(). It is\n passed each node, together with the @user_data parameter passed to\n g_tree_foreach_node(). If the function returns %TRUE, the traversal is\n stopped.\n\n Returns: %TRUE to stop the traversal\n Since: 2.68"]
pub type GTraverseNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GTreeNode, data: gpointer) -> gboolean>;
unsafe extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
unsafe extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_remove_all(tree: *mut GTree);
}
unsafe extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
unsafe extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
unsafe extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
unsafe extern "C" {
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_unref(uri: *mut GUri);
}
pub const GUriFlags_G_URI_FLAGS_NONE: GUriFlags = 0;
pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const GUriFlags_G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const GUriFlags_G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
#[doc = " GUriFlags:\n @G_URI_FLAGS_NONE: No flags set.\n @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the\n     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,\n     fixing up or ignoring common mistakes in URIs coming from external\n     sources. This is also needed for some obscure URI schemes where `;`\n     separates the host from the path. Don’t use this flag unless you need to.\n @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,\n     which will be separated from the username by `:`.\n @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional\n     authentication-related parameters, which will be separated from\n     the username and/or password by `;`.\n @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a\n     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS\n     hostnames).\n @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded\n     characters in the userinfo, path, query, and fragment fields\n     should not be decoded. (And likewise the host field if\n     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates\n     that you have already `%`-encoded the components, and so #GUri\n     should not do any encoding itself.\n @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query\n     field only.\n @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.\n @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the\n     fragment only.\n @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.\n     For example, when parsing an HTTP URI changing omitted path to `/` and\n     omitted port to `80`; and when building a URI, changing empty path to `/`\n     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)\n\n Flags that describe a URI.\n\n When parsing a URI, if you need to choose different flags based on\n the type of URI, you can use g_uri_peek_scheme() on the URI string\n to check the scheme first, and use that to decide what flags to\n parse it with.\n\n Since: 2.66"]
pub type GUriFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
unsafe extern "C" {
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
pub const GUriHideFlags_G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const GUriHideFlags_G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const GUriHideFlags_G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const GUriHideFlags_G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const GUriHideFlags_G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
#[doc = " GUriHideFlags:\n @G_URI_HIDE_NONE: No flags set.\n @G_URI_HIDE_USERINFO: Hide the userinfo.\n @G_URI_HIDE_PASSWORD: Hide the password.\n @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.\n @G_URI_HIDE_QUERY: Hide the query.\n @G_URI_HIDE_FRAGMENT: Hide the fragment.\n\n Flags describing what parts of the URI to hide in\n g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and\n %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with\n the corresponding flags.\n\n Since: 2.66"]
pub type GUriHideFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_to_string_partial(
        uri: *mut GUri,
        flags: GUriHideFlags,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
}
unsafe extern "C" {
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
}
pub const GUriParamsFlags_G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
#[doc = " GUriParamsFlags:\n @G_URI_PARAMS_NONE: No flags set.\n @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.\n @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for\n     URLs on the web, using the `https` or `http` schemas.\n @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.\n\n Flags modifying the way parameters are handled by g_uri_parse_params() and\n #GUriParamsIter.\n\n Since: 2.66"]
pub type GUriParamsFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUriParamsIter"][::std::mem::size_of::<_GUriParamsIter>() - 280usize];
    ["Alignment of _GUriParamsIter"][::std::mem::align_of::<_GUriParamsIter>() - 8usize];
    ["Offset of field: _GUriParamsIter::dummy0"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy0) - 0usize];
    ["Offset of field: _GUriParamsIter::dummy1"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy1) - 8usize];
    ["Offset of field: _GUriParamsIter::dummy2"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy2) - 16usize];
    ["Offset of field: _GUriParamsIter::dummy3"]
        [::std::mem::offset_of!(_GUriParamsIter, dummy3) - 24usize];
};
unsafe extern "C" {
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
}
unsafe extern "C" {
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uri_error_quark() -> GQuark;
}
pub const GUriError_G_URI_ERROR_FAILED: GUriError = 0;
pub const GUriError_G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const GUriError_G_URI_ERROR_BAD_USER: GUriError = 2;
pub const GUriError_G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const GUriError_G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const GUriError_G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const GUriError_G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const GUriError_G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const GUriError_G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
#[doc = " GUriError:\n @G_URI_ERROR_FAILED: Generic error if no more specific error is available.\n     See the error message for details.\n @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.\n @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.\n @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.\n @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.\n @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.\n @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.\n @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.\n @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.\n @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.\n\n Error codes returned by #GUri methods.\n\n Since: 2.66"]
pub type GUriError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_peek_scheme(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uri_unescape_bytes(
        escaped_string: *const ::std::os::raw::c_char,
        length: gssize,
        illegal_characters: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
unsafe extern "C" {
    pub static glib_major_version: guint;
}
unsafe extern "C" {
    pub static glib_minor_version: guint;
}
unsafe extern "C" {
    pub static glib_micro_version: guint;
}
unsafe extern "C" {
    pub static glib_interface_age: guint;
}
unsafe extern "C" {
    pub static glib_binary_age: guint;
}
unsafe extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
unsafe extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
unsafe extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
unsafe extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
unsafe extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
unsafe extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
unsafe extern "C" {
    pub fn g_mem_chunk_info();
}
unsafe extern "C" {
    pub fn g_blow_chunks();
}
unsafe extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
unsafe extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_list_pop_allocator();
}
unsafe extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_slist_pop_allocator();
}
unsafe extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
unsafe extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
unsafe extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
unsafe extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
unsafe extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
unsafe extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
unsafe extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(item: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCompletion"][::std::mem::size_of::<_GCompletion>() - 40usize];
    ["Alignment of _GCompletion"][::std::mem::align_of::<_GCompletion>() - 8usize];
    ["Offset of field: _GCompletion::items"][::std::mem::offset_of!(_GCompletion, items) - 0usize];
    ["Offset of field: _GCompletion::func"][::std::mem::offset_of!(_GCompletion, func) - 8usize];
    ["Offset of field: _GCompletion::prefix"]
        [::std::mem::offset_of!(_GCompletion, prefix) - 16usize];
    ["Offset of field: _GCompletion::cache"][::std::mem::offset_of!(_GCompletion, cache) - 24usize];
    ["Offset of field: _GCompletion::strncmp_func"]
        [::std::mem::offset_of!(_GCompletion, strncmp_func) - 32usize];
};
unsafe extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
unsafe extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
unsafe extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
unsafe extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
unsafe extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
unsafe extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTuples"][::std::mem::size_of::<_GTuples>() - 4usize];
    ["Alignment of _GTuples"][::std::mem::align_of::<_GTuples>() - 4usize];
    ["Offset of field: _GTuples::len"][::std::mem::offset_of!(_GTuples, len) - 0usize];
};
unsafe extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
unsafe extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
unsafe extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
unsafe extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
unsafe extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
unsafe extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
unsafe extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
unsafe extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
unsafe extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
unsafe extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThread"][::std::mem::size_of::<_GThread>() - 24usize];
    ["Alignment of _GThread"][::std::mem::align_of::<_GThread>() - 8usize];
    ["Offset of field: _GThread::func"][::std::mem::offset_of!(_GThread, func) - 0usize];
    ["Offset of field: _GThread::data"][::std::mem::offset_of!(_GThread, data) - 8usize];
    ["Offset of field: _GThread::joinable"][::std::mem::offset_of!(_GThread, joinable) - 16usize];
    ["Offset of field: _GThread::priority"][::std::mem::offset_of!(_GThread, priority) - 20usize];
};
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadFunctions"][::std::mem::size_of::<_GThreadFunctions>() - 168usize];
    ["Alignment of _GThreadFunctions"][::std::mem::align_of::<_GThreadFunctions>() - 8usize];
    ["Offset of field: _GThreadFunctions::mutex_new"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_new) - 0usize];
    ["Offset of field: _GThreadFunctions::mutex_lock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_lock) - 8usize];
    ["Offset of field: _GThreadFunctions::mutex_trylock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_trylock) - 16usize];
    ["Offset of field: _GThreadFunctions::mutex_unlock"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_unlock) - 24usize];
    ["Offset of field: _GThreadFunctions::mutex_free"]
        [::std::mem::offset_of!(_GThreadFunctions, mutex_free) - 32usize];
    ["Offset of field: _GThreadFunctions::cond_new"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_new) - 40usize];
    ["Offset of field: _GThreadFunctions::cond_signal"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_signal) - 48usize];
    ["Offset of field: _GThreadFunctions::cond_broadcast"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_broadcast) - 56usize];
    ["Offset of field: _GThreadFunctions::cond_wait"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_wait) - 64usize];
    ["Offset of field: _GThreadFunctions::cond_timed_wait"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_timed_wait) - 72usize];
    ["Offset of field: _GThreadFunctions::cond_free"]
        [::std::mem::offset_of!(_GThreadFunctions, cond_free) - 80usize];
    ["Offset of field: _GThreadFunctions::private_new"]
        [::std::mem::offset_of!(_GThreadFunctions, private_new) - 88usize];
    ["Offset of field: _GThreadFunctions::private_get"]
        [::std::mem::offset_of!(_GThreadFunctions, private_get) - 96usize];
    ["Offset of field: _GThreadFunctions::private_set"]
        [::std::mem::offset_of!(_GThreadFunctions, private_set) - 104usize];
    ["Offset of field: _GThreadFunctions::thread_create"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_create) - 112usize];
    ["Offset of field: _GThreadFunctions::thread_yield"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_yield) - 120usize];
    ["Offset of field: _GThreadFunctions::thread_join"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_join) - 128usize];
    ["Offset of field: _GThreadFunctions::thread_exit"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_exit) - 136usize];
    ["Offset of field: _GThreadFunctions::thread_set_priority"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_set_priority) - 144usize];
    ["Offset of field: _GThreadFunctions::thread_self"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_self) - 152usize];
    ["Offset of field: _GThreadFunctions::thread_equal"]
        [::std::mem::offset_of!(_GThreadFunctions, thread_equal) - 160usize];
};
unsafe extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
unsafe extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
unsafe extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
unsafe extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
unsafe extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of sched_param"][::std::mem::size_of::<sched_param>() - 4usize];
    ["Alignment of sched_param"][::std::mem::align_of::<sched_param>() - 4usize];
    ["Offset of field: sched_param::sched_priority"]
        [::std::mem::offset_of!(sched_param, sched_priority) - 0usize];
};
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cpu_set_t"][::std::mem::size_of::<cpu_set_t>() - 128usize];
    ["Alignment of cpu_set_t"][::std::mem::align_of::<cpu_set_t>() - 8usize];
    ["Offset of field: cpu_set_t::__bits"][::std::mem::offset_of!(cpu_set_t, __bits) - 0usize];
};
unsafe extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
unsafe extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
unsafe extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __jmp_buf_tag"][::std::mem::size_of::<__jmp_buf_tag>() - 200usize];
    ["Alignment of __jmp_buf_tag"][::std::mem::align_of::<__jmp_buf_tag>() - 8usize];
    ["Offset of field: __jmp_buf_tag::__jmpbuf"]
        [::std::mem::offset_of!(__jmp_buf_tag, __jmpbuf) - 0usize];
    ["Offset of field: __jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__jmp_buf_tag, __mask_was_saved) - 64usize];
    ["Offset of field: __jmp_buf_tag::__saved_mask"]
        [::std::mem::offset_of!(__jmp_buf_tag, __saved_mask) - 72usize];
};
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _pthread_cleanup_buffer"][::std::mem::size_of::<_pthread_cleanup_buffer>() - 32usize];
    ["Alignment of _pthread_cleanup_buffer"]
        [::std::mem::align_of::<_pthread_cleanup_buffer>() - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__routine"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __routine) - 0usize];
    ["Offset of field: _pthread_cleanup_buffer::__arg"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __arg) - 8usize];
    ["Offset of field: _pthread_cleanup_buffer::__canceltype"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __canceltype) - 16usize];
    ["Offset of field: _pthread_cleanup_buffer::__prev"]
        [::std::mem::offset_of!(_pthread_cleanup_buffer, __prev) - 24usize];
};
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
unsafe extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_self() -> pthread_t;
}
unsafe extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __cancel_jmp_buf_tag"][::std::mem::size_of::<__cancel_jmp_buf_tag>() - 72usize];
    ["Alignment of __cancel_jmp_buf_tag"][::std::mem::align_of::<__cancel_jmp_buf_tag>() - 8usize];
    ["Offset of field: __cancel_jmp_buf_tag::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __cancel_jmp_buf_tag::__mask_was_saved"]
        [::std::mem::offset_of!(__cancel_jmp_buf_tag, __mask_was_saved) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_unwind_buf_t"][::std::mem::size_of::<__pthread_unwind_buf_t>() - 104usize];
    ["Alignment of __pthread_unwind_buf_t"]
        [::std::mem::align_of::<__pthread_unwind_buf_t>() - 8usize];
    ["Offset of field: __pthread_unwind_buf_t::__cancel_jmp_buf"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __cancel_jmp_buf) - 0usize];
    ["Offset of field: __pthread_unwind_buf_t::__pad"]
        [::std::mem::offset_of!(__pthread_unwind_buf_t, __pad) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __pthread_cleanup_frame"][::std::mem::size_of::<__pthread_cleanup_frame>() - 24usize];
    ["Alignment of __pthread_cleanup_frame"]
        [::std::mem::align_of::<__pthread_cleanup_frame>() - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_routine"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_routine) - 0usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_arg"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_arg) - 8usize];
    ["Offset of field: __pthread_cleanup_frame::__do_it"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __do_it) - 16usize];
    ["Offset of field: __pthread_cleanup_frame::__cancel_type"]
        [::std::mem::offset_of!(__pthread_cleanup_frame, __cancel_type) - 20usize];
};
unsafe extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
unsafe extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
unsafe extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GStaticMutex"][::std::mem::size_of::<GStaticMutex>() - 48usize];
    ["Alignment of GStaticMutex"][::std::mem::align_of::<GStaticMutex>() - 8usize];
    ["Offset of field: GStaticMutex::mutex"][::std::mem::offset_of!(GStaticMutex, mutex) - 0usize];
    ["Offset of field: GStaticMutex::unused"]
        [::std::mem::offset_of!(GStaticMutex, unused) - 8usize];
};
unsafe extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
unsafe extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
unsafe extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRecMutex__bindgen_ty_1"]
        [::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>() - 8usize];
    ["Alignment of _GStaticRecMutex__bindgen_ty_1"]
        [::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GStaticRecMutex__bindgen_ty_1::owner"]
        [::std::mem::offset_of!(_GStaticRecMutex__bindgen_ty_1, owner) - 0usize];
    ["Offset of field: _GStaticRecMutex__bindgen_ty_1::dummy"]
        [::std::mem::offset_of!(_GStaticRecMutex__bindgen_ty_1, dummy) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRecMutex"][::std::mem::size_of::<_GStaticRecMutex>() - 64usize];
    ["Alignment of _GStaticRecMutex"][::std::mem::align_of::<_GStaticRecMutex>() - 8usize];
    ["Offset of field: _GStaticRecMutex::mutex"]
        [::std::mem::offset_of!(_GStaticRecMutex, mutex) - 0usize];
    ["Offset of field: _GStaticRecMutex::depth"]
        [::std::mem::offset_of!(_GStaticRecMutex, depth) - 48usize];
    ["Offset of field: _GStaticRecMutex::unused"]
        [::std::mem::offset_of!(_GStaticRecMutex, unused) - 56usize];
};
unsafe extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
unsafe extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticRWLock"][::std::mem::size_of::<_GStaticRWLock>() - 80usize];
    ["Alignment of _GStaticRWLock"][::std::mem::align_of::<_GStaticRWLock>() - 8usize];
    ["Offset of field: _GStaticRWLock::mutex"]
        [::std::mem::offset_of!(_GStaticRWLock, mutex) - 0usize];
    ["Offset of field: _GStaticRWLock::read_cond"]
        [::std::mem::offset_of!(_GStaticRWLock, read_cond) - 48usize];
    ["Offset of field: _GStaticRWLock::write_cond"]
        [::std::mem::offset_of!(_GStaticRWLock, write_cond) - 56usize];
    ["Offset of field: _GStaticRWLock::read_counter"]
        [::std::mem::offset_of!(_GStaticRWLock, read_counter) - 64usize];
    ["Offset of field: _GStaticRWLock::have_writer"]
        [::std::mem::offset_of!(_GStaticRWLock, have_writer) - 68usize];
    ["Offset of field: _GStaticRWLock::want_to_read"]
        [::std::mem::offset_of!(_GStaticRWLock, want_to_read) - 72usize];
    ["Offset of field: _GStaticRWLock::want_to_write"]
        [::std::mem::offset_of!(_GStaticRWLock, want_to_write) - 76usize];
};
unsafe extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
unsafe extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticPrivate"][::std::mem::size_of::<_GStaticPrivate>() - 4usize];
    ["Alignment of _GStaticPrivate"][::std::mem::align_of::<_GStaticPrivate>() - 4usize];
    ["Offset of field: _GStaticPrivate::index"]
        [::std::mem::offset_of!(_GStaticPrivate, index) - 0usize];
};
unsafe extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
unsafe extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
unsafe extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
unsafe extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
unsafe extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
unsafe extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
unsafe extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
unsafe extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
unsafe extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
unsafe extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
unsafe extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
unsafe extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        abs_time: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GStrvBuilder_autoptr = *mut GStrvBuilder;
pub type GStrvBuilder_listautoptr = *mut GList;
pub type GStrvBuilder_slistautoptr = *mut GSList;
pub type GStrvBuilder_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub type GUri_autoptr = *mut GUri;
pub type GUri_listautoptr = *mut GList;
pub type GUri_slistautoptr = *mut GSList;
pub type GUri_queueautoptr = *mut GQueue;
pub type GPathBuf_autoptr = *mut GPathBuf;
pub type GPathBuf_listautoptr = *mut GList;
pub type GPathBuf_slistautoptr = *mut GSList;
pub type GPathBuf_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t__bindgen_ty_1"]
        [::std::mem::size_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Alignment of __mbstate_t__bindgen_ty_1"]
        [::std::mem::align_of::<__mbstate_t__bindgen_ty_1>() - 4usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wch"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wch) - 0usize];
    ["Offset of field: __mbstate_t__bindgen_ty_1::__wchb"]
        [::std::mem::offset_of!(__mbstate_t__bindgen_ty_1, __wchb) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 8usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 4usize];
    ["Offset of field: __mbstate_t::__count"]
        [::std::mem::offset_of!(__mbstate_t, __count) - 0usize];
    ["Offset of field: __mbstate_t::__value"]
        [::std::mem::offset_of!(__mbstate_t, __value) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos_t"][::std::mem::size_of::<_G_fpos_t>() - 16usize];
    ["Alignment of _G_fpos_t"][::std::mem::align_of::<_G_fpos_t>() - 8usize];
    ["Offset of field: _G_fpos_t::__pos"][::std::mem::offset_of!(_G_fpos_t, __pos) - 0usize];
    ["Offset of field: _G_fpos_t::__state"][::std::mem::offset_of!(_G_fpos_t, __state) - 8usize];
};
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _G_fpos64_t"][::std::mem::size_of::<_G_fpos64_t>() - 16usize];
    ["Alignment of _G_fpos64_t"][::std::mem::align_of::<_G_fpos64_t>() - 8usize];
    ["Offset of field: _G_fpos64_t::__pos"][::std::mem::offset_of!(_G_fpos64_t, __pos) - 0usize];
    ["Offset of field: _G_fpos64_t::__state"]
        [::std::mem::offset_of!(_G_fpos64_t, __state) - 8usize];
};
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_flags2"][::std::mem::offset_of!(_IO_FILE, _flags2) - 116usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::__pad5"][::std::mem::offset_of!(_IO_FILE, __pad5) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 196usize];
};
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_cookie_io_functions_t"]
        [::std::mem::size_of::<_IO_cookie_io_functions_t>() - 32usize];
    ["Alignment of _IO_cookie_io_functions_t"]
        [::std::mem::align_of::<_IO_cookie_io_functions_t>() - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::read"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, read) - 0usize];
    ["Offset of field: _IO_cookie_io_functions_t::write"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, write) - 8usize];
    ["Offset of field: _IO_cookie_io_functions_t::seek"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, seek) - 16usize];
    ["Offset of field: _IO_cookie_io_functions_t::close"]
        [::std::mem::offset_of!(_IO_cookie_io_functions_t, close) - 24usize];
};
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type fpos_t = __fpos_t;
unsafe extern "C" {
    pub static mut stdin: *mut FILE;
}
unsafe extern "C" {
    pub static mut stdout: *mut FILE;
}
unsafe extern "C" {
    pub static mut stderr: *mut FILE;
}
unsafe extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
unsafe extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
unsafe extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
unsafe extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
unsafe extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
unsafe extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
unsafe extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
unsafe extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
unsafe extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_printf(format: *const gchar, ...) -> gint;
}
unsafe extern "C" {
    pub fn g_fprintf(file: *mut FILE, format: *const gchar, ...) -> gint;
}
unsafe extern "C" {
    pub fn g_sprintf(string: *mut gchar, format: *const gchar, ...) -> gint;
}
unsafe extern "C" {
    pub fn g_vprintf(format: *const gchar, args: *mut __va_list_tag) -> gint;
}
unsafe extern "C" {
    pub fn g_vfprintf(file: *mut FILE, format: *const gchar, args: *mut __va_list_tag) -> gint;
}
unsafe extern "C" {
    pub fn g_vsprintf(string: *mut gchar, format: *const gchar, args: *mut __va_list_tag) -> gint;
}
unsafe extern "C" {
    pub fn g_vasprintf(
        string: *mut *mut gchar,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of stat"][::std::mem::size_of::<stat>() - 144usize];
    ["Alignment of stat"][::std::mem::align_of::<stat>() - 8usize];
    ["Offset of field: stat::st_dev"][::std::mem::offset_of!(stat, st_dev) - 0usize];
    ["Offset of field: stat::st_ino"][::std::mem::offset_of!(stat, st_ino) - 8usize];
    ["Offset of field: stat::st_nlink"][::std::mem::offset_of!(stat, st_nlink) - 16usize];
    ["Offset of field: stat::st_mode"][::std::mem::offset_of!(stat, st_mode) - 24usize];
    ["Offset of field: stat::st_uid"][::std::mem::offset_of!(stat, st_uid) - 28usize];
    ["Offset of field: stat::st_gid"][::std::mem::offset_of!(stat, st_gid) - 32usize];
    ["Offset of field: stat::__pad0"][::std::mem::offset_of!(stat, __pad0) - 36usize];
    ["Offset of field: stat::st_rdev"][::std::mem::offset_of!(stat, st_rdev) - 40usize];
    ["Offset of field: stat::st_size"][::std::mem::offset_of!(stat, st_size) - 48usize];
    ["Offset of field: stat::st_blksize"][::std::mem::offset_of!(stat, st_blksize) - 56usize];
    ["Offset of field: stat::st_blocks"][::std::mem::offset_of!(stat, st_blocks) - 64usize];
    ["Offset of field: stat::st_atim"][::std::mem::offset_of!(stat, st_atim) - 72usize];
    ["Offset of field: stat::st_mtim"][::std::mem::offset_of!(stat, st_mtim) - 88usize];
    ["Offset of field: stat::st_ctim"][::std::mem::offset_of!(stat, st_ctim) - 104usize];
    ["Offset of field: stat::__glibc_reserved"]
        [::std::mem::offset_of!(stat, __glibc_reserved) - 120usize];
};
unsafe extern "C" {
    pub fn stat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstat(__fd: ::std::os::raw::c_int, __buf: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fstatat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __buf: *mut stat,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lstat(__file: *const ::std::os::raw::c_char, __buf: *mut stat) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchmod(__file: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmod(__fd: ::std::os::raw::c_int, __mode: __mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchmodat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn umask(__mask: __mode_t) -> __mode_t;
}
unsafe extern "C" {
    pub fn mkdir(__path: *const ::std::os::raw::c_char, __mode: __mode_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkdirat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mknod(
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mknodat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
        __dev: __dev_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifo(__path: *const ::std::os::raw::c_char, __mode: __mode_t)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn mkfifoat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __mode: __mode_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn utimensat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __times: *const timespec,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn futimens(__fd: ::std::os::raw::c_int, __times: *const timespec)
        -> ::std::os::raw::c_int;
}
pub type GStatBuf = stat;
unsafe extern "C" {
    pub fn g_access(filename: *const gchar, mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_chdir(path: *const gchar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_unlink(filename: *const gchar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_rmdir(filename: *const gchar) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_close(fd: gint, error: *mut *mut GError) -> gboolean;
}
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
#[doc = " GModuleFlags:\n @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when\n     needed. The default action is to bind all symbols when the module\n     is loaded.\n @G_MODULE_BIND_LOCAL: specifies that symbols in the module should\n     not be added to the global name space. The default action on most\n     platforms is to place symbols in the module in the global name space,\n     which may cause conflicts with existing symbols.\n @G_MODULE_BIND_MASK: mask for all flags.\n\n Flags passed to g_module_open().\n Note that these flags are not supported on all platforms."]
pub type GModuleFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
unsafe extern "C" {
    pub fn g_module_error_quark() -> GQuark;
}
pub const GModuleError_G_MODULE_ERROR_FAILED: GModuleError = 0;
pub const GModuleError_G_MODULE_ERROR_CHECK_FAILED: GModuleError = 1;
#[doc = " GModuleError:\n @G_MODULE_ERROR_FAILED: there was an error loading or opening a module file\n @G_MODULE_ERROR_CHECK_FAILED: a module returned an error from its `g_module_check_init()` function\n\n Errors returned by g_module_open_full().\n\n Since: 2.70"]
pub type GModuleError = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_module_supported() -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
unsafe extern "C" {
    pub fn g_module_open_full(
        file_name: *const gchar,
        flags: GModuleFlags,
        error: *mut *mut GError,
    ) -> *mut GModule;
}
unsafe extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
unsafe extern "C" {
    pub fn g_module_error() -> *const gchar;
}
unsafe extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
pub type GType = gsize;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
pub type GValue = _GValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
pub type GTypeInterface = _GTypeInterface;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
pub type GTypeInfo = _GTypeInfo;
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
pub type GInterfaceInfo = _GInterfaceInfo;
#[doc = " GTypeValueTable:\n @value_init: Function to initialize a GValue\n @value_free: Function to free a GValue\n @value_copy: Function to copy a GValue\n @value_peek_pointer: Function to peek the contents of a GValue if they fit\n   into a pointer\n @collect_format: A string format describing how to collect the contents of\n   this value bit-by-bit. Each character in the format represents\n   an argument to be collected, and the characters themselves indicate\n   the type of the argument. Currently supported arguments are:\n    - `'i'`: Integers, passed as `collect_values[].v_int`\n    - `'l'`: Longs, passed as `collect_values[].v_long`\n    - `'d'`: Doubles, passed as `collect_values[].v_double`\n    - `'p'`: Pointers, passed as `collect_values[].v_pointer`\n   It should be noted that for variable argument list construction,\n   ANSI C promotes every type smaller than an integer to an int, and\n   floats to doubles. So for collection of short int or char, `'i'`\n   needs to be used, and for collection of floats `'d'`.\n @collect_value: Function to initialize a GValue from the values\n   collected from variadic arguments\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n   analogous to @collect_format. Usually, @lcopy_format string consists\n   only of `'p'`s to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: Function to store the contents of a value into the\n   locations collected from variadic arguments\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
pub type GTypeValueTable = _GTypeValueTable;
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
pub type GTypeQuery = _GTypeQuery;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeClass"][::std::mem::size_of::<_GTypeClass>() - 8usize];
    ["Alignment of _GTypeClass"][::std::mem::align_of::<_GTypeClass>() - 8usize];
    ["Offset of field: _GTypeClass::g_type"][::std::mem::offset_of!(_GTypeClass, g_type) - 0usize];
};
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInstance"][::std::mem::size_of::<_GTypeInstance>() - 8usize];
    ["Alignment of _GTypeInstance"][::std::mem::align_of::<_GTypeInstance>() - 8usize];
    ["Offset of field: _GTypeInstance::g_class"]
        [::std::mem::offset_of!(_GTypeInstance, g_class) - 0usize];
};
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInterface"][::std::mem::size_of::<_GTypeInterface>() - 16usize];
    ["Alignment of _GTypeInterface"][::std::mem::align_of::<_GTypeInterface>() - 8usize];
    ["Offset of field: _GTypeInterface::g_type"]
        [::std::mem::offset_of!(_GTypeInterface, g_type) - 0usize];
    ["Offset of field: _GTypeInterface::g_instance_type"]
        [::std::mem::offset_of!(_GTypeInterface, g_instance_type) - 8usize];
};
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeQuery"][::std::mem::size_of::<_GTypeQuery>() - 24usize];
    ["Alignment of _GTypeQuery"][::std::mem::align_of::<_GTypeQuery>() - 8usize];
    ["Offset of field: _GTypeQuery::type_"][::std::mem::offset_of!(_GTypeQuery, type_) - 0usize];
    ["Offset of field: _GTypeQuery::type_name"]
        [::std::mem::offset_of!(_GTypeQuery, type_name) - 8usize];
    ["Offset of field: _GTypeQuery::class_size"]
        [::std::mem::offset_of!(_GTypeQuery, class_size) - 16usize];
    ["Offset of field: _GTypeQuery::instance_size"]
        [::std::mem::offset_of!(_GTypeQuery, instance_size) - 20usize];
};
pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;
#[doc = " GTypeDebugFlags:\n @G_TYPE_DEBUG_NONE: Print no messages\n @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping\n @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions\n @G_TYPE_DEBUG_MASK: Mask covering all debug flags\n @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type\n\n These flags used to be passed to g_type_init_with_debug_flags() which\n is now deprecated.\n\n If you need to enable debugging features, use the `GOBJECT_DEBUG`\n environment variable.\n\n Deprecated: 2.36: g_type_init() is now done automatically"]
pub type GTypeDebugFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_type_init();
}
unsafe extern "C" {
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
unsafe extern "C" {
    pub fn g_type_name(type_: GType) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_type_qname(type_: GType) -> GQuark;
}
unsafe extern "C" {
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn g_type_parent(type_: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_depth(type_: GType) -> guint;
}
unsafe extern "C" {
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_unref(g_class: gpointer);
}
unsafe extern "C" {
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
unsafe extern "C" {
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
unsafe extern "C" {
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
unsafe extern "C" {
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
unsafe extern "C" {
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
unsafe extern "C" {
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
#[doc = " GBaseInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize\n\n A callback function used by the type system to do base initialization\n of the class structures of derived types.\n\n This function is called as part of the initialization process of all derived\n classes and should reallocate or reset all dynamic class members copied over\n from the parent class.\n\n For example, class members (such as strings) that are not sufficiently\n handled by a plain memory copy of the parent class into the derived class\n have to be altered. See GClassInitFunc() for a discussion of the class\n initialization process."]
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GBaseFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n\n A callback function used by the type system to finalize those portions\n of a derived types class structure that were setup from the corresponding\n GBaseInitFunc() function.\n\n Class finalization basically works the inverse way in which class\n initialization is performed.\n\n See GClassInitFunc() for a discussion of the class initialization process."]
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GClassInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.\n @class_data: The @class_data member supplied via the #GTypeInfo structure.\n\n A callback function used by the type system to initialize the class\n of a specific type.\n\n This function should initialize all static class members.\n\n The initialization process of a class involves:\n\n - Copying common members from the parent class over to the\n   derived class structure.\n - Zero initialization of the remaining members not copied\n   over from the parent class.\n - Invocation of the GBaseInitFunc() initializers of all parent\n   types and the class' type.\n - Invocation of the class' GClassInitFunc() initializer.\n\n Since derived classes are partially initialized through a memory copy\n of the parent class, the general rule is that GBaseInitFunc() and\n GBaseFinalizeFunc() should take care of necessary reinitialization\n and release of those class members that were introduced by the type\n that specified these GBaseInitFunc()/GBaseFinalizeFunc().\n GClassInitFunc() should only care about initializing static\n class members, while dynamic class members (such as allocated strings\n or reference counted resources) are better handled by a GBaseInitFunc()\n for this type, so proper initialization of the dynamic class members\n is performed for class initialization of derived types as well.\n\n An example may help to correspond the intend of the different class\n initializers:\n\n |[<!-- language=\"C\" -->\n typedef struct {\n   GObjectClass parent_class;\n   gint         static_integer;\n   gchar       *dynamic_string;\n } TypeAClass;\n static void\n type_a_base_class_init (TypeAClass *class)\n {\n   class->dynamic_string = g_strdup (\"some string\");\n }\n static void\n type_a_base_class_finalize (TypeAClass *class)\n {\n   g_free (class->dynamic_string);\n }\n static void\n type_a_class_init (TypeAClass *class)\n {\n   class->static_integer = 42;\n }\n\n typedef struct {\n   TypeAClass   parent_class;\n   gfloat       static_float;\n   GString     *dynamic_gstring;\n } TypeBClass;\n static void\n type_b_base_class_init (TypeBClass *class)\n {\n   class->dynamic_gstring = g_string_new (\"some other string\");\n }\n static void\n type_b_base_class_finalize (TypeBClass *class)\n {\n   g_string_free (class->dynamic_gstring);\n }\n static void\n type_b_class_init (TypeBClass *class)\n {\n   class->static_float = 3.14159265358979323846;\n }\n ]|\n\n Initialization of TypeBClass will first cause initialization of\n TypeAClass (derived classes reference their parent classes, see\n g_type_class_ref() on this).\n\n Initialization of TypeAClass roughly involves zero-initializing its fields,\n then calling its GBaseInitFunc() type_a_base_class_init() to allocate\n its dynamic members (dynamic_string), and finally calling its GClassInitFunc()\n type_a_class_init() to initialize its static members (static_integer).\n The first step in the initialization process of TypeBClass is then\n a plain memory copy of the contents of TypeAClass into TypeBClass and\n zero-initialization of the remaining fields in TypeBClass.\n The dynamic members of TypeAClass within TypeBClass now need\n reinitialization which is performed by calling type_a_base_class_init()\n with an argument of TypeBClass.\n\n After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()\n is called to allocate the dynamic members of TypeBClass (dynamic_gstring),\n and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),\n is called to complete the initialization process with the static members\n (static_float).\n\n Corresponding finalization counter parts to the GBaseInitFunc() functions\n have to be provided to release allocated resources at class finalization\n time."]
pub type GClassInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GClassFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n @class_data: The @class_data member supplied via the #GTypeInfo structure\n\n A callback function used by the type system to finalize a class.\n\n This function is rarely needed, as dynamically allocated class resources\n should be handled by GBaseInitFunc() and GBaseFinalizeFunc().\n\n Also, specification of a GClassFinalizeFunc() in the #GTypeInfo\n structure of a static type is invalid, because classes of static types\n will never be finalized (they are artificially kept alive when their\n reference count drops to zero)."]
pub type GClassFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GInstanceInitFunc:\n @instance: The instance to initialize\n @g_class: (type GObject.TypeClass): The class of the type the instance is\n    created for\n\n A callback function used by the type system to initialize a new\n instance of a type.\n\n This function initializes all instance members and allocates any resources\n required by it.\n\n Initialization of a derived instance involves calling all its parent\n types instance initializers, so the class member of the instance\n is altered during its initialization to always point to the class that\n belongs to the type the current initializer was introduced for.\n\n The extended members of @instance are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
#[doc = " GInterfaceInitFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to initialize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to initialize a new\n interface.\n\n This function should initialize all internal data and* allocate any\n resources required by the interface.\n\n The members of @iface_data are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInterfaceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GInterfaceFinalizeFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to finalize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to finalize an interface.\n\n This function should destroy any internal data and release any resources\n allocated by the corresponding GInterfaceInitFunc() function."]
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GTypeClassCacheFunc:\n @cache_data: data that was given to the g_type_add_class_cache_func() call\n @g_class: (type GObject.TypeClass): The #GTypeClass structure which is\n    unreferenced\n\n A callback function which is called when the reference count of a class\n drops to zero.\n\n It may use g_type_class_ref() to prevent the class from being freed. You\n should not call g_type_class_unref() from a #GTypeClassCacheFunc function\n to prevent infinite recursion, use g_type_class_unref_uncached() instead.\n\n The functions have to check the class id passed in to figure\n whether they actually want to cache the class of this type, since all\n classes are routed through the same #GTypeClassCacheFunc chain.\n\n Returns: %TRUE to stop further #GTypeClassCacheFuncs from being\n  called, %FALSE to continue"]
pub type GTypeClassCacheFunc = ::std::option::Option<
    unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean,
>;
#[doc = " GTypeInterfaceCheckFunc:\n @check_data: data passed to g_type_add_interface_check()\n @g_iface: (type GObject.TypeInterface): the interface that has been\n    initialized\n\n A callback called after an interface vtable is initialized.\n\n See g_type_add_interface_check().\n\n Since: 2.4"]
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;
#[doc = " GTypeFundamentalFlags:\n @G_TYPE_FLAG_CLASSED: Indicates a classed type\n @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiatable type (implies classed)\n @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type\n @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)\n\n Bit masks used to check or determine specific characteristics of a\n fundamental type."]
pub type GTypeFundamentalFlags = ::std::os::raw::c_uint;
pub const GTypeFlags_G_TYPE_FLAG_NONE: GTypeFlags = 0;
pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
pub const GTypeFlags_G_TYPE_FLAG_FINAL: GTypeFlags = 64;
pub const GTypeFlags_G_TYPE_FLAG_DEPRECATED: GTypeFlags = 128;
#[doc = " GTypeFlags:\n @G_TYPE_FLAG_NONE: No special flags. Since: 2.74\n @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be\n  created for an abstract type\n @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type\n  that introduces a value table, but can't be used for\n  g_value_init()\n @G_TYPE_FLAG_FINAL: Indicates a final type. A final type is a non-derivable\n  leaf node in a deep derivable type hierarchy tree. Since: 2.70\n @G_TYPE_FLAG_DEPRECATED: The type is deprecated and may be removed in a\n  future version. A warning will be emitted if it is instantiated while\n  running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76\n\n Bit masks used to check or determine characteristics of a type."]
pub type GTypeFlags = ::std::os::raw::c_uint;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeInfo"][::std::mem::size_of::<_GTypeInfo>() - 72usize];
    ["Alignment of _GTypeInfo"][::std::mem::align_of::<_GTypeInfo>() - 8usize];
    ["Offset of field: _GTypeInfo::class_size"]
        [::std::mem::offset_of!(_GTypeInfo, class_size) - 0usize];
    ["Offset of field: _GTypeInfo::base_init"]
        [::std::mem::offset_of!(_GTypeInfo, base_init) - 8usize];
    ["Offset of field: _GTypeInfo::base_finalize"]
        [::std::mem::offset_of!(_GTypeInfo, base_finalize) - 16usize];
    ["Offset of field: _GTypeInfo::class_init"]
        [::std::mem::offset_of!(_GTypeInfo, class_init) - 24usize];
    ["Offset of field: _GTypeInfo::class_finalize"]
        [::std::mem::offset_of!(_GTypeInfo, class_finalize) - 32usize];
    ["Offset of field: _GTypeInfo::class_data"]
        [::std::mem::offset_of!(_GTypeInfo, class_data) - 40usize];
    ["Offset of field: _GTypeInfo::instance_size"]
        [::std::mem::offset_of!(_GTypeInfo, instance_size) - 48usize];
    ["Offset of field: _GTypeInfo::n_preallocs"]
        [::std::mem::offset_of!(_GTypeInfo, n_preallocs) - 50usize];
    ["Offset of field: _GTypeInfo::instance_init"]
        [::std::mem::offset_of!(_GTypeInfo, instance_init) - 56usize];
    ["Offset of field: _GTypeInfo::value_table"]
        [::std::mem::offset_of!(_GTypeInfo, value_table) - 64usize];
};
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeFundamentalInfo"][::std::mem::size_of::<_GTypeFundamentalInfo>() - 4usize];
    ["Alignment of _GTypeFundamentalInfo"]
        [::std::mem::align_of::<_GTypeFundamentalInfo>() - 4usize];
    ["Offset of field: _GTypeFundamentalInfo::type_flags"]
        [::std::mem::offset_of!(_GTypeFundamentalInfo, type_flags) - 0usize];
};
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInterfaceInfo"][::std::mem::size_of::<_GInterfaceInfo>() - 24usize];
    ["Alignment of _GInterfaceInfo"][::std::mem::align_of::<_GInterfaceInfo>() - 8usize];
    ["Offset of field: _GInterfaceInfo::interface_init"]
        [::std::mem::offset_of!(_GInterfaceInfo, interface_init) - 0usize];
    ["Offset of field: _GInterfaceInfo::interface_finalize"]
        [::std::mem::offset_of!(_GInterfaceInfo, interface_finalize) - 8usize];
    ["Offset of field: _GInterfaceInfo::interface_data"]
        [::std::mem::offset_of!(_GInterfaceInfo, interface_data) - 16usize];
};
#[doc = " GTypeValueInitFunc:\n @value: the value to initialize\n\n Initializes the value contents by setting the fields of the `value->data`\n array.\n\n The data array of the #GValue passed into this function was zero-filled\n with `memset()`, so no care has to be taken to free any old contents.\n For example, in the case of a string value that may never be %NULL, the\n implementation might look like:\n\n |[<!-- language=\"C\" -->\n value->data[0].v_pointer = g_strdup (\"\");\n ]|\n\n Since: 2.78"]
pub type GTypeValueInitFunc = ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>;
#[doc = " GTypeValueFreeFunc:\n @value: the value to free\n\n Frees any old contents that might be left in the `value->data` array of\n the given value.\n\n No resources may remain allocated through the #GValue contents after this\n function returns. E.g. for our above string type:\n\n |[<!-- language=\"C\" -->\n // only free strings without a specific flag for static storage\n if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))\n   g_free (value->data[0].v_pointer);\n ]|\n\n Since: 2.78"]
pub type GTypeValueFreeFunc = ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>;
#[doc = " GTypeValueCopyFunc:\n @src_value: the value to copy\n @dest_value: (out): the location of the copy\n\n Copies the content of a #GValue into another.\n\n The @dest_value is a #GValue with zero-filled data section and @src_value\n is a properly initialized #GValue of same type, or derived type.\n\n The purpose of this function is to copy the contents of @src_value\n into @dest_value in a way, that even after @src_value has been freed, the\n contents of @dest_value remain valid. String type example:\n\n |[<!-- language=\"C\" -->\n dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);\n ]|\n\n Since: 2.78"]
pub type GTypeValueCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GTypeValuePeekPointerFunc:\n @value: the value to peek\n\n If the value contents fit into a pointer, such as objects or strings,\n return this pointer, so the caller can peek at the current contents.\n\n To extend on our above string example:\n\n |[<!-- language=\"C\" -->\n return value->data[0].v_pointer;\n ]|\n\n Returns: (transfer none): a pointer to the value contents\n\n Since: 2.78"]
pub type GTypeValuePeekPointerFunc =
    ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>;
#[doc = " GTypeValueCollectFunc:\n @value: the value to initialize\n @n_collect_values: the number of collected values\n @collect_values: (array length=n_collect_values): the collected values\n @collect_flags: optional flags\n\n This function is responsible for converting the values collected from\n a variadic argument list into contents suitable for storage in a #GValue.\n\n This function should setup @value similar to #GTypeValueInitFunc; e.g.\n for a string value that does not allow `NULL` pointers, it needs to either\n emit an error, or do an implicit conversion by storing an empty string.\n\n The @value passed in to this function has a zero-filled data array, so\n just like for #GTypeValueInitFunc it is guaranteed to not contain any old\n contents that might need freeing.\n\n The @n_collect_values argument is the string length of the `collect_format`\n field of #GTypeValueTable, and `collect_values` is an array of #GTypeCValue\n with length of @n_collect_values, containing the collected values according\n to `collect_format`.\n\n The @collect_flags argument provided as a hint by the caller. It may\n contain the flag %G_VALUE_NOCOPY_CONTENTS indicating that the collected\n value contents may be considered ‘static’ for the duration of the @value\n lifetime. Thus an extra copy of the contents stored in @collect_values is\n not required for assignment to @value.\n\n For our above string example, we continue with:\n\n |[<!-- language=\"C\" -->\n if (!collect_values[0].v_pointer)\n   value->data[0].v_pointer = g_strdup (\"\");\n else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n   {\n     value->data[0].v_pointer = collect_values[0].v_pointer;\n     // keep a flag for the value_free() implementation to not free this string\n     value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;\n   }\n else\n   value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);\n return NULL;\n ]|\n\n It should be noted, that it is generally a bad idea to follow the\n %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to\n reentrancy requirements and reference count assertions performed\n by the signal emission code, reference counts should always be\n incremented for reference counted contents stored in the `value->data`\n array. To deviate from our string example for a moment, and taking\n a look at an exemplary implementation for `GTypeValueTable.collect_value()`\n of `GObject`:\n\n |[<!-- language=\"C\" -->\n GObject *object = G_OBJECT (collect_values[0].v_pointer);\n g_return_val_if_fail (object != NULL,\n    g_strdup_printf (\"Object %p passed as invalid NULL pointer\", object));\n // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types\n value->data[0].v_pointer = g_object_ref (object);\n return NULL;\n ]|\n\n The reference count for valid objects is always incremented, regardless\n of `collect_flags`. For invalid objects, the example returns a newly\n allocated string without altering `value`.\n\n Upon success, `collect_value()` needs to return `NULL`. If, however,\n an error condition occurred, `collect_value()` should return a newly\n allocated string containing an error diagnostic.\n\n The calling code makes no assumptions about the `value` contents being\n valid upon error returns, `value` is simply thrown away without further\n freeing. As such, it is a good idea to not allocate `GValue` contents\n prior to returning an error; however, `collect_values()` is not obliged\n to return a correctly setup @value for error returns, simply because\n any non-`NULL` return is considered a fatal programming error, and\n further program behaviour is undefined.\n\n Returns: (transfer full) (nullable): `NULL` on success, otherwise a\n   newly allocated error string on failure\n\n Since: 2.78"]
pub type GTypeValueCollectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GValue,
        n_collect_values: guint,
        collect_values: *mut GTypeCValue,
        collect_flags: guint,
    ) -> *mut gchar,
>;
#[doc = " GTypeValueLCopyFunc:\n @value: the value to lcopy\n @n_collect_values: the number of collected values\n @collect_values: (array length=n_collect_values): the collected\n   locations for storage\n @collect_flags: optional flags\n\n This function is responsible for storing the `value`\n contents into arguments passed through a variadic argument list which\n got collected into `collect_values` according to `lcopy_format`.\n\n The `n_collect_values` argument equals the string length of\n `lcopy_format`, and `collect_flags` may contain %G_VALUE_NOCOPY_CONTENTS.\n\n In contrast to #GTypeValueCollectFunc, this function is obliged to always\n properly support %G_VALUE_NOCOPY_CONTENTS.\n\n Similar to #GTypeValueCollectFunc the function may prematurely abort by\n returning a newly allocated string describing an error condition. To\n complete the string example:\n\n |[<!-- language=\"C\" -->\n gchar **string_p = collect_values[0].v_pointer;\n g_return_val_if_fail (string_p != NULL,\n   g_strdup (\"string location passed as NULL\"));\n\n if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n   *string_p = value->data[0].v_pointer;\n else\n   *string_p = g_strdup (value->data[0].v_pointer);\n ]|\n\n And an illustrative version of this function for reference-counted\n types:\n\n |[<!-- language=\"C\" -->\n GObject **object_p = collect_values[0].v_pointer;\n g_return_val_if_fail (object_p != NULL,\n   g_strdup (\"object location passed as NULL\"));\n\n if (value->data[0].v_pointer == NULL)\n   *object_p = NULL;\n else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour\n   *object_p = value->data[0].v_pointer;\n else\n   *object_p = g_object_ref (value->data[0].v_pointer);\n\n return NULL;\n ]|\n\n Returns: (transfer full) (nullable): `NULL` on success, otherwise\n   a newly allocated error string on failure\n\n Since: 2.78"]
pub type GTypeValueLCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const GValue,
        n_collect_values: guint,
        collect_values: *mut GTypeCValue,
        collect_flags: guint,
    ) -> *mut gchar,
>;
#[doc = " GTypeValueTable:\n @value_init: Function to initialize a GValue\n @value_free: Function to free a GValue\n @value_copy: Function to copy a GValue\n @value_peek_pointer: Function to peek the contents of a GValue if they fit\n   into a pointer\n @collect_format: A string format describing how to collect the contents of\n   this value bit-by-bit. Each character in the format represents\n   an argument to be collected, and the characters themselves indicate\n   the type of the argument. Currently supported arguments are:\n    - `'i'`: Integers, passed as `collect_values[].v_int`\n    - `'l'`: Longs, passed as `collect_values[].v_long`\n    - `'d'`: Doubles, passed as `collect_values[].v_double`\n    - `'p'`: Pointers, passed as `collect_values[].v_pointer`\n   It should be noted that for variable argument list construction,\n   ANSI C promotes every type smaller than an integer to an int, and\n   floats to doubles. So for collection of short int or char, `'i'`\n   needs to be used, and for collection of floats `'d'`.\n @collect_value: Function to initialize a GValue from the values\n   collected from variadic arguments\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n   analogous to @collect_format. Usually, @lcopy_format string consists\n   only of `'p'`s to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: Function to store the contents of a value into the\n   locations collected from variadic arguments\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeValueTable {
    pub value_init: GTypeValueInitFunc,
    pub value_free: GTypeValueFreeFunc,
    pub value_copy: GTypeValueCopyFunc,
    pub value_peek_pointer: GTypeValuePeekPointerFunc,
    pub collect_format: *const gchar,
    pub collect_value: GTypeValueCollectFunc,
    pub lcopy_format: *const gchar,
    pub lcopy_value: GTypeValueLCopyFunc,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeValueTable"][::std::mem::size_of::<_GTypeValueTable>() - 64usize];
    ["Alignment of _GTypeValueTable"][::std::mem::align_of::<_GTypeValueTable>() - 8usize];
    ["Offset of field: _GTypeValueTable::value_init"]
        [::std::mem::offset_of!(_GTypeValueTable, value_init) - 0usize];
    ["Offset of field: _GTypeValueTable::value_free"]
        [::std::mem::offset_of!(_GTypeValueTable, value_free) - 8usize];
    ["Offset of field: _GTypeValueTable::value_copy"]
        [::std::mem::offset_of!(_GTypeValueTable, value_copy) - 16usize];
    ["Offset of field: _GTypeValueTable::value_peek_pointer"]
        [::std::mem::offset_of!(_GTypeValueTable, value_peek_pointer) - 24usize];
    ["Offset of field: _GTypeValueTable::collect_format"]
        [::std::mem::offset_of!(_GTypeValueTable, collect_format) - 32usize];
    ["Offset of field: _GTypeValueTable::collect_value"]
        [::std::mem::offset_of!(_GTypeValueTable, collect_value) - 40usize];
    ["Offset of field: _GTypeValueTable::lcopy_format"]
        [::std::mem::offset_of!(_GTypeValueTable, lcopy_format) - 48usize];
    ["Offset of field: _GTypeValueTable::lcopy_value"]
        [::std::mem::offset_of!(_GTypeValueTable, lcopy_value) - 56usize];
};
unsafe extern "C" {
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const gchar,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
}
unsafe extern "C" {
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
}
unsafe extern "C" {
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
unsafe extern "C" {
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut guint,
    ) -> *mut GType;
}
unsafe extern "C" {
    pub fn g_type_interface_instantiatable_prerequisite(interface_type: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
unsafe extern "C" {
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
unsafe extern "C" {
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
unsafe extern "C" {
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
unsafe extern "C" {
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
unsafe extern "C" {
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
unsafe extern "C" {
    pub fn g_type_ensure(type_: GType);
}
unsafe extern "C" {
    pub fn g_type_get_type_registration_serial() -> guint;
}
unsafe extern "C" {
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
unsafe extern "C" {
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
}
unsafe extern "C" {
    pub fn g_type_fundamental_next() -> GType;
}
unsafe extern "C" {
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
unsafe extern "C" {
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
unsafe extern "C" {
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
unsafe extern "C" {
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
unsafe extern "C" {
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
unsafe extern "C" {
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
unsafe extern "C" {
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
unsafe extern "C" {
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
unsafe extern "C" {
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
unsafe extern "C" {
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
}
unsafe extern "C" {
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
unsafe extern "C" {
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_value(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_check_value_holds(value: *const GValue, type_: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
#[doc = " GValueTransform:\n @src_value: Source value.\n @dest_value: Target value.\n\n The type of value transformation functions which can be registered with\n g_value_register_transform_func().\n\n @dest_value will be initialized to the correct destination type."]
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValue__bindgen_ty_1"][::std::mem::size_of::<_GValue__bindgen_ty_1>() - 8usize];
    ["Alignment of _GValue__bindgen_ty_1"]
        [::std::mem::align_of::<_GValue__bindgen_ty_1>() - 8usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_int"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_int) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_uint"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_uint) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_long"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_long) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_ulong"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_ulong) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_int64"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_int64) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_uint64"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_uint64) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_float"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_float) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_double"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_double) - 0usize];
    ["Offset of field: _GValue__bindgen_ty_1::v_pointer"]
        [::std::mem::offset_of!(_GValue__bindgen_ty_1, v_pointer) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValue"][::std::mem::size_of::<_GValue>() - 24usize];
    ["Alignment of _GValue"][::std::mem::align_of::<_GValue>() - 8usize];
    ["Offset of field: _GValue::g_type"][::std::mem::offset_of!(_GValue, g_type) - 0usize];
    ["Offset of field: _GValue::data"][::std::mem::offset_of!(_GValue, data) - 8usize];
};
unsafe extern "C" {
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
unsafe extern "C" {
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
unsafe extern "C" {
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
unsafe extern "C" {
    pub fn g_value_unset(value: *mut GValue);
}
unsafe extern "C" {
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
unsafe extern "C" {
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
unsafe extern "C" {
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
#[doc = " GParamFlags:\n @G_PARAM_READABLE: the parameter is readable\n @G_PARAM_WRITABLE: the parameter is writable\n @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE\n @G_PARAM_CONSTRUCT: the parameter will be set upon object construction\n @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction\n @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())\n  strict validation is not required\n @G_PARAM_STATIC_NAME: the string used as name when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_NICK: the string used as nick when constructing the\n  parameter is guaranteed to remain valid and\n  unmmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this\n   property will not automatically result in a \"notify\" signal being\n   emitted: the implementation must call g_object_notify() themselves\n   in case the property actually changes.  Since: 2.42.\n @G_PARAM_PRIVATE: internal\n @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed\n  in a future version. A warning will be generated if it is used\n  while running with G_ENABLE_DIAGNOSTIC=1.\n  Since 2.26\n\n Through the #GParamFlags flag values, certain aspects of parameters\n can be configured.\n\n See also: %G_PARAM_STATIC_STRINGS"]
pub type GParamFlags = ::std::os::raw::c_int;
pub type GParamSpec = _GParamSpec;
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
pub type GParamSpecClass = _GParamSpecClass;
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpec"][::std::mem::size_of::<_GParamSpec>() - 72usize];
    ["Alignment of _GParamSpec"][::std::mem::align_of::<_GParamSpec>() - 8usize];
    ["Offset of field: _GParamSpec::g_type_instance"]
        [::std::mem::offset_of!(_GParamSpec, g_type_instance) - 0usize];
    ["Offset of field: _GParamSpec::name"][::std::mem::offset_of!(_GParamSpec, name) - 8usize];
    ["Offset of field: _GParamSpec::flags"][::std::mem::offset_of!(_GParamSpec, flags) - 16usize];
    ["Offset of field: _GParamSpec::value_type"]
        [::std::mem::offset_of!(_GParamSpec, value_type) - 24usize];
    ["Offset of field: _GParamSpec::owner_type"]
        [::std::mem::offset_of!(_GParamSpec, owner_type) - 32usize];
    ["Offset of field: _GParamSpec::_nick"][::std::mem::offset_of!(_GParamSpec, _nick) - 40usize];
    ["Offset of field: _GParamSpec::_blurb"][::std::mem::offset_of!(_GParamSpec, _blurb) - 48usize];
    ["Offset of field: _GParamSpec::qdata"][::std::mem::offset_of!(_GParamSpec, qdata) - 56usize];
    ["Offset of field: _GParamSpec::ref_count"]
        [::std::mem::offset_of!(_GParamSpec, ref_count) - 64usize];
    ["Offset of field: _GParamSpec::param_id"]
        [::std::mem::offset_of!(_GParamSpec, param_id) - 68usize];
};
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
    pub value_is_valid: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *const GValue) -> gboolean,
    >,
    pub dummy: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecClass"][::std::mem::size_of::<_GParamSpecClass>() - 80usize];
    ["Alignment of _GParamSpecClass"][::std::mem::align_of::<_GParamSpecClass>() - 8usize];
    ["Offset of field: _GParamSpecClass::g_type_class"]
        [::std::mem::offset_of!(_GParamSpecClass, g_type_class) - 0usize];
    ["Offset of field: _GParamSpecClass::value_type"]
        [::std::mem::offset_of!(_GParamSpecClass, value_type) - 8usize];
    ["Offset of field: _GParamSpecClass::finalize"]
        [::std::mem::offset_of!(_GParamSpecClass, finalize) - 16usize];
    ["Offset of field: _GParamSpecClass::value_set_default"]
        [::std::mem::offset_of!(_GParamSpecClass, value_set_default) - 24usize];
    ["Offset of field: _GParamSpecClass::value_validate"]
        [::std::mem::offset_of!(_GParamSpecClass, value_validate) - 32usize];
    ["Offset of field: _GParamSpecClass::values_cmp"]
        [::std::mem::offset_of!(_GParamSpecClass, values_cmp) - 40usize];
    ["Offset of field: _GParamSpecClass::value_is_valid"]
        [::std::mem::offset_of!(_GParamSpecClass, value_is_valid) - 48usize];
    ["Offset of field: _GParamSpecClass::dummy"]
        [::std::mem::offset_of!(_GParamSpecClass, dummy) - 56usize];
};
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParameter"][::std::mem::size_of::<_GParameter>() - 32usize];
    ["Alignment of _GParameter"][::std::mem::align_of::<_GParameter>() - 8usize];
    ["Offset of field: _GParameter::name"][::std::mem::offset_of!(_GParameter, name) - 0usize];
    ["Offset of field: _GParameter::value"][::std::mem::offset_of!(_GParameter, value) - 8usize];
};
unsafe extern "C" {
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
unsafe extern "C" {
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
unsafe extern "C" {
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_value_is_valid(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
unsafe extern "C" {
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecTypeInfo"][::std::mem::size_of::<_GParamSpecTypeInfo>() - 56usize];
    ["Alignment of _GParamSpecTypeInfo"][::std::mem::align_of::<_GParamSpecTypeInfo>() - 8usize];
    ["Offset of field: _GParamSpecTypeInfo::instance_size"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, instance_size) - 0usize];
    ["Offset of field: _GParamSpecTypeInfo::n_preallocs"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, n_preallocs) - 2usize];
    ["Offset of field: _GParamSpecTypeInfo::instance_init"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, instance_init) - 8usize];
    ["Offset of field: _GParamSpecTypeInfo::value_type"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, value_type) - 16usize];
    ["Offset of field: _GParamSpecTypeInfo::finalize"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, finalize) - 24usize];
    ["Offset of field: _GParamSpecTypeInfo::value_set_default"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, value_set_default) - 32usize];
    ["Offset of field: _GParamSpecTypeInfo::value_validate"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, value_validate) - 40usize];
    ["Offset of field: _GParamSpecTypeInfo::values_cmp"]
        [::std::mem::offset_of!(_GParamSpecTypeInfo, values_cmp) - 48usize];
};
unsafe extern "C" {
    pub fn g_param_type_register_static(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_param_spec_is_valid_name(name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn _g_param_type_register_static_constant(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
        opt_type: GType,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
}
unsafe extern "C" {
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType)
        -> *mut GList;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_pool_free(pool: *mut GParamSpecPool);
}
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
#[doc = " GCallback:\n\n The type used for callback functions in structure definitions and function\n signatures.\n\n This doesn't mean that all callback functions must take no  parameters and\n return void. The required signature of a callback function is determined by\n the context in which is used (e.g. the signal to which it is connected).\n\n Use G_CALLBACK() to cast the callback function to a #GCallback."]
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " GClosureNotify:\n @data: data specified when registering the notification callback\n @closure: the #GClosure on which the notification is emitted\n\n The type used for the various notification callbacks which can be registered\n on closures."]
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
#[doc = " GClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @n_param_values: the length of the @param_values array\n @param_values: (array length=n_param_values): an array of\n  #GValues holding the arguments on which to invoke the\n  callback of @closure\n @invocation_hint: (nullable): the invocation hint given as the\n  last argument to g_closure_invoke()\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n\n The type used for marshaller functions."]
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
#[doc = " GVaClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @instance: (type GObject.TypeInstance): the instance on which the closure is\n  invoked.\n @args: va_list of arguments to be passed to the closure.\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n @n_params: the length of the @param_types array\n @param_types: (array length=n_params): the #GType of each argument from\n  @args.\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
#[doc = " GCClosure:\n @closure: the #GClosure\n @callback: the callback function\n\n A #GCClosure is a specialization of #GClosure for C function callbacks."]
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GClosureNotifyData"][::std::mem::size_of::<_GClosureNotifyData>() - 16usize];
    ["Alignment of _GClosureNotifyData"][::std::mem::align_of::<_GClosureNotifyData>() - 8usize];
    ["Offset of field: _GClosureNotifyData::data"]
        [::std::mem::offset_of!(_GClosureNotifyData, data) - 0usize];
    ["Offset of field: _GClosureNotifyData::notify"]
        [::std::mem::offset_of!(_GClosureNotifyData, notify) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosure {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GClosure"][::std::mem::size_of::<_GClosure>() - 32usize];
    ["Alignment of _GClosure"][::std::mem::align_of::<_GClosure>() - 8usize];
    ["Offset of field: _GClosure::marshal"][::std::mem::offset_of!(_GClosure, marshal) - 8usize];
    ["Offset of field: _GClosure::data"][::std::mem::offset_of!(_GClosure, data) - 16usize];
    ["Offset of field: _GClosure::notifiers"]
        [::std::mem::offset_of!(_GClosure, notifiers) - 24usize];
};
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ref_count_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                15u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ref_count_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                15u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn meta_marshal_nouse_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                15usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_meta_marshal_nouse_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                15usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_guards_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                16usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_n_guards_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                16usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_fnotifiers_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                17usize,
                2u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_n_fnotifiers_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                17usize,
                2u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn n_inotifiers_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                19usize,
                8u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_n_inotifiers_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                19usize,
                8u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_inotify_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                27usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_inotify_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                27usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn floating_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                28usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_floating_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                28usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn derivative_flag_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                29usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_derivative_flag_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                29usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn in_marshal_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                30usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_in_marshal_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                30usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn is_invalid_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                31usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_is_invalid_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                31usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCClosure"][::std::mem::size_of::<_GCClosure>() - 40usize];
    ["Alignment of _GCClosure"][::std::mem::align_of::<_GCClosure>() - 8usize];
    ["Offset of field: _GCClosure::closure"][::std::mem::offset_of!(_GCClosure, closure) - 0usize];
    ["Offset of field: _GCClosure::callback"]
        [::std::mem::offset_of!(_GCClosure, callback) - 32usize];
};
unsafe extern "C" {
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_sink(closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_closure_unref(closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
unsafe extern "C" {
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
unsafe extern "C" {
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
}
unsafe extern "C" {
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
pub type GSignalQuery = _GSignalQuery;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
pub type GSignalInvocationHint = _GSignalInvocationHint;
#[doc = " GSignalCMarshaller:\n\n This is the signature of marshaller functions, required to marshall\n arrays of parameter values to signal emissions into C language callback\n invocations.\n\n It is merely an alias to #GClosureMarshal since the #GClosure mechanism\n takes over responsibility of actual function invocation for the signal\n system."]
pub type GSignalCMarshaller = GClosureMarshal;
#[doc = " GSignalCVaMarshaller:\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GSignalCVaMarshaller = GVaClosureMarshal;
#[doc = " GSignalEmissionHook:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @n_param_values: the number of parameters to the function, including\n  the instance on which the signal was emitted.\n @param_values: (array length=n_param_values): the instance on which\n  the signal was emitted, followed by the parameters of the emission.\n @data: user data associated with the hook.\n\n A simple function pointer to get invoked when the signal is emitted.\n\n Emission hooks allow you to tie a hook to the signal type, so that it will\n trap all emissions of that signal, from any object.\n\n You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.\n\n Returns: whether it wants to stay connected. If it returns %FALSE, the signal\n  hook is disconnected (and destroyed)."]
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        n_param_values: guint,
        param_values: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSignalAccumulator:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @return_accu: Accumulator to collect callback return values in, this\n  is the return value of the current signal emission.\n @handler_return: A #GValue holding the return value of the signal handler.\n @data: Callback data that was specified when creating the signal.\n\n The signal accumulator is a special callback function that can be used\n to collect return values of the various callbacks that are called\n during a signal emission.\n\n The signal accumulator is specified at signal creation time, if it is\n left %NULL, no accumulation of callback return values is performed.\n The return value of signal emissions is then the value returned by the\n last callback.\n\n Returns: The accumulator function returns whether the signal emission\n  should be aborted. Returning %TRUE will continue with\n  the signal emission. Returning %FALSE will abort the current emission.\n  Since 2.62, returning %FALSE will skip to the CLEANUP stage. In this case,\n  emission will occur as normal in the CLEANUP stage and the handler's\n  return value will be accumulated."]
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
pub const GSignalFlags_G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const GSignalFlags_G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const GSignalFlags_G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const GSignalFlags_G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const GSignalFlags_G_SIGNAL_ACTION: GSignalFlags = 32;
pub const GSignalFlags_G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const GSignalFlags_G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const GSignalFlags_G_SIGNAL_DEPRECATED: GSignalFlags = 256;
pub const GSignalFlags_G_SIGNAL_ACCUMULATOR_FIRST_RUN: GSignalFlags = 131072;
#[doc = " GSignalFlags:\n @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.\n @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.\n @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.\n @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in\n  emission for this very object will not be emitted recursively,\n  but instead cause the first emission to be restarted.\n @G_SIGNAL_DETAILED: This signal supports \"::detail\" appendices to the signal name\n  upon handler connections and emissions.\n @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive\n  objects from user code via g_signal_emit() and friends, without\n  the need of being embedded into extra code that performs pre or\n  post emission adjustments on the object. They can also be thought\n  of as object methods which can be called generically by\n  third-party code.\n @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.\n @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the\n   arguments, even if there are no signal handlers connected.  Since 2.30.\n @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed\n   in a future version. A warning will be generated if it is connected while\n   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.\n @G_SIGNAL_ACCUMULATOR_FIRST_RUN: Only used in #GSignalAccumulator accumulator\n   functions for the #GSignalInvocationHint::run_type field to mark the first\n   call to the accumulator function for a signal emission.  Since 2.68.\n\n The signal flags are used to specify a signal's behaviour."]
pub type GSignalFlags = ::std::os::raw::c_uint;
pub const GConnectFlags_G_CONNECT_DEFAULT: GConnectFlags = 0;
pub const GConnectFlags_G_CONNECT_AFTER: GConnectFlags = 1;
pub const GConnectFlags_G_CONNECT_SWAPPED: GConnectFlags = 2;
#[doc = " GConnectFlags:\n @G_CONNECT_DEFAULT: Default behaviour (no special flags). Since: 2.74\n @G_CONNECT_AFTER: If set, the handler should be called after the\n  default handler of the signal. Normally, the handler is called before\n  the default handler.\n @G_CONNECT_SWAPPED: If set, the instance and data should be swapped when\n  calling the handler; see g_signal_connect_swapped() for an example.\n\n The connection flags are used to specify the behaviour of a signal's\n connection."]
pub type GConnectFlags = ::std::os::raw::c_uint;
pub const GSignalMatchType_G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const GSignalMatchType_G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;
#[doc = " GSignalMatchType:\n @G_SIGNAL_MATCH_ID: The signal id must be equal.\n @G_SIGNAL_MATCH_DETAIL: The signal detail must be equal.\n @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.\n @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.\n @G_SIGNAL_MATCH_DATA: The closure data must be the same.\n @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may be matched.\n\n The match types specify what g_signal_handlers_block_matched(),\n g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()\n match signals by."]
pub type GSignalMatchType = ::std::os::raw::c_uint;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSignalInvocationHint"][::std::mem::size_of::<_GSignalInvocationHint>() - 12usize];
    ["Alignment of _GSignalInvocationHint"]
        [::std::mem::align_of::<_GSignalInvocationHint>() - 4usize];
    ["Offset of field: _GSignalInvocationHint::signal_id"]
        [::std::mem::offset_of!(_GSignalInvocationHint, signal_id) - 0usize];
    ["Offset of field: _GSignalInvocationHint::detail"]
        [::std::mem::offset_of!(_GSignalInvocationHint, detail) - 4usize];
    ["Offset of field: _GSignalInvocationHint::run_type"]
        [::std::mem::offset_of!(_GSignalInvocationHint, run_type) - 8usize];
};
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSignalQuery"][::std::mem::size_of::<_GSignalQuery>() - 56usize];
    ["Alignment of _GSignalQuery"][::std::mem::align_of::<_GSignalQuery>() - 8usize];
    ["Offset of field: _GSignalQuery::signal_id"]
        [::std::mem::offset_of!(_GSignalQuery, signal_id) - 0usize];
    ["Offset of field: _GSignalQuery::signal_name"]
        [::std::mem::offset_of!(_GSignalQuery, signal_name) - 8usize];
    ["Offset of field: _GSignalQuery::itype"]
        [::std::mem::offset_of!(_GSignalQuery, itype) - 16usize];
    ["Offset of field: _GSignalQuery::signal_flags"]
        [::std::mem::offset_of!(_GSignalQuery, signal_flags) - 24usize];
    ["Offset of field: _GSignalQuery::return_type"]
        [::std::mem::offset_of!(_GSignalQuery, return_type) - 32usize];
    ["Offset of field: _GSignalQuery::n_params"]
        [::std::mem::offset_of!(_GSignalQuery, n_params) - 40usize];
    ["Offset of field: _GSignalQuery::param_types"]
        [::std::mem::offset_of!(_GSignalQuery, param_types) - 48usize];
};
unsafe extern "C" {
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: *mut __va_list_tag,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_set_va_marshaller(
        signal_id: guint,
        instance_type: GType,
        va_marshaller: GSignalCVaMarshaller,
    );
}
unsafe extern "C" {
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: guint,
        detail: GQuark,
        return_value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_signal_emit_valist(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
unsafe extern "C" {
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
unsafe extern "C" {
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
unsafe extern "C" {
    pub fn g_signal_is_valid_name(name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
unsafe extern "C" {
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
unsafe extern "C" {
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
unsafe extern "C" {
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_has_handler_pending(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_connect_closure(
        instance: gpointer,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_clear_signal_handler(handler_id_ptr: *mut gulong, instance: gpointer);
}
unsafe extern "C" {
    pub fn g_signal_override_class_closure(
        signal_id: guint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
}
unsafe extern "C" {
    pub fn g_signal_override_class_handler(
        signal_name: *const gchar,
        instance_type: GType,
        class_handler: GCallback,
    );
}
unsafe extern "C" {
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
unsafe extern "C" {
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
unsafe extern "C" {
    pub fn _g_signals_destroy(itype: GType);
}
unsafe extern "C" {
    pub fn g_date_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_strv_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_gstring_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_hash_table_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_byte_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_ptr_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bytes_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_type_get_gtype() -> GType;
}
unsafe extern "C" {
    pub fn g_regex_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_match_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_date_time_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_time_zone_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_channel_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_condition_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_builder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_dict_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_key_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_main_loop_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_main_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_source_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pollfd_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_thread_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_checksum_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_markup_parse_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mapped_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_option_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_uri_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tree_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pattern_spec_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bookmark_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_hmac_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dir_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_rand_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_strv_builder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_variant_get_gtype() -> GType;
}
#[doc = " GBoxedCopyFunc:\n @boxed: (not nullable): The boxed structure to be copied.\n\n This function is provided by the user and should produce a copy\n of the passed in boxed structure.\n\n Returns: (not nullable): The newly created copy of the boxed structure."]
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
#[doc = " GBoxedFreeFunc:\n @boxed: (not nullable): The boxed structure to be freed.\n\n This function is provided by the user and should free the boxed\n structure passed."]
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
unsafe extern "C" {
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
unsafe extern "C" {
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
unsafe extern "C" {
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_boxed_type_register_static(
        name: *const gchar,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_closure_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_value_get_type() -> GType;
}
pub type GObject = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GObjectClass = _GObjectClass;
pub type GInitiallyUnowned = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GInitiallyUnownedClass = _GObjectClass;
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
pub type GObjectConstructParam = _GObjectConstructParam;
#[doc = " GObjectGetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: a #GValue to return the property value in\n @pspec: the #GParamSpec describing the property\n\n The type of the @get_property function of #GObjectClass."]
pub type GObjectGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectSetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: the new value for the property\n @pspec: the #GParamSpec describing the property\n\n The type of the @set_property function of #GObjectClass."]
pub type GObjectSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectFinalizeFunc:\n @object: the #GObject being finalized\n\n The type of the @finalize function of #GObjectClass."]
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
#[doc = " GWeakNotify:\n @data: data that was provided when the weak reference was established\n @where_the_object_was: the object being disposed\n\n A #GWeakNotify function can be added to an object as a callback that gets\n triggered when the object is finalized.\n\n Since the object is already being disposed when the #GWeakNotify is called,\n there's not much you could do with the object, apart from e.g. using its\n address as hash-index or the like.\n\n In particular, this means it’s invalid to call g_object_ref(),\n g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),\n g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls\n them on the object from this callback."]
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObject"][::std::mem::size_of::<_GObject>() - 24usize];
    ["Alignment of _GObject"][::std::mem::align_of::<_GObject>() - 8usize];
    ["Offset of field: _GObject::g_type_instance"]
        [::std::mem::offset_of!(_GObject, g_type_instance) - 0usize];
    ["Offset of field: _GObject::ref_count"][::std::mem::offset_of!(_GObject, ref_count) - 8usize];
    ["Offset of field: _GObject::qdata"][::std::mem::offset_of!(_GObject, qdata) - 16usize];
};
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub n_construct_properties: gsize,
    pub pspecs: gpointer,
    pub n_pspecs: gsize,
    pub pdummy: [gpointer; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObjectClass"][::std::mem::size_of::<_GObjectClass>() - 136usize];
    ["Alignment of _GObjectClass"][::std::mem::align_of::<_GObjectClass>() - 8usize];
    ["Offset of field: _GObjectClass::g_type_class"]
        [::std::mem::offset_of!(_GObjectClass, g_type_class) - 0usize];
    ["Offset of field: _GObjectClass::construct_properties"]
        [::std::mem::offset_of!(_GObjectClass, construct_properties) - 8usize];
    ["Offset of field: _GObjectClass::constructor"]
        [::std::mem::offset_of!(_GObjectClass, constructor) - 16usize];
    ["Offset of field: _GObjectClass::set_property"]
        [::std::mem::offset_of!(_GObjectClass, set_property) - 24usize];
    ["Offset of field: _GObjectClass::get_property"]
        [::std::mem::offset_of!(_GObjectClass, get_property) - 32usize];
    ["Offset of field: _GObjectClass::dispose"]
        [::std::mem::offset_of!(_GObjectClass, dispose) - 40usize];
    ["Offset of field: _GObjectClass::finalize"]
        [::std::mem::offset_of!(_GObjectClass, finalize) - 48usize];
    ["Offset of field: _GObjectClass::dispatch_properties_changed"]
        [::std::mem::offset_of!(_GObjectClass, dispatch_properties_changed) - 56usize];
    ["Offset of field: _GObjectClass::notify"]
        [::std::mem::offset_of!(_GObjectClass, notify) - 64usize];
    ["Offset of field: _GObjectClass::constructed"]
        [::std::mem::offset_of!(_GObjectClass, constructed) - 72usize];
    ["Offset of field: _GObjectClass::flags"]
        [::std::mem::offset_of!(_GObjectClass, flags) - 80usize];
    ["Offset of field: _GObjectClass::n_construct_properties"]
        [::std::mem::offset_of!(_GObjectClass, n_construct_properties) - 88usize];
    ["Offset of field: _GObjectClass::pspecs"]
        [::std::mem::offset_of!(_GObjectClass, pspecs) - 96usize];
    ["Offset of field: _GObjectClass::n_pspecs"]
        [::std::mem::offset_of!(_GObjectClass, n_pspecs) - 104usize];
    ["Offset of field: _GObjectClass::pdummy"]
        [::std::mem::offset_of!(_GObjectClass, pdummy) - 112usize];
};
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GObjectConstructParam"][::std::mem::size_of::<_GObjectConstructParam>() - 16usize];
    ["Alignment of _GObjectConstructParam"]
        [::std::mem::align_of::<_GObjectConstructParam>() - 8usize];
    ["Offset of field: _GObjectConstructParam::pspec"]
        [::std::mem::offset_of!(_GObjectConstructParam, pspec) - 0usize];
    ["Offset of field: _GObjectConstructParam::value"]
        [::std::mem::offset_of!(_GObjectConstructParam, value) - 8usize];
};
unsafe extern "C" {
    #[doc = " GInitiallyUnowned:\n\n A type for objects that have an initially floating reference.\n\n All the fields in the `GInitiallyUnowned` structure are private to the\n implementation and should never be accessed directly.\n/\n/**\n GInitiallyUnownedClass:\n\n The class structure for the GInitiallyUnowned type."]
    pub fn g_initially_unowned_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        pspec: *mut GParamSpec,
    );
}
unsafe extern "C" {
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut guint,
    ) -> *mut *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: guint,
        pspecs: *mut *mut GParamSpec,
    );
}
unsafe extern "C" {
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_object_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: guint,
        names: *mut *const ::std::os::raw::c_char,
        values: *const GValue,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *const GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_set_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_get_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *const GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn g_object_freeze_notify(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
unsafe extern "C" {
    pub fn g_object_thaw_notify(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_take_ref(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_unref(object: gpointer);
}
unsafe extern "C" {
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
unsafe extern "C" {
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
#[doc = " GToggleNotify:\n @data: Callback data passed to g_object_add_toggle_ref()\n @object: The object on which g_object_add_toggle_ref() was called.\n @is_last_ref: %TRUE if the toggle reference is now the\n  last reference to the object. %FALSE if the toggle\n  reference was the last reference and there are now other\n  references.\n\n A callback function used for notification when the state\n of a toggle reference changes.\n\n See also: g_object_add_toggle_ref()"]
pub type GToggleNotify = ::std::option::Option<
    unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean),
>;
unsafe extern "C" {
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
unsafe extern "C" {
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const gchar,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const gchar,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
unsafe extern "C" {
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
unsafe extern "C" {
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_object_force_floating(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_object_run_dispose(object: *mut GObject);
}
unsafe extern "C" {
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
unsafe extern "C" {
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
unsafe extern "C" {
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
unsafe extern "C" {
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GWeakRef__bindgen_ty_1"][::std::mem::size_of::<GWeakRef__bindgen_ty_1>() - 8usize];
    ["Alignment of GWeakRef__bindgen_ty_1"]
        [::std::mem::align_of::<GWeakRef__bindgen_ty_1>() - 8usize];
    ["Offset of field: GWeakRef__bindgen_ty_1::p"]
        [::std::mem::offset_of!(GWeakRef__bindgen_ty_1, p) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GWeakRef"][::std::mem::size_of::<GWeakRef>() - 8usize];
    ["Alignment of GWeakRef"][::std::mem::align_of::<GWeakRef>() - 8usize];
    ["Offset of field: GWeakRef::priv_"][::std::mem::offset_of!(GWeakRef, priv_) - 0usize];
};
unsafe extern "C" {
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
unsafe extern "C" {
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
unsafe extern "C" {
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
unsafe extern "C" {
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
pub type GBinding = _GBinding;
#[doc = " GBindingTransformFunc:\n @binding: a #GBinding\n @from_value: the #GValue containing the value to transform\n @to_value: the #GValue in which to store the transformed value\n @user_data: data passed to the transform function\n\n A function to be called to transform @from_value to @to_value.\n\n If this is the @transform_to function of a binding, then @from_value\n is the @source_property on the @source object, and @to_value is the\n @target_property on the @target object. If this is the\n @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,\n then those roles are reversed.\n\n Returns: %TRUE if the transformation was successful, and %FALSE\n   otherwise\n\n Since: 2.26"]
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GBinding,
        from_value: *const GValue,
        to_value: *mut GValue,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GBindingFlags_G_BINDING_DEFAULT: GBindingFlags = 0;
pub const GBindingFlags_G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const GBindingFlags_G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;
#[doc = " GBindingFlags:\n @G_BINDING_DEFAULT: The default binding; if the source property\n   changes, the target property is updated with its value.\n @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the\n   property of the source or the property of the target changes,\n   the other is updated.\n @G_BINDING_SYNC_CREATE: Synchronize the values of the source and\n   target properties when creating the binding; the direction of\n   the synchronization is always from the source to the target.\n @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are\n   booleans, setting one to %TRUE will result in the other being\n   set to %FALSE and vice versa. This flag will only work for\n   boolean properties, and cannot be used when passing custom\n   transformation functions to g_object_bind_property_full().\n\n Flags to be passed to g_object_bind_property() or\n g_object_bind_property_full().\n\n This enumeration can be extended at later date.\n\n Since: 2.26"]
pub type GBindingFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_binding_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_binding_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
unsafe extern "C" {
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_dup_source(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_dup_target(binding: *mut GBinding) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_binding_unbind(binding: *mut GBinding);
}
unsafe extern "C" {
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
unsafe extern "C" {
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
unsafe extern "C" {
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBindingGroup {
    _unused: [u8; 0],
}
pub type GBindingGroup = _GBindingGroup;
unsafe extern "C" {
    pub fn g_binding_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_binding_group_new() -> *mut GBindingGroup;
}
unsafe extern "C" {
    pub fn g_binding_group_dup_source(self_: *mut GBindingGroup) -> gpointer;
}
unsafe extern "C" {
    pub fn g_binding_group_set_source(self_: *mut GBindingGroup, source: gpointer);
}
unsafe extern "C" {
    pub fn g_binding_group_bind(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    );
}
unsafe extern "C" {
    pub fn g_binding_group_bind_full(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        user_data_destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_binding_group_bind_with_closures(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    );
}
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
pub type GEnumClass = _GEnumClass;
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
pub type GFlagsClass = _GFlagsClass;
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
pub type GEnumValue = _GEnumValue;
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
pub type GFlagsValue = _GFlagsValue;
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GEnumClass"][::std::mem::size_of::<_GEnumClass>() - 32usize];
    ["Alignment of _GEnumClass"][::std::mem::align_of::<_GEnumClass>() - 8usize];
    ["Offset of field: _GEnumClass::g_type_class"]
        [::std::mem::offset_of!(_GEnumClass, g_type_class) - 0usize];
    ["Offset of field: _GEnumClass::minimum"]
        [::std::mem::offset_of!(_GEnumClass, minimum) - 8usize];
    ["Offset of field: _GEnumClass::maximum"]
        [::std::mem::offset_of!(_GEnumClass, maximum) - 12usize];
    ["Offset of field: _GEnumClass::n_values"]
        [::std::mem::offset_of!(_GEnumClass, n_values) - 16usize];
    ["Offset of field: _GEnumClass::values"][::std::mem::offset_of!(_GEnumClass, values) - 24usize];
};
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFlagsClass"][::std::mem::size_of::<_GFlagsClass>() - 24usize];
    ["Alignment of _GFlagsClass"][::std::mem::align_of::<_GFlagsClass>() - 8usize];
    ["Offset of field: _GFlagsClass::g_type_class"]
        [::std::mem::offset_of!(_GFlagsClass, g_type_class) - 0usize];
    ["Offset of field: _GFlagsClass::mask"][::std::mem::offset_of!(_GFlagsClass, mask) - 8usize];
    ["Offset of field: _GFlagsClass::n_values"]
        [::std::mem::offset_of!(_GFlagsClass, n_values) - 12usize];
    ["Offset of field: _GFlagsClass::values"]
        [::std::mem::offset_of!(_GFlagsClass, values) - 16usize];
};
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GEnumValue"][::std::mem::size_of::<_GEnumValue>() - 24usize];
    ["Alignment of _GEnumValue"][::std::mem::align_of::<_GEnumValue>() - 8usize];
    ["Offset of field: _GEnumValue::value"][::std::mem::offset_of!(_GEnumValue, value) - 0usize];
    ["Offset of field: _GEnumValue::value_name"]
        [::std::mem::offset_of!(_GEnumValue, value_name) - 8usize];
    ["Offset of field: _GEnumValue::value_nick"]
        [::std::mem::offset_of!(_GEnumValue, value_nick) - 16usize];
};
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFlagsValue"][::std::mem::size_of::<_GFlagsValue>() - 24usize];
    ["Alignment of _GFlagsValue"][::std::mem::align_of::<_GFlagsValue>() - 8usize];
    ["Offset of field: _GFlagsValue::value"][::std::mem::offset_of!(_GFlagsValue, value) - 0usize];
    ["Offset of field: _GFlagsValue::value_name"]
        [::std::mem::offset_of!(_GFlagsValue, value_name) - 8usize];
    ["Offset of field: _GFlagsValue::value_nick"]
        [::std::mem::offset_of!(_GFlagsValue, value_nick) - 16usize];
};
unsafe extern "C" {
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
unsafe extern "C" {
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const gchar,
    ) -> *mut GEnumValue;
}
unsafe extern "C" {
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const gchar,
    ) -> *mut GEnumValue;
}
unsafe extern "C" {
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint)
        -> *mut GFlagsValue;
}
unsafe extern "C" {
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const gchar,
    ) -> *mut GFlagsValue;
}
unsafe extern "C" {
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const gchar,
    ) -> *mut GFlagsValue;
}
unsafe extern "C" {
    pub fn g_enum_to_string(g_enum_type: GType, value: gint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_flags_to_string(flags_type: GType, value: guint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
unsafe extern "C" {
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
unsafe extern "C" {
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn g_enum_register_static(
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_flags_register_static(
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
}
unsafe extern "C" {
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
}
unsafe extern "C" {
    pub fn g_unicode_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unicode_break_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unicode_script_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_normalize_mode_get_type() -> GType;
}
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
pub type GParamSpecChar = _GParamSpecChar;
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
pub type GParamSpecUChar = _GParamSpecUChar;
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
pub type GParamSpecBoolean = _GParamSpecBoolean;
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
pub type GParamSpecInt = _GParamSpecInt;
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
pub type GParamSpecUInt = _GParamSpecUInt;
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
pub type GParamSpecLong = _GParamSpecLong;
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
pub type GParamSpecULong = _GParamSpecULong;
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
pub type GParamSpecInt64 = _GParamSpecInt64;
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
pub type GParamSpecUInt64 = _GParamSpecUInt64;
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
pub type GParamSpecUnichar = _GParamSpecUnichar;
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
pub type GParamSpecEnum = _GParamSpecEnum;
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
pub type GParamSpecFlags = _GParamSpecFlags;
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
pub type GParamSpecFloat = _GParamSpecFloat;
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
pub type GParamSpecDouble = _GParamSpecDouble;
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
pub type GParamSpecString = _GParamSpecString;
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
pub type GParamSpecParam = _GParamSpecParam;
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
pub type GParamSpecBoxed = _GParamSpecBoxed;
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
pub type GParamSpecPointer = _GParamSpecPointer;
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
pub type GParamSpecValueArray = _GParamSpecValueArray;
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
pub type GParamSpecObject = _GParamSpecObject;
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
pub type GParamSpecOverride = _GParamSpecOverride;
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
pub type GParamSpecGType = _GParamSpecGType;
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
pub type GParamSpecVariant = _GParamSpecVariant;
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecChar"][::std::mem::size_of::<_GParamSpecChar>() - 80usize];
    ["Alignment of _GParamSpecChar"][::std::mem::align_of::<_GParamSpecChar>() - 8usize];
    ["Offset of field: _GParamSpecChar::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecChar, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecChar::minimum"]
        [::std::mem::offset_of!(_GParamSpecChar, minimum) - 72usize];
    ["Offset of field: _GParamSpecChar::maximum"]
        [::std::mem::offset_of!(_GParamSpecChar, maximum) - 73usize];
    ["Offset of field: _GParamSpecChar::default_value"]
        [::std::mem::offset_of!(_GParamSpecChar, default_value) - 74usize];
};
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUChar"][::std::mem::size_of::<_GParamSpecUChar>() - 80usize];
    ["Alignment of _GParamSpecUChar"][::std::mem::align_of::<_GParamSpecUChar>() - 8usize];
    ["Offset of field: _GParamSpecUChar::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUChar, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUChar::minimum"]
        [::std::mem::offset_of!(_GParamSpecUChar, minimum) - 72usize];
    ["Offset of field: _GParamSpecUChar::maximum"]
        [::std::mem::offset_of!(_GParamSpecUChar, maximum) - 73usize];
    ["Offset of field: _GParamSpecUChar::default_value"]
        [::std::mem::offset_of!(_GParamSpecUChar, default_value) - 74usize];
};
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecBoolean"][::std::mem::size_of::<_GParamSpecBoolean>() - 80usize];
    ["Alignment of _GParamSpecBoolean"][::std::mem::align_of::<_GParamSpecBoolean>() - 8usize];
    ["Offset of field: _GParamSpecBoolean::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecBoolean, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecBoolean::default_value"]
        [::std::mem::offset_of!(_GParamSpecBoolean, default_value) - 72usize];
};
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecInt"][::std::mem::size_of::<_GParamSpecInt>() - 88usize];
    ["Alignment of _GParamSpecInt"][::std::mem::align_of::<_GParamSpecInt>() - 8usize];
    ["Offset of field: _GParamSpecInt::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecInt, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecInt::minimum"]
        [::std::mem::offset_of!(_GParamSpecInt, minimum) - 72usize];
    ["Offset of field: _GParamSpecInt::maximum"]
        [::std::mem::offset_of!(_GParamSpecInt, maximum) - 76usize];
    ["Offset of field: _GParamSpecInt::default_value"]
        [::std::mem::offset_of!(_GParamSpecInt, default_value) - 80usize];
};
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUInt"][::std::mem::size_of::<_GParamSpecUInt>() - 88usize];
    ["Alignment of _GParamSpecUInt"][::std::mem::align_of::<_GParamSpecUInt>() - 8usize];
    ["Offset of field: _GParamSpecUInt::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUInt, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUInt::minimum"]
        [::std::mem::offset_of!(_GParamSpecUInt, minimum) - 72usize];
    ["Offset of field: _GParamSpecUInt::maximum"]
        [::std::mem::offset_of!(_GParamSpecUInt, maximum) - 76usize];
    ["Offset of field: _GParamSpecUInt::default_value"]
        [::std::mem::offset_of!(_GParamSpecUInt, default_value) - 80usize];
};
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecLong"][::std::mem::size_of::<_GParamSpecLong>() - 96usize];
    ["Alignment of _GParamSpecLong"][::std::mem::align_of::<_GParamSpecLong>() - 8usize];
    ["Offset of field: _GParamSpecLong::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecLong, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecLong::minimum"]
        [::std::mem::offset_of!(_GParamSpecLong, minimum) - 72usize];
    ["Offset of field: _GParamSpecLong::maximum"]
        [::std::mem::offset_of!(_GParamSpecLong, maximum) - 80usize];
    ["Offset of field: _GParamSpecLong::default_value"]
        [::std::mem::offset_of!(_GParamSpecLong, default_value) - 88usize];
};
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecULong"][::std::mem::size_of::<_GParamSpecULong>() - 96usize];
    ["Alignment of _GParamSpecULong"][::std::mem::align_of::<_GParamSpecULong>() - 8usize];
    ["Offset of field: _GParamSpecULong::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecULong, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecULong::minimum"]
        [::std::mem::offset_of!(_GParamSpecULong, minimum) - 72usize];
    ["Offset of field: _GParamSpecULong::maximum"]
        [::std::mem::offset_of!(_GParamSpecULong, maximum) - 80usize];
    ["Offset of field: _GParamSpecULong::default_value"]
        [::std::mem::offset_of!(_GParamSpecULong, default_value) - 88usize];
};
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecInt64"][::std::mem::size_of::<_GParamSpecInt64>() - 96usize];
    ["Alignment of _GParamSpecInt64"][::std::mem::align_of::<_GParamSpecInt64>() - 8usize];
    ["Offset of field: _GParamSpecInt64::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecInt64, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecInt64::minimum"]
        [::std::mem::offset_of!(_GParamSpecInt64, minimum) - 72usize];
    ["Offset of field: _GParamSpecInt64::maximum"]
        [::std::mem::offset_of!(_GParamSpecInt64, maximum) - 80usize];
    ["Offset of field: _GParamSpecInt64::default_value"]
        [::std::mem::offset_of!(_GParamSpecInt64, default_value) - 88usize];
};
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUInt64"][::std::mem::size_of::<_GParamSpecUInt64>() - 96usize];
    ["Alignment of _GParamSpecUInt64"][::std::mem::align_of::<_GParamSpecUInt64>() - 8usize];
    ["Offset of field: _GParamSpecUInt64::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUInt64, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUInt64::minimum"]
        [::std::mem::offset_of!(_GParamSpecUInt64, minimum) - 72usize];
    ["Offset of field: _GParamSpecUInt64::maximum"]
        [::std::mem::offset_of!(_GParamSpecUInt64, maximum) - 80usize];
    ["Offset of field: _GParamSpecUInt64::default_value"]
        [::std::mem::offset_of!(_GParamSpecUInt64, default_value) - 88usize];
};
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecUnichar"][::std::mem::size_of::<_GParamSpecUnichar>() - 80usize];
    ["Alignment of _GParamSpecUnichar"][::std::mem::align_of::<_GParamSpecUnichar>() - 8usize];
    ["Offset of field: _GParamSpecUnichar::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecUnichar, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecUnichar::default_value"]
        [::std::mem::offset_of!(_GParamSpecUnichar, default_value) - 72usize];
};
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecEnum"][::std::mem::size_of::<_GParamSpecEnum>() - 88usize];
    ["Alignment of _GParamSpecEnum"][::std::mem::align_of::<_GParamSpecEnum>() - 8usize];
    ["Offset of field: _GParamSpecEnum::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecEnum, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecEnum::enum_class"]
        [::std::mem::offset_of!(_GParamSpecEnum, enum_class) - 72usize];
    ["Offset of field: _GParamSpecEnum::default_value"]
        [::std::mem::offset_of!(_GParamSpecEnum, default_value) - 80usize];
};
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecFlags"][::std::mem::size_of::<_GParamSpecFlags>() - 88usize];
    ["Alignment of _GParamSpecFlags"][::std::mem::align_of::<_GParamSpecFlags>() - 8usize];
    ["Offset of field: _GParamSpecFlags::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecFlags, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecFlags::flags_class"]
        [::std::mem::offset_of!(_GParamSpecFlags, flags_class) - 72usize];
    ["Offset of field: _GParamSpecFlags::default_value"]
        [::std::mem::offset_of!(_GParamSpecFlags, default_value) - 80usize];
};
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecFloat"][::std::mem::size_of::<_GParamSpecFloat>() - 88usize];
    ["Alignment of _GParamSpecFloat"][::std::mem::align_of::<_GParamSpecFloat>() - 8usize];
    ["Offset of field: _GParamSpecFloat::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecFloat, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecFloat::minimum"]
        [::std::mem::offset_of!(_GParamSpecFloat, minimum) - 72usize];
    ["Offset of field: _GParamSpecFloat::maximum"]
        [::std::mem::offset_of!(_GParamSpecFloat, maximum) - 76usize];
    ["Offset of field: _GParamSpecFloat::default_value"]
        [::std::mem::offset_of!(_GParamSpecFloat, default_value) - 80usize];
    ["Offset of field: _GParamSpecFloat::epsilon"]
        [::std::mem::offset_of!(_GParamSpecFloat, epsilon) - 84usize];
};
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecDouble"][::std::mem::size_of::<_GParamSpecDouble>() - 104usize];
    ["Alignment of _GParamSpecDouble"][::std::mem::align_of::<_GParamSpecDouble>() - 8usize];
    ["Offset of field: _GParamSpecDouble::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecDouble, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecDouble::minimum"]
        [::std::mem::offset_of!(_GParamSpecDouble, minimum) - 72usize];
    ["Offset of field: _GParamSpecDouble::maximum"]
        [::std::mem::offset_of!(_GParamSpecDouble, maximum) - 80usize];
    ["Offset of field: _GParamSpecDouble::default_value"]
        [::std::mem::offset_of!(_GParamSpecDouble, default_value) - 88usize];
    ["Offset of field: _GParamSpecDouble::epsilon"]
        [::std::mem::offset_of!(_GParamSpecDouble, epsilon) - 96usize];
};
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecString"][::std::mem::size_of::<_GParamSpecString>() - 104usize];
    ["Alignment of _GParamSpecString"][::std::mem::align_of::<_GParamSpecString>() - 8usize];
    ["Offset of field: _GParamSpecString::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecString, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecString::default_value"]
        [::std::mem::offset_of!(_GParamSpecString, default_value) - 72usize];
    ["Offset of field: _GParamSpecString::cset_first"]
        [::std::mem::offset_of!(_GParamSpecString, cset_first) - 80usize];
    ["Offset of field: _GParamSpecString::cset_nth"]
        [::std::mem::offset_of!(_GParamSpecString, cset_nth) - 88usize];
    ["Offset of field: _GParamSpecString::substitutor"]
        [::std::mem::offset_of!(_GParamSpecString, substitutor) - 96usize];
};
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn null_fold_if_empty_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_null_fold_if_empty_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn ensure_non_null_raw(this: *const Self) -> guint {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                1usize,
                1u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set_ensure_non_null_raw(this: *mut Self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                1usize,
                1u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        null_fold_if_empty: guint,
        ensure_non_null: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecParam"][::std::mem::size_of::<_GParamSpecParam>() - 72usize];
    ["Alignment of _GParamSpecParam"][::std::mem::align_of::<_GParamSpecParam>() - 8usize];
    ["Offset of field: _GParamSpecParam::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecParam, parent_instance) - 0usize];
};
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecBoxed"][::std::mem::size_of::<_GParamSpecBoxed>() - 72usize];
    ["Alignment of _GParamSpecBoxed"][::std::mem::align_of::<_GParamSpecBoxed>() - 8usize];
    ["Offset of field: _GParamSpecBoxed::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecBoxed, parent_instance) - 0usize];
};
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecPointer"][::std::mem::size_of::<_GParamSpecPointer>() - 72usize];
    ["Alignment of _GParamSpecPointer"][::std::mem::align_of::<_GParamSpecPointer>() - 8usize];
    ["Offset of field: _GParamSpecPointer::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecPointer, parent_instance) - 0usize];
};
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecValueArray"][::std::mem::size_of::<_GParamSpecValueArray>() - 88usize];
    ["Alignment of _GParamSpecValueArray"]
        [::std::mem::align_of::<_GParamSpecValueArray>() - 8usize];
    ["Offset of field: _GParamSpecValueArray::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecValueArray, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecValueArray::element_spec"]
        [::std::mem::offset_of!(_GParamSpecValueArray, element_spec) - 72usize];
    ["Offset of field: _GParamSpecValueArray::fixed_n_elements"]
        [::std::mem::offset_of!(_GParamSpecValueArray, fixed_n_elements) - 80usize];
};
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecObject"][::std::mem::size_of::<_GParamSpecObject>() - 72usize];
    ["Alignment of _GParamSpecObject"][::std::mem::align_of::<_GParamSpecObject>() - 8usize];
    ["Offset of field: _GParamSpecObject::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecObject, parent_instance) - 0usize];
};
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecOverride"][::std::mem::size_of::<_GParamSpecOverride>() - 80usize];
    ["Alignment of _GParamSpecOverride"][::std::mem::align_of::<_GParamSpecOverride>() - 8usize];
    ["Offset of field: _GParamSpecOverride::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecOverride, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecOverride::overridden"]
        [::std::mem::offset_of!(_GParamSpecOverride, overridden) - 72usize];
};
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecGType"][::std::mem::size_of::<_GParamSpecGType>() - 80usize];
    ["Alignment of _GParamSpecGType"][::std::mem::align_of::<_GParamSpecGType>() - 8usize];
    ["Offset of field: _GParamSpecGType::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecGType, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecGType::is_a_type"]
        [::std::mem::offset_of!(_GParamSpecGType, is_a_type) - 72usize];
};
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GParamSpecVariant"][::std::mem::size_of::<_GParamSpecVariant>() - 120usize];
    ["Alignment of _GParamSpecVariant"][::std::mem::align_of::<_GParamSpecVariant>() - 8usize];
    ["Offset of field: _GParamSpecVariant::parent_instance"]
        [::std::mem::offset_of!(_GParamSpecVariant, parent_instance) - 0usize];
    ["Offset of field: _GParamSpecVariant::type_"]
        [::std::mem::offset_of!(_GParamSpecVariant, type_) - 72usize];
    ["Offset of field: _GParamSpecVariant::default_value"]
        [::std::mem::offset_of!(_GParamSpecVariant, default_value) - 80usize];
    ["Offset of field: _GParamSpecVariant::padding"]
        [::std::mem::offset_of!(_GParamSpecVariant, padding) - 88usize];
};
unsafe extern "C" {
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_pointer(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_override(
        name: *const gchar,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
unsafe extern "C" {
    pub static mut g_param_spec_types: *mut GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalGroup {
    _unused: [u8; 0],
}
pub type GSignalGroup = _GSignalGroup;
unsafe extern "C" {
    pub fn g_signal_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_signal_group_new(target_type: GType) -> *mut GSignalGroup;
}
unsafe extern "C" {
    pub fn g_signal_group_set_target(self_: *mut GSignalGroup, target: gpointer);
}
unsafe extern "C" {
    pub fn g_signal_group_dup_target(self_: *mut GSignalGroup) -> gpointer;
}
unsafe extern "C" {
    pub fn g_signal_group_block(self_: *mut GSignalGroup);
}
unsafe extern "C" {
    pub fn g_signal_group_unblock(self_: *mut GSignalGroup);
}
unsafe extern "C" {
    pub fn g_signal_group_connect_closure(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_object(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        object: gpointer,
        flags: GConnectFlags,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_data(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        notify: GClosureNotify,
        flags: GConnectFlags,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_after(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_signal_group_connect_swapped(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
unsafe extern "C" {
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
pub type GTypeModule = _GTypeModule;
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
pub type GTypeModuleClass = _GTypeModuleClass;
pub type GTypeModule_autoptr = *mut GTypeModule;
pub type GTypeModule_listautoptr = *mut GList;
pub type GTypeModule_slistautoptr = *mut GSList;
pub type GTypeModule_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeModule"][::std::mem::size_of::<_GTypeModule>() - 56usize];
    ["Alignment of _GTypeModule"][::std::mem::align_of::<_GTypeModule>() - 8usize];
    ["Offset of field: _GTypeModule::parent_instance"]
        [::std::mem::offset_of!(_GTypeModule, parent_instance) - 0usize];
    ["Offset of field: _GTypeModule::use_count"]
        [::std::mem::offset_of!(_GTypeModule, use_count) - 24usize];
    ["Offset of field: _GTypeModule::type_infos"]
        [::std::mem::offset_of!(_GTypeModule, type_infos) - 32usize];
    ["Offset of field: _GTypeModule::interface_infos"]
        [::std::mem::offset_of!(_GTypeModule, interface_infos) - 40usize];
    ["Offset of field: _GTypeModule::name"][::std::mem::offset_of!(_GTypeModule, name) - 48usize];
};
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypeModuleClass"][::std::mem::size_of::<_GTypeModuleClass>() - 184usize];
    ["Alignment of _GTypeModuleClass"][::std::mem::align_of::<_GTypeModuleClass>() - 8usize];
    ["Offset of field: _GTypeModuleClass::parent_class"]
        [::std::mem::offset_of!(_GTypeModuleClass, parent_class) - 0usize];
    ["Offset of field: _GTypeModuleClass::load"]
        [::std::mem::offset_of!(_GTypeModuleClass, load) - 136usize];
    ["Offset of field: _GTypeModuleClass::unload"]
        [::std::mem::offset_of!(_GTypeModuleClass, unload) - 144usize];
    ["Offset of field: _GTypeModuleClass::reserved1"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved1) - 152usize];
    ["Offset of field: _GTypeModuleClass::reserved2"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved2) - 160usize];
    ["Offset of field: _GTypeModuleClass::reserved3"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved3) - 168usize];
    ["Offset of field: _GTypeModuleClass::reserved4"]
        [::std::mem::offset_of!(_GTypeModuleClass, reserved4) - 176usize];
};
unsafe extern "C" {
    pub fn g_type_module_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
unsafe extern "C" {
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
unsafe extern "C" {
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
unsafe extern "C" {
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
unsafe extern "C" {
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
#[doc = " GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
pub type GTypePluginClass = _GTypePluginClass;
#[doc = " GTypePluginUse:\n @plugin: the #GTypePlugin whose use count should be increased\n\n The type of the @use_plugin function of #GTypePluginClass, which gets called\n to increase the use count of @plugin."]
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginUnuse:\n @plugin: the #GTypePlugin whose use count should be decreased\n\n The type of the @unuse_plugin function of #GTypePluginClass."]
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginCompleteTypeInfo:\n @plugin: the #GTypePlugin\n @g_type: the #GType whose info is completed\n @info: the #GTypeInfo struct to fill in\n @value_table: the #GTypeValueTable to fill in\n\n The type of the @complete_type_info function of #GTypePluginClass."]
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    ),
>;
#[doc = " GTypePluginCompleteInterfaceInfo:\n @plugin: the #GTypePlugin\n @instance_type: the #GType of an instantiatable type to which the interface\n  is added\n @interface_type: the #GType of the interface whose info is completed\n @info: the #GInterfaceInfo to fill in\n\n The type of the @complete_interface_info function of #GTypePluginClass."]
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    ),
>;
#[doc = " GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTypePluginClass"][::std::mem::size_of::<_GTypePluginClass>() - 48usize];
    ["Alignment of _GTypePluginClass"][::std::mem::align_of::<_GTypePluginClass>() - 8usize];
    ["Offset of field: _GTypePluginClass::base_iface"]
        [::std::mem::offset_of!(_GTypePluginClass, base_iface) - 0usize];
    ["Offset of field: _GTypePluginClass::use_plugin"]
        [::std::mem::offset_of!(_GTypePluginClass, use_plugin) - 16usize];
    ["Offset of field: _GTypePluginClass::unuse_plugin"]
        [::std::mem::offset_of!(_GTypePluginClass, unuse_plugin) - 24usize];
    ["Offset of field: _GTypePluginClass::complete_type_info"]
        [::std::mem::offset_of!(_GTypePluginClass, complete_type_info) - 32usize];
    ["Offset of field: _GTypePluginClass::complete_interface_info"]
        [::std::mem::offset_of!(_GTypePluginClass, complete_interface_info) - 40usize];
};
unsafe extern "C" {
    pub fn g_type_plugin_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
unsafe extern "C" {
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
unsafe extern "C" {
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
unsafe extern "C" {
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
pub type GValueArray = _GValueArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GValueArray"][::std::mem::size_of::<_GValueArray>() - 24usize];
    ["Alignment of _GValueArray"][::std::mem::align_of::<_GValueArray>() - 8usize];
    ["Offset of field: _GValueArray::n_values"]
        [::std::mem::offset_of!(_GValueArray, n_values) - 0usize];
    ["Offset of field: _GValueArray::values"]
        [::std::mem::offset_of!(_GValueArray, values) - 8usize];
    ["Offset of field: _GValueArray::n_prealloced"]
        [::std::mem::offset_of!(_GValueArray, n_prealloced) - 16usize];
};
unsafe extern "C" {
    pub fn g_value_array_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
unsafe extern "C" {
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
unsafe extern "C" {
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: guint,
        value: *const GValue,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: GCompareFunc,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
unsafe extern "C" {
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
unsafe extern "C" {
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
unsafe extern "C" {
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
unsafe extern "C" {
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
unsafe extern "C" {
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
unsafe extern "C" {
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
unsafe extern "C" {
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
unsafe extern "C" {
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
unsafe extern "C" {
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
unsafe extern "C" {
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
unsafe extern "C" {
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
unsafe extern "C" {
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
unsafe extern "C" {
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
unsafe extern "C" {
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
unsafe extern "C" {
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
unsafe extern "C" {
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
unsafe extern "C" {
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
unsafe extern "C" {
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
unsafe extern "C" {
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
unsafe extern "C" {
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
unsafe extern "C" {
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
unsafe extern "C" {
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
unsafe extern "C" {
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
unsafe extern "C" {
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
unsafe extern "C" {
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
unsafe extern "C" {
    pub fn g_value_set_interned_string(value: *mut GValue, v_string: *const gchar);
}
unsafe extern "C" {
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_steal_string(value: *mut GValue) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
unsafe extern "C" {
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
unsafe extern "C" {
    pub fn g_gtype_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
unsafe extern "C" {
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
unsafe extern "C" {
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
unsafe extern "C" {
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
unsafe extern "C" {
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
#[doc = " gchararray:\n\n A C representable type name for %G_TYPE_STRING."]
pub type gchararray = *mut gchar;
pub type GClosure_autoptr = *mut GClosure;
pub type GClosure_listautoptr = *mut GList;
pub type GClosure_slistautoptr = *mut GSList;
pub type GClosure_queueautoptr = *mut GQueue;
pub type GEnumClass_autoptr = *mut GEnumClass;
pub type GEnumClass_listautoptr = *mut GList;
pub type GEnumClass_slistautoptr = *mut GSList;
pub type GEnumClass_queueautoptr = *mut GQueue;
pub type GFlagsClass_autoptr = *mut GFlagsClass;
pub type GFlagsClass_listautoptr = *mut GList;
pub type GFlagsClass_slistautoptr = *mut GSList;
pub type GFlagsClass_queueautoptr = *mut GQueue;
pub type GObject_autoptr = *mut GObject;
pub type GObject_listautoptr = *mut GList;
pub type GObject_slistautoptr = *mut GSList;
pub type GObject_queueautoptr = *mut GQueue;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type GInitiallyUnowned_listautoptr = *mut GList;
pub type GInitiallyUnowned_slistautoptr = *mut GSList;
pub type GInitiallyUnowned_queueautoptr = *mut GQueue;
pub type GParamSpec_autoptr = *mut GParamSpec;
pub type GParamSpec_listautoptr = *mut GList;
pub type GParamSpec_slistautoptr = *mut GSList;
pub type GParamSpec_queueautoptr = *mut GQueue;
pub type GTypeClass_autoptr = *mut GTypeClass;
pub type GTypeClass_listautoptr = *mut GList;
pub type GTypeClass_slistautoptr = *mut GSList;
pub type GTypeClass_queueautoptr = *mut GQueue;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NONE: GAppInfoCreateFlags = 0;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NEEDS_TERMINAL: GAppInfoCreateFlags = 1;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_URIS: GAppInfoCreateFlags = 2;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: GAppInfoCreateFlags =
    4;
#[doc = " GAppInfoCreateFlags:\n @G_APP_INFO_CREATE_NONE: No flags.\n @G_APP_INFO_CREATE_NEEDS_TERMINAL: Application opens in a terminal window.\n @G_APP_INFO_CREATE_SUPPORTS_URIS: Application supports URI arguments.\n @G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: Application supports startup notification. Since 2.26\n\n Flags used when creating a #GAppInfo."]
pub type GAppInfoCreateFlags = ::std::os::raw::c_uint;
pub const GConverterFlags_G_CONVERTER_NO_FLAGS: GConverterFlags = 0;
pub const GConverterFlags_G_CONVERTER_INPUT_AT_END: GConverterFlags = 1;
pub const GConverterFlags_G_CONVERTER_FLUSH: GConverterFlags = 2;
#[doc = " GConverterFlags:\n @G_CONVERTER_NO_FLAGS: No flags.\n @G_CONVERTER_INPUT_AT_END: At end of input data\n @G_CONVERTER_FLUSH: Flush data\n\n Flags used when calling a g_converter_convert().\n\n Since: 2.24"]
pub type GConverterFlags = ::std::os::raw::c_uint;
pub const GConverterResult_G_CONVERTER_ERROR: GConverterResult = 0;
pub const GConverterResult_G_CONVERTER_CONVERTED: GConverterResult = 1;
pub const GConverterResult_G_CONVERTER_FINISHED: GConverterResult = 2;
pub const GConverterResult_G_CONVERTER_FLUSHED: GConverterResult = 3;
#[doc = " GConverterResult:\n @G_CONVERTER_ERROR: There was an error during conversion.\n @G_CONVERTER_CONVERTED: Some data was consumed or produced\n @G_CONVERTER_FINISHED: The conversion is finished\n @G_CONVERTER_FLUSHED: Flushing is finished\n\n Results returned from g_converter_convert().\n\n Since: 2.24"]
pub type GConverterResult = ::std::os::raw::c_uint;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: GDataStreamByteOrder = 0;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: GDataStreamByteOrder = 1;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: GDataStreamByteOrder = 2;
#[doc = " GDataStreamByteOrder:\n @G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: Selects Big Endian byte order.\n @G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: Selects Little Endian byte order.\n @G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: Selects endianness based on host machine's architecture.\n\n #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources\n across various machine architectures.\n"]
pub type GDataStreamByteOrder = ::std::os::raw::c_uint;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_LF: GDataStreamNewlineType = 0;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR: GDataStreamNewlineType = 1;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR_LF: GDataStreamNewlineType = 2;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_ANY: GDataStreamNewlineType = 3;
#[doc = " GDataStreamNewlineType:\n @G_DATA_STREAM_NEWLINE_TYPE_LF: Selects \"LF\" line endings, common on most modern UNIX platforms.\n @G_DATA_STREAM_NEWLINE_TYPE_CR: Selects \"CR\" line endings.\n @G_DATA_STREAM_NEWLINE_TYPE_CR_LF: Selects \"CR, LF\" line ending, common on Microsoft Windows.\n @G_DATA_STREAM_NEWLINE_TYPE_ANY: Automatically try to handle any line ending type.\n\n #GDataStreamNewlineType is used when checking for or setting the line endings for a given file."]
pub type GDataStreamNewlineType = ::std::os::raw::c_uint;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INVALID: GFileAttributeType = 0;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRING: GFileAttributeType = 1;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: GFileAttributeType = 2;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BOOLEAN: GFileAttributeType = 3;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT32: GFileAttributeType = 4;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT32: GFileAttributeType = 5;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT64: GFileAttributeType = 6;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT64: GFileAttributeType = 7;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_OBJECT: GFileAttributeType = 8;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRINGV: GFileAttributeType = 9;
#[doc = " GFileAttributeType:\n @G_FILE_ATTRIBUTE_TYPE_INVALID: indicates an invalid or uninitialized type.\n @G_FILE_ATTRIBUTE_TYPE_STRING: a null terminated UTF8 string.\n @G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: a zero terminated string of non-zero bytes.\n @G_FILE_ATTRIBUTE_TYPE_BOOLEAN: a boolean value.\n @G_FILE_ATTRIBUTE_TYPE_UINT32: an unsigned 4-byte/32-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_INT32: a signed 4-byte/32-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_UINT64: an unsigned 8-byte/64-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_INT64: a signed 8-byte/64-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_OBJECT: a #GObject.\n @G_FILE_ATTRIBUTE_TYPE_STRINGV: a %NULL terminated char **. Since 2.22\n\n The data types for file attributes."]
pub type GFileAttributeType = ::std::os::raw::c_uint;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_NONE: GFileAttributeInfoFlags = 0;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: GFileAttributeInfoFlags = 1;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: GFileAttributeInfoFlags =
    2;
#[doc = " GFileAttributeInfoFlags:\n @G_FILE_ATTRIBUTE_INFO_NONE: no flags set.\n @G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: copy the attribute values when the file is copied.\n @G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: copy the attribute values when the file is moved.\n\n Flags specifying the behaviour of an attribute."]
pub type GFileAttributeInfoFlags = ::std::os::raw::c_uint;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_UNSET: GFileAttributeStatus = 0;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_SET: GFileAttributeStatus = 1;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: GFileAttributeStatus = 2;
#[doc = " GFileAttributeStatus:\n @G_FILE_ATTRIBUTE_STATUS_UNSET: Attribute value is unset (empty).\n @G_FILE_ATTRIBUTE_STATUS_SET: Attribute value is set.\n @G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: Indicates an error in setting the value.\n\n Used by g_file_set_attributes_from_info() when setting file attributes."]
pub type GFileAttributeStatus = ::std::os::raw::c_uint;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NONE: GFileQueryInfoFlags = 0;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: GFileQueryInfoFlags = 1;
#[doc = " GFileQueryInfoFlags:\n @G_FILE_QUERY_INFO_NONE: No flags set.\n @G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: Don't follow symlinks.\n\n Flags used when querying a #GFileInfo."]
pub type GFileQueryInfoFlags = ::std::os::raw::c_uint;
pub const GFileCreateFlags_G_FILE_CREATE_NONE: GFileCreateFlags = 0;
pub const GFileCreateFlags_G_FILE_CREATE_PRIVATE: GFileCreateFlags = 1;
pub const GFileCreateFlags_G_FILE_CREATE_REPLACE_DESTINATION: GFileCreateFlags = 2;
#[doc = " GFileCreateFlags:\n @G_FILE_CREATE_NONE: No flags set.\n @G_FILE_CREATE_PRIVATE: Create a file that can only be\n    accessed by the current user.\n @G_FILE_CREATE_REPLACE_DESTINATION: Replace the destination\n    as if it didn't exist before. Don't try to keep any old\n    permissions, replace instead of following links. This\n    is generally useful if you're doing a \"copy over\"\n    rather than a \"save new version of\" replace operation.\n    You can think of it as \"unlink destination\" before\n    writing to it, although the implementation may not\n    be exactly like that. This flag can only be used with\n    g_file_replace() and its variants, including g_file_replace_contents().\n    Since 2.20\n\n Flags used when an operation may create a file."]
pub type GFileCreateFlags = ::std::os::raw::c_uint;
pub const GFileMeasureFlags_G_FILE_MEASURE_NONE: GFileMeasureFlags = 0;
pub const GFileMeasureFlags_G_FILE_MEASURE_REPORT_ANY_ERROR: GFileMeasureFlags = 2;
pub const GFileMeasureFlags_G_FILE_MEASURE_APPARENT_SIZE: GFileMeasureFlags = 4;
pub const GFileMeasureFlags_G_FILE_MEASURE_NO_XDEV: GFileMeasureFlags = 8;
#[doc = " GFileMeasureFlags:\n @G_FILE_MEASURE_NONE: No flags set.\n @G_FILE_MEASURE_REPORT_ANY_ERROR: Report any error encountered\n   while traversing the directory tree.  Normally errors are only\n   reported for the toplevel file.\n @G_FILE_MEASURE_APPARENT_SIZE: Tally usage based on apparent file\n   sizes.  Normally, the block-size is used, if available, as this is a\n   more accurate representation of disk space used.\n   Compare with `du --apparent-size`.\n   Since GLib 2.78. and similarly to `du` since GNU Coreutils 9.2, this will\n   ignore the sizes of file types other than regular files and links, as the\n   sizes of other file types are not specified in a standard way.\n @G_FILE_MEASURE_NO_XDEV: Do not cross mount point boundaries.\n   Compare with `du -x`.\n\n Flags that can be used with g_file_measure_disk_usage().\n\n Since: 2.38"]
pub type GFileMeasureFlags = ::std::os::raw::c_uint;
pub const GMountMountFlags_G_MOUNT_MOUNT_NONE: GMountMountFlags = 0;
#[doc = " GMountMountFlags:\n @G_MOUNT_MOUNT_NONE: No flags set.\n\n Flags used when mounting a mount."]
pub type GMountMountFlags = ::std::os::raw::c_uint;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_NONE: GMountUnmountFlags = 0;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_FORCE: GMountUnmountFlags = 1;
#[doc = " GMountUnmountFlags:\n @G_MOUNT_UNMOUNT_NONE: No flags set.\n @G_MOUNT_UNMOUNT_FORCE: Unmount even if there are outstanding\n  file operations on the mount.\n\n Flags used when an unmounting a mount."]
pub type GMountUnmountFlags = ::std::os::raw::c_uint;
pub const GDriveStartFlags_G_DRIVE_START_NONE: GDriveStartFlags = 0;
#[doc = " GDriveStartFlags:\n @G_DRIVE_START_NONE: No flags set.\n\n Flags used when starting a drive.\n\n Since: 2.22"]
pub type GDriveStartFlags = ::std::os::raw::c_uint;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_UNKNOWN: GDriveStartStopType = 0;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_SHUTDOWN: GDriveStartStopType = 1;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_NETWORK: GDriveStartStopType = 2;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_MULTIDISK: GDriveStartStopType = 3;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_PASSWORD: GDriveStartStopType = 4;
#[doc = " GDriveStartStopType:\n @G_DRIVE_START_STOP_TYPE_UNKNOWN: Unknown or drive doesn't support\n    start/stop.\n @G_DRIVE_START_STOP_TYPE_SHUTDOWN: The stop method will physically\n    shut down the drive and e.g. power down the port the drive is\n    attached to.\n @G_DRIVE_START_STOP_TYPE_NETWORK: The start/stop methods are used\n    for connecting/disconnect to the drive over the network.\n @G_DRIVE_START_STOP_TYPE_MULTIDISK: The start/stop methods will\n    assemble/disassemble a virtual drive from several physical\n    drives.\n @G_DRIVE_START_STOP_TYPE_PASSWORD: The start/stop methods will\n    unlock/lock the disk (for example using the ATA <quote>SECURITY\n    UNLOCK DEVICE</quote> command)\n\n Enumeration describing how a drive can be started/stopped.\n\n Since: 2.22"]
pub type GDriveStartStopType = ::std::os::raw::c_uint;
pub const GFileCopyFlags_G_FILE_COPY_NONE: GFileCopyFlags = 0;
pub const GFileCopyFlags_G_FILE_COPY_OVERWRITE: GFileCopyFlags = 1;
pub const GFileCopyFlags_G_FILE_COPY_BACKUP: GFileCopyFlags = 2;
pub const GFileCopyFlags_G_FILE_COPY_NOFOLLOW_SYMLINKS: GFileCopyFlags = 4;
pub const GFileCopyFlags_G_FILE_COPY_ALL_METADATA: GFileCopyFlags = 8;
pub const GFileCopyFlags_G_FILE_COPY_NO_FALLBACK_FOR_MOVE: GFileCopyFlags = 16;
pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_PERMS: GFileCopyFlags = 32;
pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_MODIFIED_TIME: GFileCopyFlags = 64;
#[doc = " GFileCopyFlags:\n @G_FILE_COPY_NONE: No flags set.\n @G_FILE_COPY_OVERWRITE: Overwrite any existing files\n @G_FILE_COPY_BACKUP: Make a backup of any existing files.\n @G_FILE_COPY_NOFOLLOW_SYMLINKS: Don't follow symlinks.\n @G_FILE_COPY_ALL_METADATA: Copy all file metadata instead of just default set used for copy (see #GFileInfo).\n @G_FILE_COPY_NO_FALLBACK_FOR_MOVE: Don't use copy and delete fallback if native move not supported.\n @G_FILE_COPY_TARGET_DEFAULT_PERMS: Leaves target file with default perms, instead of setting the source file perms.\n @G_FILE_COPY_TARGET_DEFAULT_MODIFIED_TIME: Use default modification\n     timestamps instead of copying them from the source file. Since 2.80\n\n Flags used when copying or moving files."]
pub type GFileCopyFlags = ::std::os::raw::c_uint;
pub const GFileMonitorFlags_G_FILE_MONITOR_NONE: GFileMonitorFlags = 0;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOUNTS: GFileMonitorFlags = 1;
pub const GFileMonitorFlags_G_FILE_MONITOR_SEND_MOVED: GFileMonitorFlags = 2;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_HARD_LINKS: GFileMonitorFlags = 4;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOVES: GFileMonitorFlags = 8;
#[doc = " GFileMonitorFlags:\n @G_FILE_MONITOR_NONE: No flags set.\n @G_FILE_MONITOR_WATCH_MOUNTS: Watch for mount events.\n @G_FILE_MONITOR_SEND_MOVED: Pair DELETED and CREATED events caused\n   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED\n   event instead (NB: not supported on all backends; the default\n   behaviour -without specifying this flag- is to send single DELETED\n   and CREATED events).  Deprecated since 2.46: use\n   %G_FILE_MONITOR_WATCH_MOVES instead.\n @G_FILE_MONITOR_WATCH_HARD_LINKS: Watch for changes to the file made\n   via another hard link. Since 2.36.\n @G_FILE_MONITOR_WATCH_MOVES: Watch for rename operations on a\n   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,\n   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT\n   events to be emitted when possible.  Since: 2.46.\n\n Flags used to set what a #GFileMonitor will watch for."]
pub type GFileMonitorFlags = ::std::os::raw::c_uint;
pub const GFileType_G_FILE_TYPE_UNKNOWN: GFileType = 0;
pub const GFileType_G_FILE_TYPE_REGULAR: GFileType = 1;
pub const GFileType_G_FILE_TYPE_DIRECTORY: GFileType = 2;
pub const GFileType_G_FILE_TYPE_SYMBOLIC_LINK: GFileType = 3;
pub const GFileType_G_FILE_TYPE_SPECIAL: GFileType = 4;
pub const GFileType_G_FILE_TYPE_SHORTCUT: GFileType = 5;
pub const GFileType_G_FILE_TYPE_MOUNTABLE: GFileType = 6;
#[doc = " GFileType:\n @G_FILE_TYPE_UNKNOWN: File's type is unknown.\n @G_FILE_TYPE_REGULAR: File handle represents a regular file.\n @G_FILE_TYPE_DIRECTORY: File handle represents a directory.\n @G_FILE_TYPE_SYMBOLIC_LINK: File handle represents a symbolic link\n    (Unix systems).\n @G_FILE_TYPE_SPECIAL: File is a \"special\" file, such as a socket, fifo,\n    block device, or character device.\n @G_FILE_TYPE_SHORTCUT: File is a shortcut (Windows systems).\n @G_FILE_TYPE_MOUNTABLE: File is a mountable location.\n\n Indicates the file's on-disk type.\n\n On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;\n use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine\n whether a file is a symlink or not. This is due to the fact that NTFS does\n not have a single filesystem object type for symbolic links - it has\n files that symlink to files, and directories that symlink to directories.\n #GFileType enumeration cannot precisely represent this important distinction,\n which is why all Windows symlinks will continue to be reported as\n %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY."]
pub type GFileType = ::std::os::raw::c_uint;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: GFilesystemPreviewType = 0;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: GFilesystemPreviewType = 1;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_NEVER: GFilesystemPreviewType = 2;
#[doc = " GFilesystemPreviewType:\n @G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: Only preview files if user has explicitly requested it.\n @G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: Preview files if user has requested preview of \"local\" files.\n @G_FILESYSTEM_PREVIEW_TYPE_NEVER: Never preview files.\n\n Indicates a hint from the file system whether files should be\n previewed in a file manager. Returned as the value of the key\n %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW."]
pub type GFilesystemPreviewType = ::std::os::raw::c_uint;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGED: GFileMonitorEvent = 0;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: GFileMonitorEvent = 1;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_DELETED: GFileMonitorEvent = 2;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CREATED: GFileMonitorEvent = 3;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: GFileMonitorEvent = 4;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_PRE_UNMOUNT: GFileMonitorEvent = 5;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_UNMOUNTED: GFileMonitorEvent = 6;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED: GFileMonitorEvent = 7;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_RENAMED: GFileMonitorEvent = 8;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_IN: GFileMonitorEvent = 9;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_OUT: GFileMonitorEvent = 10;
#[doc = " GFileMonitorEvent:\n @G_FILE_MONITOR_EVENT_CHANGED: a file changed.\n @G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: a hint that this was probably the last change in a set of changes.\n @G_FILE_MONITOR_EVENT_DELETED: a file was deleted.\n @G_FILE_MONITOR_EVENT_CREATED: a file was created.\n @G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: a file attribute was changed.\n @G_FILE_MONITOR_EVENT_PRE_UNMOUNT: the file location will soon be unmounted.\n @G_FILE_MONITOR_EVENT_UNMOUNTED: the file location was unmounted.\n @G_FILE_MONITOR_EVENT_MOVED: the file was moved -- only sent if the\n   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set\n @G_FILE_MONITOR_EVENT_RENAMED: the file was renamed within the\n   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES\n   flag is set.  Since: 2.46.\n @G_FILE_MONITOR_EVENT_MOVED_IN: the file was moved into the\n   monitored directory from another location -- only sent if the\n   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.\n @G_FILE_MONITOR_EVENT_MOVED_OUT: the file was moved out of the\n   monitored directory to another location -- only sent if the\n   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46\n\n Specifies what type of event a monitor event is."]
pub type GFileMonitorEvent = ::std::os::raw::c_uint;
pub const GIOErrorEnum_G_IO_ERROR_FAILED: GIOErrorEnum = 0;
pub const GIOErrorEnum_G_IO_ERROR_NOT_FOUND: GIOErrorEnum = 1;
pub const GIOErrorEnum_G_IO_ERROR_EXISTS: GIOErrorEnum = 2;
pub const GIOErrorEnum_G_IO_ERROR_IS_DIRECTORY: GIOErrorEnum = 3;
pub const GIOErrorEnum_G_IO_ERROR_NOT_DIRECTORY: GIOErrorEnum = 4;
pub const GIOErrorEnum_G_IO_ERROR_NOT_EMPTY: GIOErrorEnum = 5;
pub const GIOErrorEnum_G_IO_ERROR_NOT_REGULAR_FILE: GIOErrorEnum = 6;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SYMBOLIC_LINK: GIOErrorEnum = 7;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTABLE_FILE: GIOErrorEnum = 8;
pub const GIOErrorEnum_G_IO_ERROR_FILENAME_TOO_LONG: GIOErrorEnum = 9;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_FILENAME: GIOErrorEnum = 10;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_LINKS: GIOErrorEnum = 11;
pub const GIOErrorEnum_G_IO_ERROR_NO_SPACE: GIOErrorEnum = 12;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_ARGUMENT: GIOErrorEnum = 13;
pub const GIOErrorEnum_G_IO_ERROR_PERMISSION_DENIED: GIOErrorEnum = 14;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SUPPORTED: GIOErrorEnum = 15;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTED: GIOErrorEnum = 16;
pub const GIOErrorEnum_G_IO_ERROR_ALREADY_MOUNTED: GIOErrorEnum = 17;
pub const GIOErrorEnum_G_IO_ERROR_CLOSED: GIOErrorEnum = 18;
pub const GIOErrorEnum_G_IO_ERROR_CANCELLED: GIOErrorEnum = 19;
pub const GIOErrorEnum_G_IO_ERROR_PENDING: GIOErrorEnum = 20;
pub const GIOErrorEnum_G_IO_ERROR_READ_ONLY: GIOErrorEnum = 21;
pub const GIOErrorEnum_G_IO_ERROR_CANT_CREATE_BACKUP: GIOErrorEnum = 22;
pub const GIOErrorEnum_G_IO_ERROR_WRONG_ETAG: GIOErrorEnum = 23;
pub const GIOErrorEnum_G_IO_ERROR_TIMED_OUT: GIOErrorEnum = 24;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_RECURSE: GIOErrorEnum = 25;
pub const GIOErrorEnum_G_IO_ERROR_BUSY: GIOErrorEnum = 26;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_BLOCK: GIOErrorEnum = 27;
pub const GIOErrorEnum_G_IO_ERROR_HOST_NOT_FOUND: GIOErrorEnum = 28;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_MERGE: GIOErrorEnum = 29;
pub const GIOErrorEnum_G_IO_ERROR_FAILED_HANDLED: GIOErrorEnum = 30;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_OPEN_FILES: GIOErrorEnum = 31;
pub const GIOErrorEnum_G_IO_ERROR_NOT_INITIALIZED: GIOErrorEnum = 32;
pub const GIOErrorEnum_G_IO_ERROR_ADDRESS_IN_USE: GIOErrorEnum = 33;
pub const GIOErrorEnum_G_IO_ERROR_PARTIAL_INPUT: GIOErrorEnum = 34;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_DATA: GIOErrorEnum = 35;
pub const GIOErrorEnum_G_IO_ERROR_DBUS_ERROR: GIOErrorEnum = 36;
pub const GIOErrorEnum_G_IO_ERROR_HOST_UNREACHABLE: GIOErrorEnum = 37;
pub const GIOErrorEnum_G_IO_ERROR_NETWORK_UNREACHABLE: GIOErrorEnum = 38;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_REFUSED: GIOErrorEnum = 39;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_FAILED: GIOErrorEnum = 40;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_AUTH_FAILED: GIOErrorEnum = 41;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NEED_AUTH: GIOErrorEnum = 42;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NOT_ALLOWED: GIOErrorEnum = 43;
pub const GIOErrorEnum_G_IO_ERROR_BROKEN_PIPE: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_CLOSED: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_NOT_CONNECTED: GIOErrorEnum = 45;
pub const GIOErrorEnum_G_IO_ERROR_MESSAGE_TOO_LARGE: GIOErrorEnum = 46;
pub const GIOErrorEnum_G_IO_ERROR_NO_SUCH_DEVICE: GIOErrorEnum = 47;
pub const GIOErrorEnum_G_IO_ERROR_DESTINATION_UNSET: GIOErrorEnum = 48;
#[doc = " GIOErrorEnum:\n @G_IO_ERROR_FAILED: Generic error condition for when an operation fails\n     and no more specific #GIOErrorEnum value is defined.\n @G_IO_ERROR_NOT_FOUND: File not found.\n @G_IO_ERROR_EXISTS: File already exists.\n @G_IO_ERROR_IS_DIRECTORY: File is a directory.\n @G_IO_ERROR_NOT_DIRECTORY: File is not a directory.\n @G_IO_ERROR_NOT_EMPTY: File is a directory that isn't empty.\n @G_IO_ERROR_NOT_REGULAR_FILE: File is not a regular file.\n @G_IO_ERROR_NOT_SYMBOLIC_LINK: File is not a symbolic link.\n @G_IO_ERROR_NOT_MOUNTABLE_FILE: File cannot be mounted.\n @G_IO_ERROR_FILENAME_TOO_LONG: Filename is too many characters.\n @G_IO_ERROR_INVALID_FILENAME: Filename is invalid or contains invalid characters.\n @G_IO_ERROR_TOO_MANY_LINKS: File contains too many symbolic links.\n @G_IO_ERROR_NO_SPACE: No space left on drive.\n @G_IO_ERROR_INVALID_ARGUMENT: Invalid argument.\n @G_IO_ERROR_PERMISSION_DENIED: Permission denied.\n @G_IO_ERROR_NOT_SUPPORTED: Operation (or one of its parameters) not supported\n @G_IO_ERROR_NOT_MOUNTED: File isn't mounted.\n @G_IO_ERROR_ALREADY_MOUNTED: File is already mounted.\n @G_IO_ERROR_CLOSED: File was closed.\n @G_IO_ERROR_CANCELLED: Operation was cancelled. See #GCancellable.\n @G_IO_ERROR_PENDING: Operations are still pending.\n @G_IO_ERROR_READ_ONLY: File is read only.\n @G_IO_ERROR_CANT_CREATE_BACKUP: Backup couldn't be created.\n @G_IO_ERROR_WRONG_ETAG: File's Entity Tag was incorrect.\n @G_IO_ERROR_TIMED_OUT: Operation timed out.\n @G_IO_ERROR_WOULD_RECURSE: Operation would be recursive.\n @G_IO_ERROR_BUSY: File is busy.\n @G_IO_ERROR_WOULD_BLOCK: Operation would block.\n @G_IO_ERROR_HOST_NOT_FOUND: Host couldn't be found (remote operations).\n @G_IO_ERROR_WOULD_MERGE: Operation would merge files.\n @G_IO_ERROR_FAILED_HANDLED: Operation failed and a helper program has\n     already interacted with the user. Do not display any error dialog.\n @G_IO_ERROR_TOO_MANY_OPEN_FILES: The current process has too many files\n     open and can't open any more. Duplicate descriptors do count toward\n     this limit. Since 2.20\n @G_IO_ERROR_NOT_INITIALIZED: The object has not been initialized. Since 2.22\n @G_IO_ERROR_ADDRESS_IN_USE: The requested address is already in use. Since 2.22\n @G_IO_ERROR_PARTIAL_INPUT: Need more input to finish operation. Since 2.24\n @G_IO_ERROR_INVALID_DATA: The input data was invalid. Since 2.24\n @G_IO_ERROR_DBUS_ERROR: A remote object generated an error that\n     doesn't correspond to a locally registered #GError error\n     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus\n     error name and g_dbus_error_strip_remote_error() to fix up the\n     message so it matches what was received on the wire. Since 2.26.\n @G_IO_ERROR_HOST_UNREACHABLE: Host unreachable. Since 2.26\n @G_IO_ERROR_NETWORK_UNREACHABLE: Network unreachable. Since 2.26\n @G_IO_ERROR_CONNECTION_REFUSED: Connection refused. Since 2.26\n @G_IO_ERROR_PROXY_FAILED: Connection to proxy server failed. Since 2.26\n @G_IO_ERROR_PROXY_AUTH_FAILED: Proxy authentication failed. Since 2.26\n @G_IO_ERROR_PROXY_NEED_AUTH: Proxy server needs authentication. Since 2.26\n @G_IO_ERROR_PROXY_NOT_ALLOWED: Proxy connection is not allowed by ruleset.\n     Since 2.26\n @G_IO_ERROR_BROKEN_PIPE: Broken pipe. Since 2.36\n @G_IO_ERROR_CONNECTION_CLOSED: Connection closed by peer. Note that this\n     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some\n     \"connection closed\" errors returned %G_IO_ERROR_BROKEN_PIPE, but others\n     returned %G_IO_ERROR_FAILED. Now they should all return the same\n     value, which has this more logical name. Since 2.44.\n @G_IO_ERROR_NOT_CONNECTED: Transport endpoint is not connected. Since 2.44\n @G_IO_ERROR_MESSAGE_TOO_LARGE: Message too large. Since 2.48.\n @G_IO_ERROR_NO_SUCH_DEVICE: No such device found. Since 2.74\n @G_IO_ERROR_DESTINATION_UNSET: Destination address unset. Since 2.80\n\n Error codes returned by GIO functions.\n\n Note that this domain may be extended in future GLib releases. In\n general, new error codes either only apply to new APIs, or else\n replace %G_IO_ERROR_FAILED in cases that were not explicitly\n distinguished before. You should therefore avoid writing code like\n |[<!-- language=\"C\" -->\n if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))\n   {\n     // Assume that this is EPRINTERONFIRE\n     ...\n   }\n ]|\n but should instead treat all unrecognized error codes the same as\n %G_IO_ERROR_FAILED.\n\n See also #GPollableReturn for a cheaper way of returning\n %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError."]
pub type GIOErrorEnum = ::std::os::raw::c_uint;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_PASSWORD: GAskPasswordFlags = 1;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_USERNAME: GAskPasswordFlags = 2;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_DOMAIN: GAskPasswordFlags = 4;
pub const GAskPasswordFlags_G_ASK_PASSWORD_SAVING_SUPPORTED: GAskPasswordFlags = 8;
pub const GAskPasswordFlags_G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: GAskPasswordFlags = 16;
pub const GAskPasswordFlags_G_ASK_PASSWORD_TCRYPT: GAskPasswordFlags = 32;
#[doc = " GAskPasswordFlags:\n @G_ASK_PASSWORD_NEED_PASSWORD: operation requires a password.\n @G_ASK_PASSWORD_NEED_USERNAME: operation requires a username.\n @G_ASK_PASSWORD_NEED_DOMAIN: operation requires a domain.\n @G_ASK_PASSWORD_SAVING_SUPPORTED: operation supports saving settings.\n @G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: operation supports anonymous users.\n @G_ASK_PASSWORD_TCRYPT: operation takes TCRYPT parameters (Since: 2.58)\n\n #GAskPasswordFlags are used to request specific information from the\n user, or to notify the user of their choices in an authentication\n situation."]
pub type GAskPasswordFlags = ::std::os::raw::c_uint;
pub const GPasswordSave_G_PASSWORD_SAVE_NEVER: GPasswordSave = 0;
pub const GPasswordSave_G_PASSWORD_SAVE_FOR_SESSION: GPasswordSave = 1;
pub const GPasswordSave_G_PASSWORD_SAVE_PERMANENTLY: GPasswordSave = 2;
#[doc = " GPasswordSave:\n @G_PASSWORD_SAVE_NEVER: never save a password.\n @G_PASSWORD_SAVE_FOR_SESSION: save a password for the session.\n @G_PASSWORD_SAVE_PERMANENTLY: save a password permanently.\n\n #GPasswordSave is used to indicate the lifespan of a saved password.\n\n #Gvfs stores passwords in the Gnome keyring when this flag allows it\n to, and later retrieves it again from there."]
pub type GPasswordSave = ::std::os::raw::c_uint;
pub const GMountOperationResult_G_MOUNT_OPERATION_HANDLED: GMountOperationResult = 0;
pub const GMountOperationResult_G_MOUNT_OPERATION_ABORTED: GMountOperationResult = 1;
pub const GMountOperationResult_G_MOUNT_OPERATION_UNHANDLED: GMountOperationResult = 2;
#[doc = " GMountOperationResult:\n @G_MOUNT_OPERATION_HANDLED: The request was fulfilled and the\n     user specified data is now available\n @G_MOUNT_OPERATION_ABORTED: The user requested the mount operation\n     to be aborted\n @G_MOUNT_OPERATION_UNHANDLED: The request was unhandled (i.e. not\n     implemented)\n\n #GMountOperationResult is returned as a result when a request for\n information is send by the mounting operation."]
pub type GMountOperationResult = ::std::os::raw::c_uint;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_NONE: GOutputStreamSpliceFlags = 0;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: GOutputStreamSpliceFlags =
    1;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: GOutputStreamSpliceFlags =
    2;
#[doc = " GOutputStreamSpliceFlags:\n @G_OUTPUT_STREAM_SPLICE_NONE: Do not close either stream.\n @G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: Close the source stream after\n     the splice.\n @G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: Close the target stream after\n     the splice.\n\n GOutputStreamSpliceFlags determine how streams should be spliced."]
pub type GOutputStreamSpliceFlags = ::std::os::raw::c_uint;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_NONE: GIOStreamSpliceFlags = 0;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM1: GIOStreamSpliceFlags = 1;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM2: GIOStreamSpliceFlags = 2;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: GIOStreamSpliceFlags = 4;
#[doc = " GIOStreamSpliceFlags:\n @G_IO_STREAM_SPLICE_NONE: Do not close either stream.\n @G_IO_STREAM_SPLICE_CLOSE_STREAM1: Close the first stream after\n     the splice.\n @G_IO_STREAM_SPLICE_CLOSE_STREAM2: Close the second stream after\n     the splice.\n @G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: Wait for both splice operations to finish\n     before calling the callback.\n\n GIOStreamSpliceFlags determine how streams should be spliced.\n\n Since: 2.28"]
pub type GIOStreamSpliceFlags = ::std::os::raw::c_uint;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_UNKNOWN: GEmblemOrigin = 0;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_DEVICE: GEmblemOrigin = 1;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_LIVEMETADATA: GEmblemOrigin = 2;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_TAG: GEmblemOrigin = 3;
#[doc = " GEmblemOrigin:\n @G_EMBLEM_ORIGIN_UNKNOWN: Emblem of unknown origin\n @G_EMBLEM_ORIGIN_DEVICE: Emblem adds device-specific information\n @G_EMBLEM_ORIGIN_LIVEMETADATA: Emblem depicts live metadata, such as \"readonly\"\n @G_EMBLEM_ORIGIN_TAG: Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)\n\n GEmblemOrigin is used to add information about the origin of the emblem\n to #GEmblem.\n\n Since: 2.18"]
pub type GEmblemOrigin = ::std::os::raw::c_uint;
pub const GResolverError_G_RESOLVER_ERROR_NOT_FOUND: GResolverError = 0;
pub const GResolverError_G_RESOLVER_ERROR_TEMPORARY_FAILURE: GResolverError = 1;
pub const GResolverError_G_RESOLVER_ERROR_INTERNAL: GResolverError = 2;
#[doc = " GResolverError:\n @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not\n     found\n @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not\n     be looked up due to a network error or similar problem\n @G_RESOLVER_ERROR_INTERNAL: unknown error\n\n An error code used with %G_RESOLVER_ERROR in a #GError returned\n from a #GResolver routine.\n\n Since: 2.22"]
pub type GResolverError = ::std::os::raw::c_uint;
pub const GResolverRecordType_G_RESOLVER_RECORD_SRV: GResolverRecordType = 1;
pub const GResolverRecordType_G_RESOLVER_RECORD_MX: GResolverRecordType = 2;
pub const GResolverRecordType_G_RESOLVER_RECORD_TXT: GResolverRecordType = 3;
pub const GResolverRecordType_G_RESOLVER_RECORD_SOA: GResolverRecordType = 4;
pub const GResolverRecordType_G_RESOLVER_RECORD_NS: GResolverRecordType = 5;
#[doc = " GResolverRecordType:\n @G_RESOLVER_RECORD_SRV: look up DNS SRV records for a domain\n @G_RESOLVER_RECORD_MX: look up DNS MX records for a domain\n @G_RESOLVER_RECORD_TXT: look up DNS TXT records for a name\n @G_RESOLVER_RECORD_SOA: look up DNS SOA records for a zone\n @G_RESOLVER_RECORD_NS: look up DNS NS records for a domain\n\n The type of record that g_resolver_lookup_records() or\n g_resolver_lookup_records_async() should retrieve. The records are returned\n as lists of #GVariant tuples. Each record type has different values in\n the variant tuples returned.\n\n %G_RESOLVER_RECORD_SRV records are returned as variants with the signature\n `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the\n weight, a `guint16` with the port, and a string of the hostname.\n\n %G_RESOLVER_RECORD_MX records are returned as variants with the signature\n `(qs)`, representing a `guint16` with the preference, and a string containing\n the mail exchanger hostname.\n\n %G_RESOLVER_RECORD_TXT records are returned as variants with the signature\n `(as)`, representing an array of the strings in the text record. Note: Most TXT\n records only contain a single string, but\n [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a\n record to contain multiple strings. The RFC which defines the interpretation\n of a specific TXT record will likely require concatenation of multiple\n strings if they are present, as with\n [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).\n\n %G_RESOLVER_RECORD_SOA records are returned as variants with the signature\n `(ssuuuuu)`, representing a string containing the primary name server, a\n string containing the administrator, the serial as a `guint32`, the refresh\n interval as a `guint32`, the retry interval as a `guint32`, the expire timeout\n as a `guint32`, and the TTL as a `guint32`.\n\n %G_RESOLVER_RECORD_NS records are returned as variants with the signature\n `(s)`, representing a string of the hostname of the name server.\n\n Since: 2.34"]
pub type GResolverRecordType = ::std::os::raw::c_uint;
pub const GResourceError_G_RESOURCE_ERROR_NOT_FOUND: GResourceError = 0;
pub const GResourceError_G_RESOURCE_ERROR_INTERNAL: GResourceError = 1;
#[doc = " GResourceError:\n @G_RESOURCE_ERROR_NOT_FOUND: no file was found at the requested path\n @G_RESOURCE_ERROR_INTERNAL: unknown error\n\n An error code used with %G_RESOURCE_ERROR in a #GError returned\n from a #GResource routine.\n\n Since: 2.32"]
pub type GResourceError = ::std::os::raw::c_uint;
pub const GResourceFlags_G_RESOURCE_FLAGS_NONE: GResourceFlags = 0;
pub const GResourceFlags_G_RESOURCE_FLAGS_COMPRESSED: GResourceFlags = 1;
#[doc = " GResourceFlags:\n @G_RESOURCE_FLAGS_NONE: No flags set.\n @G_RESOURCE_FLAGS_COMPRESSED: The file is compressed.\n\n GResourceFlags give information about a particular file inside a resource\n bundle.\n\n Since: 2.32"]
pub type GResourceFlags = ::std::os::raw::c_uint;
pub const GResourceLookupFlags_G_RESOURCE_LOOKUP_FLAGS_NONE: GResourceLookupFlags = 0;
#[doc = " GResourceLookupFlags:\n @G_RESOURCE_LOOKUP_FLAGS_NONE: No flags set.\n\n GResourceLookupFlags determine how resource path lookups are handled.\n\n Since: 2.32"]
pub type GResourceLookupFlags = ::std::os::raw::c_uint;
pub const GSocketFamily_G_SOCKET_FAMILY_INVALID: GSocketFamily = 0;
pub const GSocketFamily_G_SOCKET_FAMILY_UNIX: GSocketFamily = 1;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV4: GSocketFamily = 2;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV6: GSocketFamily = 10;
#[doc = " GSocketFamily:\n @G_SOCKET_FAMILY_INVALID: no address family\n @G_SOCKET_FAMILY_IPV4: the IPv4 family\n @G_SOCKET_FAMILY_IPV6: the IPv6 family\n @G_SOCKET_FAMILY_UNIX: the UNIX domain family\n\n The protocol family of a #GSocketAddress. (These values are\n identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,\n if available.)\n\n Since: 2.22"]
pub type GSocketFamily = ::std::os::raw::c_uint;
pub const GSocketType_G_SOCKET_TYPE_INVALID: GSocketType = 0;
pub const GSocketType_G_SOCKET_TYPE_STREAM: GSocketType = 1;
pub const GSocketType_G_SOCKET_TYPE_DATAGRAM: GSocketType = 2;
pub const GSocketType_G_SOCKET_TYPE_SEQPACKET: GSocketType = 3;
#[doc = " GSocketType:\n @G_SOCKET_TYPE_INVALID: Type unknown or wrong\n @G_SOCKET_TYPE_STREAM: Reliable connection-based byte streams (e.g. TCP).\n @G_SOCKET_TYPE_DATAGRAM: Connectionless, unreliable datagram passing.\n     (e.g. UDP)\n @G_SOCKET_TYPE_SEQPACKET: Reliable connection-based passing of datagrams\n     of fixed maximum length (e.g. SCTP).\n\n Flags used when creating a #GSocket. Some protocols may not implement\n all the socket types.\n\n Since: 2.22"]
pub type GSocketType = ::std::os::raw::c_uint;
pub const GSocketMsgFlags_G_SOCKET_MSG_NONE: GSocketMsgFlags = 0;
pub const GSocketMsgFlags_G_SOCKET_MSG_OOB: GSocketMsgFlags = 1;
pub const GSocketMsgFlags_G_SOCKET_MSG_PEEK: GSocketMsgFlags = 2;
pub const GSocketMsgFlags_G_SOCKET_MSG_DONTROUTE: GSocketMsgFlags = 4;
#[doc = " GSocketMsgFlags:\n @G_SOCKET_MSG_NONE: No flags.\n @G_SOCKET_MSG_OOB: Request to send/receive out of band data.\n @G_SOCKET_MSG_PEEK: Read data from the socket without removing it from\n     the queue.\n @G_SOCKET_MSG_DONTROUTE: Don't use a gateway to send out the packet,\n     only send to hosts on directly connected networks.\n\n Flags used in g_socket_receive_message() and g_socket_send_message().\n The flags listed in the enum are some commonly available flags, but the\n values used for them are the same as on the platform, and any other flags\n are passed in/out as is. So to use a platform specific flag, just include\n the right system header and pass in the flag.\n\n Since: 2.22"]
pub type GSocketMsgFlags = ::std::os::raw::c_uint;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UNKNOWN: GSocketProtocol = -1;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_DEFAULT: GSocketProtocol = 0;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_TCP: GSocketProtocol = 6;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UDP: GSocketProtocol = 17;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_SCTP: GSocketProtocol = 132;
#[doc = " GSocketProtocol:\n @G_SOCKET_PROTOCOL_UNKNOWN: The protocol type is unknown\n @G_SOCKET_PROTOCOL_DEFAULT: The default protocol for the family/type\n @G_SOCKET_PROTOCOL_TCP: TCP over IP\n @G_SOCKET_PROTOCOL_UDP: UDP over IP\n @G_SOCKET_PROTOCOL_SCTP: SCTP over IP\n\n A protocol identifier is specified when creating a #GSocket, which is a\n family/type specific identifier, where 0 means the default protocol for\n the particular family/type.\n\n This enum contains a set of commonly available and used protocols. You\n can also pass any other identifiers handled by the platform in order to\n use protocols not listed here.\n\n Since: 2.22"]
pub type GSocketProtocol = ::std::os::raw::c_int;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_ZLIB: GZlibCompressorFormat = 0;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_GZIP: GZlibCompressorFormat = 1;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_RAW: GZlibCompressorFormat = 2;
#[doc = " GZlibCompressorFormat:\n @G_ZLIB_COMPRESSOR_FORMAT_ZLIB: deflate compression with zlib header\n @G_ZLIB_COMPRESSOR_FORMAT_GZIP: gzip file format\n @G_ZLIB_COMPRESSOR_FORMAT_RAW: deflate compression with no header\n\n Used to select the type of data format to use for #GZlibDecompressor\n and #GZlibCompressor.\n\n Since: 2.24"]
pub type GZlibCompressorFormat = ::std::os::raw::c_uint;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_INVALID: GUnixSocketAddressType = 0;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ANONYMOUS: GUnixSocketAddressType = 1;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_PATH: GUnixSocketAddressType = 2;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT: GUnixSocketAddressType = 3;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: GUnixSocketAddressType = 4;
#[doc = " GUnixSocketAddressType:\n @G_UNIX_SOCKET_ADDRESS_INVALID: invalid\n @G_UNIX_SOCKET_ADDRESS_ANONYMOUS: anonymous\n @G_UNIX_SOCKET_ADDRESS_PATH: a filesystem path\n @G_UNIX_SOCKET_ADDRESS_ABSTRACT: an abstract name\n @G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: an abstract name, 0-padded\n   to the full length of a unix socket name\n\n The type of name used by a #GUnixSocketAddress.\n %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain\n socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS\n indicates a socket not bound to any name (eg, a client-side socket,\n or a socket created with socketpair()).\n\n For abstract sockets, there are two incompatible ways of naming\n them; the man pages suggest using the entire `struct sockaddr_un`\n as the name, padding the unused parts of the %sun_path field with\n zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.\n However, many programs instead just use a portion of %sun_path, and\n pass an appropriate smaller length to bind() or connect(). This is\n %G_UNIX_SOCKET_ADDRESS_ABSTRACT.\n\n Since: 2.26"]
pub type GUnixSocketAddressType = ::std::os::raw::c_uint;
pub const GBusType_G_BUS_TYPE_STARTER: GBusType = -1;
pub const GBusType_G_BUS_TYPE_NONE: GBusType = 0;
pub const GBusType_G_BUS_TYPE_SYSTEM: GBusType = 1;
pub const GBusType_G_BUS_TYPE_SESSION: GBusType = 2;
#[doc = " GBusType:\n @G_BUS_TYPE_STARTER: An alias for the message bus that activated the process, if any.\n @G_BUS_TYPE_NONE: Not a message bus.\n @G_BUS_TYPE_SYSTEM: The system-wide message bus.\n @G_BUS_TYPE_SESSION: The login session message bus.\n\n An enumeration for well-known message buses.\n\n Since: 2.26"]
pub type GBusType = ::std::os::raw::c_int;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_NONE: GBusNameOwnerFlags = 0;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: GBusNameOwnerFlags = 1;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_REPLACE: GBusNameOwnerFlags = 2;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: GBusNameOwnerFlags = 4;
#[doc = " GBusNameOwnerFlags:\n @G_BUS_NAME_OWNER_FLAGS_NONE: No flags set.\n @G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: Allow another message bus connection to claim the name.\n @G_BUS_NAME_OWNER_FLAGS_REPLACE: If another message bus connection owns the name and have\n specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.\n @G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: If another message bus connection owns the name, immediately\n return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)\n\n Flags used in g_bus_own_name().\n\n Since: 2.26"]
pub type GBusNameOwnerFlags = ::std::os::raw::c_uint;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_NONE: GBusNameWatcherFlags = 0;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_AUTO_START: GBusNameWatcherFlags = 1;
#[doc = " GBusNameWatcherFlags:\n @G_BUS_NAME_WATCHER_FLAGS_NONE: No flags set.\n @G_BUS_NAME_WATCHER_FLAGS_AUTO_START: If no-one owns the name when\n beginning to watch the name, ask the bus to launch an owner for the\n name.\n\n Flags used in g_bus_watch_name().\n\n Since: 2.26"]
pub type GBusNameWatcherFlags = ::std::os::raw::c_uint;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NONE: GDBusProxyFlags = 0;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: GDBusProxyFlags = 1;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: GDBusProxyFlags = 2;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: GDBusProxyFlags = 4;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: GDBusProxyFlags = 8;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: GDBusProxyFlags =
    16;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: GDBusProxyFlags = 32;
#[doc = " GDBusProxyFlags:\n @G_DBUS_PROXY_FLAGS_NONE: No flags set.\n @G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: Don't load properties.\n @G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: Don't connect to signals on the remote object.\n @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: If the proxy is for a well-known name,\n do not ask the bus to launch an owner during proxy initialization or a method call.\n This flag is only meaningful in proxies for well-known names.\n @G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.\n @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: If the proxy is for a well-known name,\n do not ask the bus to launch an owner during proxy initialization, but allow it to be\n autostarted by a method call. This flag is only meaningful in proxies for well-known names,\n and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.\n @G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch D-Bus\n    call for this signal subscription. This gives you more control\n    over which match rules you add (but you must add them manually). (Since: 2.72)\n\n Flags used when constructing an instance of a #GDBusProxy derived class.\n\n Since: 2.26"]
pub type GDBusProxyFlags = ::std::os::raw::c_uint;
pub const GDBusError_G_DBUS_ERROR_FAILED: GDBusError = 0;
pub const GDBusError_G_DBUS_ERROR_NO_MEMORY: GDBusError = 1;
pub const GDBusError_G_DBUS_ERROR_SERVICE_UNKNOWN: GDBusError = 2;
pub const GDBusError_G_DBUS_ERROR_NAME_HAS_NO_OWNER: GDBusError = 3;
pub const GDBusError_G_DBUS_ERROR_NO_REPLY: GDBusError = 4;
pub const GDBusError_G_DBUS_ERROR_IO_ERROR: GDBusError = 5;
pub const GDBusError_G_DBUS_ERROR_BAD_ADDRESS: GDBusError = 6;
pub const GDBusError_G_DBUS_ERROR_NOT_SUPPORTED: GDBusError = 7;
pub const GDBusError_G_DBUS_ERROR_LIMITS_EXCEEDED: GDBusError = 8;
pub const GDBusError_G_DBUS_ERROR_ACCESS_DENIED: GDBusError = 9;
pub const GDBusError_G_DBUS_ERROR_AUTH_FAILED: GDBusError = 10;
pub const GDBusError_G_DBUS_ERROR_NO_SERVER: GDBusError = 11;
pub const GDBusError_G_DBUS_ERROR_TIMEOUT: GDBusError = 12;
pub const GDBusError_G_DBUS_ERROR_NO_NETWORK: GDBusError = 13;
pub const GDBusError_G_DBUS_ERROR_ADDRESS_IN_USE: GDBusError = 14;
pub const GDBusError_G_DBUS_ERROR_DISCONNECTED: GDBusError = 15;
pub const GDBusError_G_DBUS_ERROR_INVALID_ARGS: GDBusError = 16;
pub const GDBusError_G_DBUS_ERROR_FILE_NOT_FOUND: GDBusError = 17;
pub const GDBusError_G_DBUS_ERROR_FILE_EXISTS: GDBusError = 18;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_METHOD: GDBusError = 19;
pub const GDBusError_G_DBUS_ERROR_TIMED_OUT: GDBusError = 20;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: GDBusError = 21;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_INVALID: GDBusError = 22;
pub const GDBusError_G_DBUS_ERROR_SPAWN_EXEC_FAILED: GDBusError = 23;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FORK_FAILED: GDBusError = 24;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_EXITED: GDBusError = 25;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: GDBusError = 26;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FAILED: GDBusError = 27;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SETUP_FAILED: GDBusError = 28;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CONFIG_INVALID: GDBusError = 29;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_INVALID: GDBusError = 30;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: GDBusError = 31;
pub const GDBusError_G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: GDBusError = 32;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FILE_INVALID: GDBusError = 33;
pub const GDBusError_G_DBUS_ERROR_SPAWN_NO_MEMORY: GDBusError = 34;
pub const GDBusError_G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: GDBusError = 35;
pub const GDBusError_G_DBUS_ERROR_INVALID_SIGNATURE: GDBusError = 36;
pub const GDBusError_G_DBUS_ERROR_INVALID_FILE_CONTENT: GDBusError = 37;
pub const GDBusError_G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: GDBusError = 38;
pub const GDBusError_G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: GDBusError = 39;
pub const GDBusError_G_DBUS_ERROR_OBJECT_PATH_IN_USE: GDBusError = 40;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_OBJECT: GDBusError = 41;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_INTERFACE: GDBusError = 42;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_PROPERTY: GDBusError = 43;
pub const GDBusError_G_DBUS_ERROR_PROPERTY_READ_ONLY: GDBusError = 44;
#[doc = " GDBusError:\n @G_DBUS_ERROR_FAILED:\n A generic error; \"something went wrong\" - see the error message for\n more.\n @G_DBUS_ERROR_NO_MEMORY:\n There was not enough memory to complete an operation.\n @G_DBUS_ERROR_SERVICE_UNKNOWN:\n The bus doesn't know how to launch a service to supply the bus name\n you wanted.\n @G_DBUS_ERROR_NAME_HAS_NO_OWNER:\n The bus name you referenced doesn't exist (i.e. no application owns\n it).\n @G_DBUS_ERROR_NO_REPLY:\n No reply to a message expecting one, usually means a timeout occurred.\n @G_DBUS_ERROR_IO_ERROR:\n Something went wrong reading or writing to a socket, for example.\n @G_DBUS_ERROR_BAD_ADDRESS:\n A D-Bus bus address was malformed.\n @G_DBUS_ERROR_NOT_SUPPORTED:\n Requested operation isn't supported (like ENOSYS on UNIX).\n @G_DBUS_ERROR_LIMITS_EXCEEDED:\n Some limited resource is exhausted.\n @G_DBUS_ERROR_ACCESS_DENIED:\n Security restrictions don't allow doing what you're trying to do.\n @G_DBUS_ERROR_AUTH_FAILED:\n Authentication didn't work.\n @G_DBUS_ERROR_NO_SERVER:\n Unable to connect to server (probably caused by ECONNREFUSED on a\n socket).\n @G_DBUS_ERROR_TIMEOUT:\n Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that\n %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:\n this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also\n exists. We can't fix it for compatibility reasons so just be\n careful.\n @G_DBUS_ERROR_NO_NETWORK:\n No network access (probably ENETUNREACH on a socket).\n @G_DBUS_ERROR_ADDRESS_IN_USE:\n Can't bind a socket since its address is in use (i.e. EADDRINUSE).\n @G_DBUS_ERROR_DISCONNECTED:\n The connection is disconnected and you're trying to use it.\n @G_DBUS_ERROR_INVALID_ARGS:\n Invalid arguments passed to a method call.\n @G_DBUS_ERROR_FILE_NOT_FOUND:\n Missing file.\n @G_DBUS_ERROR_FILE_EXISTS:\n Existing file and the operation you're using does not silently overwrite.\n @G_DBUS_ERROR_UNKNOWN_METHOD:\n Method name you invoked isn't known by the object you invoked it on.\n @G_DBUS_ERROR_UNKNOWN_OBJECT:\n Object you invoked a method on isn't known. Since 2.42\n @G_DBUS_ERROR_UNKNOWN_INTERFACE:\n Interface you invoked a method on isn't known by the object. Since 2.42\n @G_DBUS_ERROR_UNKNOWN_PROPERTY:\n Property you tried to access isn't known by the object. Since 2.42\n @G_DBUS_ERROR_PROPERTY_READ_ONLY:\n Property you tried to set is read-only. Since 2.42\n @G_DBUS_ERROR_TIMED_OUT:\n Certain timeout errors, e.g. while starting a service. Warning: this is\n confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We\n can't fix it for compatibility reasons so just be careful.\n @G_DBUS_ERROR_MATCH_RULE_NOT_FOUND:\n Tried to remove or modify a match rule that didn't exist.\n @G_DBUS_ERROR_MATCH_RULE_INVALID:\n The match rule isn't syntactically valid.\n @G_DBUS_ERROR_SPAWN_EXEC_FAILED:\n While starting a new process, the exec() call failed.\n @G_DBUS_ERROR_SPAWN_FORK_FAILED:\n While starting a new process, the fork() call failed.\n @G_DBUS_ERROR_SPAWN_CHILD_EXITED:\n While starting a new process, the child exited with a status code.\n @G_DBUS_ERROR_SPAWN_CHILD_SIGNALED:\n While starting a new process, the child exited on a signal.\n @G_DBUS_ERROR_SPAWN_FAILED:\n While starting a new process, something went wrong.\n @G_DBUS_ERROR_SPAWN_SETUP_FAILED:\n We failed to setup the environment correctly.\n @G_DBUS_ERROR_SPAWN_CONFIG_INVALID:\n We failed to setup the config parser correctly.\n @G_DBUS_ERROR_SPAWN_SERVICE_INVALID:\n Bus name was not valid.\n @G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND:\n Service file not found in system-services directory.\n @G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID:\n Permissions are incorrect on the setuid helper.\n @G_DBUS_ERROR_SPAWN_FILE_INVALID:\n Service file invalid (Name, User or Exec missing).\n @G_DBUS_ERROR_SPAWN_NO_MEMORY:\n Tried to get a UNIX process ID and it wasn't available.\n @G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN:\n Tried to get a UNIX process ID and it wasn't available.\n @G_DBUS_ERROR_INVALID_SIGNATURE:\n A type signature is not valid.\n @G_DBUS_ERROR_INVALID_FILE_CONTENT:\n A file contains invalid syntax or is otherwise broken.\n @G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:\n Asked for SELinux security context and it wasn't available.\n @G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN:\n Asked for ADT audit data and it wasn't available.\n @G_DBUS_ERROR_OBJECT_PATH_IN_USE:\n There's already an object with the requested object path.\n\n Error codes for the %G_DBUS_ERROR error domain.\n\n Since: 2.26"]
pub type GDBusError = ::std::os::raw::c_uint;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_NONE: GDBusConnectionFlags = 0;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: GDBusConnectionFlags =
    1;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: GDBusConnectionFlags =
    2;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS:
    GDBusConnectionFlags = 4;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION:
    GDBusConnectionFlags = 8;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING:
    GDBusConnectionFlags = 16;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER:
    GDBusConnectionFlags = 32;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: GDBusConnectionFlags = 64;
#[doc = " GDBusConnectionFlags:\n @G_DBUS_CONNECTION_FLAGS_NONE: No flags set.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: Perform authentication against server.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: Perform authentication against client.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: When\n authenticating as a server, allow the anonymous authentication\n method.\n @G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: Pass this flag if connecting to a peer that is a\n message bus. This means that the Hello() method will be invoked as part of the connection setup.\n @G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: If set, processing of D-Bus messages is\n delayed until g_dbus_connection_start_message_processing() is called.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: When authenticating\n as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)\n @G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: When authenticating, try to use\n  protocols that work across a Linux user namespace boundary, even if this\n  reduces interoperability with older D-Bus implementations. This currently\n  affects client-side `EXTERNAL` authentication, for which this flag makes\n  connections to a server in another user namespace succeed, but causes\n  a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74\n\n Flags used when creating a new #GDBusConnection.\n\n Since: 2.26"]
pub type GDBusConnectionFlags = ::std::os::raw::c_uint;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_NONE: GDBusCapabilityFlags = 0;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: GDBusCapabilityFlags = 1;
#[doc = " GDBusCapabilityFlags:\n @G_DBUS_CAPABILITY_FLAGS_NONE: No flags set.\n @G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: The connection\n supports exchanging UNIX file descriptors with the remote peer.\n\n Capabilities negotiated with the remote peer.\n\n Since: 2.26"]
pub type GDBusCapabilityFlags = ::std::os::raw::c_uint;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NONE: GDBusCallFlags = 0;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NO_AUTO_START: GDBusCallFlags = 1;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: GDBusCallFlags = 2;
#[doc = " GDBusCallFlags:\n @G_DBUS_CALL_FLAGS_NONE: No flags set.\n @G_DBUS_CALL_FLAGS_NO_AUTO_START: The bus must not launch\n an owner for the destination name in response to this method\n invocation.\n @G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: the caller is prepared to\n wait for interactive authorization. Since 2.46.\n\n Flags used in g_dbus_connection_call() and similar APIs.\n\n Since: 2.26"]
pub type GDBusCallFlags = ::std::os::raw::c_uint;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_INVALID: GDBusMessageType = 0;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_CALL: GDBusMessageType = 1;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_RETURN: GDBusMessageType = 2;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_ERROR: GDBusMessageType = 3;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_SIGNAL: GDBusMessageType = 4;
#[doc = " GDBusMessageType:\n @G_DBUS_MESSAGE_TYPE_INVALID: Message is of invalid type.\n @G_DBUS_MESSAGE_TYPE_METHOD_CALL: Method call.\n @G_DBUS_MESSAGE_TYPE_METHOD_RETURN: Method reply.\n @G_DBUS_MESSAGE_TYPE_ERROR: Error reply.\n @G_DBUS_MESSAGE_TYPE_SIGNAL: Signal emission.\n\n Message types used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageType = ::std::os::raw::c_uint;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NONE: GDBusMessageFlags = 0;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: GDBusMessageFlags = 1;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: GDBusMessageFlags = 2;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION:
    GDBusMessageFlags = 4;
#[doc = " GDBusMessageFlags:\n @G_DBUS_MESSAGE_FLAGS_NONE: No flags set.\n @G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: A reply is not expected.\n @G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: The bus must not launch an\n owner for the destination name in response to this message.\n @G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: If set on a method\n call, this flag means that the caller is prepared to wait for interactive\n authorization. Since 2.46.\n\n Message flags used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageFlags = ::std::os::raw::c_uint;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INVALID: GDBusMessageHeaderField = 0;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_PATH: GDBusMessageHeaderField = 1;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: GDBusMessageHeaderField =
    2;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: GDBusMessageHeaderField = 3;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: GDBusMessageHeaderField =
    4;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL:
    GDBusMessageHeaderField = 5;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: GDBusMessageHeaderField =
    6;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SENDER: GDBusMessageHeaderField = 7;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: GDBusMessageHeaderField =
    8;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS:
    GDBusMessageHeaderField = 9;
#[doc = " GDBusMessageHeaderField:\n @G_DBUS_MESSAGE_HEADER_FIELD_INVALID: Not a valid header field.\n @G_DBUS_MESSAGE_HEADER_FIELD_PATH: The object path.\n @G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: The interface name.\n @G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: The method or signal name.\n @G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: The name of the error that occurred.\n @G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: The serial number the message is a reply to.\n @G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: The name the message is intended for.\n @G_DBUS_MESSAGE_HEADER_FIELD_SENDER: Unique name of the sender of the message (filled in by the bus).\n @G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: The signature of the message body.\n @G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: The number of UNIX file descriptors that accompany the message.\n\n Header fields used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageHeaderField = ::std::os::raw::c_uint;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_NONE: GDBusPropertyInfoFlags = 0;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_READABLE: GDBusPropertyInfoFlags = 1;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: GDBusPropertyInfoFlags = 2;
#[doc = " GDBusPropertyInfoFlags:\n @G_DBUS_PROPERTY_INFO_FLAGS_NONE: No flags set.\n @G_DBUS_PROPERTY_INFO_FLAGS_READABLE: Property is readable.\n @G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: Property is writable.\n\n Flags describing the access control of a D-Bus property.\n\n Since: 2.26"]
pub type GDBusPropertyInfoFlags = ::std::os::raw::c_uint;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_NONE: GDBusSubtreeFlags = 0;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: GDBusSubtreeFlags =
    1;
#[doc = " GDBusSubtreeFlags:\n @G_DBUS_SUBTREE_FLAGS_NONE: No flags set.\n @G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: Method calls to objects not in the enumerated range\n                                                       will still be dispatched. This is useful if you want\n                                                       to dynamically spawn objects in the subtree.\n\n Flags passed to g_dbus_connection_register_subtree().\n\n Since: 2.26"]
pub type GDBusSubtreeFlags = ::std::os::raw::c_uint;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_NONE: GDBusServerFlags = 0;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: GDBusServerFlags = 1;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: GDBusServerFlags = 2;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: GDBusServerFlags =
    4;
#[doc = " GDBusServerFlags:\n @G_DBUS_SERVER_FLAGS_NONE: No flags set.\n @G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: All #GDBusServer::new-connection\n signals will run in separated dedicated threads (see signal for\n details).\n @G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: Allow the anonymous\n authentication method.\n @G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: Require the UID of the\n peer to be the same as the UID of the server when authenticating. (Since: 2.68)\n\n Flags used when creating a #GDBusServer.\n\n Since: 2.26"]
pub type GDBusServerFlags = ::std::os::raw::c_uint;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NONE: GDBusSignalFlags = 0;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: GDBusSignalFlags = 1;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: GDBusSignalFlags = 2;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: GDBusSignalFlags = 4;
#[doc = " GDBusSignalFlags:\n @G_DBUS_SIGNAL_FLAGS_NONE: No flags set.\n @G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch\n D-Bus call for this signal subscription.  This gives you more control\n over which match rules you add (but you must add them manually).\n @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: Match first arguments that\n contain a bus or interface name with the given namespace.\n @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: Match first arguments that\n contain an object path that is either equivalent to the given path,\n or one of the paths is a subpath of the other.\n\n Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().\n\n Since: 2.26"]
pub type GDBusSignalFlags = ::std::os::raw::c_uint;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_NONE: GDBusSendMessageFlags = 0;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: GDBusSendMessageFlags =
    1;
#[doc = " GDBusSendMessageFlags:\n @G_DBUS_SEND_MESSAGE_FLAGS_NONE: No flags set.\n @G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: Do not automatically\n assign a serial number from the #GDBusConnection object when\n sending a message.\n\n Flags used when sending #GDBusMessages on a #GDBusConnection.\n\n Since: 2.26"]
pub type GDBusSendMessageFlags = ::std::os::raw::c_uint;
pub const GCredentialsType_G_CREDENTIALS_TYPE_INVALID: GCredentialsType = 0;
pub const GCredentialsType_G_CREDENTIALS_TYPE_LINUX_UCRED: GCredentialsType = 1;
pub const GCredentialsType_G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: GCredentialsType = 2;
pub const GCredentialsType_G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: GCredentialsType = 3;
pub const GCredentialsType_G_CREDENTIALS_TYPE_SOLARIS_UCRED: GCredentialsType = 4;
pub const GCredentialsType_G_CREDENTIALS_TYPE_NETBSD_UNPCBID: GCredentialsType = 5;
pub const GCredentialsType_G_CREDENTIALS_TYPE_APPLE_XUCRED: GCredentialsType = 6;
pub const GCredentialsType_G_CREDENTIALS_TYPE_WIN32_PID: GCredentialsType = 7;
#[doc = " GCredentialsType:\n @G_CREDENTIALS_TYPE_INVALID: Indicates an invalid native credential type.\n @G_CREDENTIALS_TYPE_LINUX_UCRED: The native credentials type is a `struct ucred`.\n @G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: The native credentials type is a `struct cmsgcred`.\n @G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: The native credentials type is a `struct sockpeercred`. Added in 2.30.\n @G_CREDENTIALS_TYPE_SOLARIS_UCRED: The native credentials type is a `ucred_t`. Added in 2.40.\n @G_CREDENTIALS_TYPE_NETBSD_UNPCBID: The native credentials type is a `struct unpcbid`. Added in 2.42.\n @G_CREDENTIALS_TYPE_APPLE_XUCRED: The native credentials type is a `struct xucred`. Added in 2.66.\n @G_CREDENTIALS_TYPE_WIN32_PID: The native credentials type is a PID `DWORD`. Added in 2.72.\n\n Enumeration describing different kinds of native credential types.\n\n Since: 2.26"]
pub type GCredentialsType = ::std::os::raw::c_uint;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: GDBusMessageByteOrder = 66;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: GDBusMessageByteOrder =
    108;
#[doc = " GDBusMessageByteOrder:\n @G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: The byte order is big endian.\n @G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: The byte order is little endian.\n\n Enumeration used to describe the byte order of a D-Bus message.\n\n Since: 2.26"]
pub type GDBusMessageByteOrder = ::std::os::raw::c_uint;
pub const GApplicationFlags_G_APPLICATION_FLAGS_NONE: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_DEFAULT_FLAGS: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_IS_SERVICE: GApplicationFlags = 1;
pub const GApplicationFlags_G_APPLICATION_IS_LAUNCHER: GApplicationFlags = 2;
pub const GApplicationFlags_G_APPLICATION_HANDLES_OPEN: GApplicationFlags = 4;
pub const GApplicationFlags_G_APPLICATION_HANDLES_COMMAND_LINE: GApplicationFlags = 8;
pub const GApplicationFlags_G_APPLICATION_SEND_ENVIRONMENT: GApplicationFlags = 16;
pub const GApplicationFlags_G_APPLICATION_NON_UNIQUE: GApplicationFlags = 32;
pub const GApplicationFlags_G_APPLICATION_CAN_OVERRIDE_APP_ID: GApplicationFlags = 64;
pub const GApplicationFlags_G_APPLICATION_ALLOW_REPLACEMENT: GApplicationFlags = 128;
pub const GApplicationFlags_G_APPLICATION_REPLACE: GApplicationFlags = 256;
#[doc = " GApplicationFlags:\n @G_APPLICATION_FLAGS_NONE: Default. Deprecated in 2.74, use\n   %G_APPLICATION_DEFAULT_FLAGS instead\n @G_APPLICATION_DEFAULT_FLAGS: Default flags. Since: 2.74\n @G_APPLICATION_IS_SERVICE: Run as a service. In this mode, registration\n      fails if the service is already running, and the application\n      will initially wait up to 10 seconds for an initial activation\n      message to arrive.\n @G_APPLICATION_IS_LAUNCHER: Don't try to become the primary instance.\n @G_APPLICATION_HANDLES_OPEN: This application handles opening files (in\n     the primary instance). Note that this flag only affects the default\n     implementation of local_command_line(), and has no effect if\n     %G_APPLICATION_HANDLES_COMMAND_LINE is given.\n     See g_application_run() for details.\n @G_APPLICATION_HANDLES_COMMAND_LINE: This application handles command line\n     arguments (in the primary instance). Note that this flag only affect\n     the default implementation of local_command_line().\n     See g_application_run() for details.\n @G_APPLICATION_SEND_ENVIRONMENT: Send the environment of the\n     launching process to the primary instance. Set this flag if your\n     application is expected to behave differently depending on certain\n     environment variables. For instance, an editor might be expected\n     to use the `GIT_COMMITTER_NAME` environment variable\n     when editing a git commit message. The environment is available\n     to the #GApplication::command-line signal handler, via\n     g_application_command_line_getenv().\n @G_APPLICATION_NON_UNIQUE: Make no attempts to do any of the typical\n     single-instance application negotiation, even if the application\n     ID is given.  The application neither attempts to become the\n     owner of the application ID nor does it check if an existing\n     owner already exists.  Everything occurs in the local process.\n     Since: 2.30.\n @G_APPLICATION_CAN_OVERRIDE_APP_ID: Allow users to override the\n     application ID from the command line with `--gapplication-app-id`.\n     Since: 2.48\n @G_APPLICATION_ALLOW_REPLACEMENT: Allow another instance to take over\n     the bus name. Since: 2.60\n @G_APPLICATION_REPLACE: Take over from another instance. This flag is\n     usually set by passing `--gapplication-replace` on the commandline.\n     Since: 2.60\n\n Flags used to define the behaviour of a #GApplication.\n\n Since: 2.28"]
pub type GApplicationFlags = ::std::os::raw::c_uint;
pub const GTlsError_G_TLS_ERROR_UNAVAILABLE: GTlsError = 0;
pub const GTlsError_G_TLS_ERROR_MISC: GTlsError = 1;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE: GTlsError = 2;
pub const GTlsError_G_TLS_ERROR_NOT_TLS: GTlsError = 3;
pub const GTlsError_G_TLS_ERROR_HANDSHAKE: GTlsError = 4;
pub const GTlsError_G_TLS_ERROR_CERTIFICATE_REQUIRED: GTlsError = 5;
pub const GTlsError_G_TLS_ERROR_EOF: GTlsError = 6;
pub const GTlsError_G_TLS_ERROR_INAPPROPRIATE_FALLBACK: GTlsError = 7;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: GTlsError = 8;
#[doc = " GTlsError:\n @G_TLS_ERROR_UNAVAILABLE: No TLS provider is available\n @G_TLS_ERROR_MISC: Miscellaneous TLS error\n @G_TLS_ERROR_BAD_CERTIFICATE: The certificate presented could not\n   be parsed or failed validation.\n @G_TLS_ERROR_NOT_TLS: The TLS handshake failed because the\n   peer does not seem to be a TLS server.\n @G_TLS_ERROR_HANDSHAKE: The TLS handshake failed because the\n   peer's certificate was not acceptable.\n @G_TLS_ERROR_CERTIFICATE_REQUIRED: The TLS handshake failed because\n   the server requested a client-side certificate, but none was\n   provided. See g_tls_connection_set_certificate().\n @G_TLS_ERROR_EOF: The TLS connection was closed without proper\n   notice, which may indicate an attack. See\n   g_tls_connection_set_require_close_notify().\n @G_TLS_ERROR_INAPPROPRIATE_FALLBACK: The TLS handshake failed\n   because the client sent the fallback SCSV, indicating a protocol\n   downgrade attack. Since: 2.60\n @G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: The certificate failed\n   to load because a password was incorrect. Since: 2.72\n\n An error code used with %G_TLS_ERROR in a #GError returned from a\n TLS-related routine.\n\n Since: 2.28"]
pub type GTlsError = ::std::os::raw::c_uint;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NO_FLAGS: GTlsCertificateFlags = 0;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_UNKNOWN_CA: GTlsCertificateFlags = 1;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_BAD_IDENTITY: GTlsCertificateFlags = 2;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NOT_ACTIVATED: GTlsCertificateFlags = 4;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_EXPIRED: GTlsCertificateFlags = 8;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_REVOKED: GTlsCertificateFlags = 16;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_INSECURE: GTlsCertificateFlags = 32;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_GENERIC_ERROR: GTlsCertificateFlags = 64;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_VALIDATE_ALL: GTlsCertificateFlags = 127;
#[doc = " GTlsCertificateFlags:\n @G_TLS_CERTIFICATE_NO_FLAGS: No flags set. Since: 2.74\n @G_TLS_CERTIFICATE_UNKNOWN_CA: The signing certificate authority is\n   not known.\n @G_TLS_CERTIFICATE_BAD_IDENTITY: The certificate does not match the\n   expected identity of the site that it was retrieved from.\n @G_TLS_CERTIFICATE_NOT_ACTIVATED: The certificate's activation time\n   is still in the future\n @G_TLS_CERTIFICATE_EXPIRED: The certificate has expired\n @G_TLS_CERTIFICATE_REVOKED: The certificate has been revoked\n   according to the #GTlsConnection's certificate revocation list.\n @G_TLS_CERTIFICATE_INSECURE: The certificate's algorithm is\n   considered insecure.\n @G_TLS_CERTIFICATE_GENERIC_ERROR: Some other error occurred validating\n   the certificate\n @G_TLS_CERTIFICATE_VALIDATE_ALL: the combination of all of the above\n   flags\n\n A set of flags describing TLS certification validation. This can be\n used to describe why a particular certificate was rejected (for\n example, in #GTlsConnection::accept-certificate).\n\n GLib guarantees that if certificate verification fails, at least one\n flag will be set, but it does not guarantee that all possible flags\n will be set. Accordingly, you may not safely decide to ignore any\n particular type of error. For example, it would be incorrect to mask\n %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,\n because this could potentially be the only error flag set even if\n other problems exist with the certificate.\n\n Since: 2.28"]
pub type GTlsCertificateFlags = ::std::os::raw::c_uint;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_NONE: GTlsAuthenticationMode = 0;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUESTED: GTlsAuthenticationMode = 1;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUIRED: GTlsAuthenticationMode = 2;
#[doc = " GTlsAuthenticationMode:\n @G_TLS_AUTHENTICATION_NONE: client authentication not required\n @G_TLS_AUTHENTICATION_REQUESTED: client authentication is requested\n @G_TLS_AUTHENTICATION_REQUIRED: client authentication is required\n\n The client authentication mode for a #GTlsServerConnection.\n\n Since: 2.28"]
pub type GTlsAuthenticationMode = ::std::os::raw::c_uint;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_UNIQUE: GTlsChannelBindingType = 0;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:
    GTlsChannelBindingType = 1;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_EXPORTER: GTlsChannelBindingType = 2;
#[doc = " GTlsChannelBindingType:\n @G_TLS_CHANNEL_BINDING_TLS_UNIQUE:\n    [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding\n    type\n @G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:\n    [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)\n    binding type\n @G_TLS_CHANNEL_BINDING_TLS_EXPORTER:\n    [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding\n    type. Since: 2.74\n\n The type of TLS channel binding data to retrieve from #GTlsConnection\n or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The\n [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)\n binding type is not currently implemented.\n\n Since: 2.66"]
pub type GTlsChannelBindingType = ::std::os::raw::c_uint;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED:
    GTlsChannelBindingError = 0;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE:
    GTlsChannelBindingError = 1;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE:
    GTlsChannelBindingError = 2;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED:
    GTlsChannelBindingError = 3;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR:
    GTlsChannelBindingError = 4;
#[doc = " GTlsChannelBindingError:\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED: Either entire binding\n    retrieval facility or specific binding type is not implemented in the\n    TLS backend.\n @G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE: The handshake is not yet\n    complete on the connection which is a strong requirement for any existing\n    binding type.\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE: Handshake is complete but\n    binding data is not available. That normally indicates the TLS\n    implementation failed to provide the binding data. For example, some\n    implementations do not provide a peer certificate for resumed connections.\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED: Binding type is not supported\n    on the current connection. This error could be triggered when requesting\n    `tls-server-end-point` binding data for a certificate which has no hash\n    function or uses multiple hash functions.\n @G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR: Any other backend error\n    preventing binding data retrieval.\n\n An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to\n indicate a TLS channel binding retrieval error.\n\n Since: 2.66"]
pub type GTlsChannelBindingError = ::std::os::raw::c_uint;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_NEVER: GTlsRehandshakeMode = 0;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_SAFELY: GTlsRehandshakeMode = 1;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_UNSAFELY: GTlsRehandshakeMode = 2;
#[doc = " GTlsRehandshakeMode:\n @G_TLS_REHANDSHAKE_NEVER: Never allow rehandshaking\n @G_TLS_REHANDSHAKE_SAFELY: Allow safe rehandshaking only\n @G_TLS_REHANDSHAKE_UNSAFELY: Allow unsafe rehandshaking\n\n When to allow rehandshaking. See\n g_tls_connection_set_rehandshake_mode().\n\n Since: 2.28\n\n Deprecated: 2.60. Changing the rehandshake mode is no longer\n   required for compatibility. Also, rehandshaking has been removed\n   from the TLS protocol in TLS 1.3."]
pub type GTlsRehandshakeMode = ::std::os::raw::c_uint;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_NONE: _GTlsPasswordFlags = 0;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_RETRY: _GTlsPasswordFlags = 2;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_MANY_TRIES: _GTlsPasswordFlags = 4;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_FINAL_TRY: _GTlsPasswordFlags = 8;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_USER: _GTlsPasswordFlags = 16;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: _GTlsPasswordFlags = 32;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: _GTlsPasswordFlags = 64;
#[doc = " GTlsPasswordFlags:\n @G_TLS_PASSWORD_NONE: No flags\n @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.\n @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been\n    wrong many times, and the user may not have many chances left.\n @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get\n    this password right.\n @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.\n    Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer\n    PIN is required. Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific\n    PIN is required. Since: 2.70.\n\n Various flags for the password.\n\n Since: 2.30"]
pub type _GTlsPasswordFlags = ::std::os::raw::c_uint;
#[doc = " GTlsPasswordFlags:\n @G_TLS_PASSWORD_NONE: No flags\n @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.\n @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been\n    wrong many times, and the user may not have many chances left.\n @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get\n    this password right.\n @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.\n    Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer\n    PIN is required. Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific\n    PIN is required. Since: 2.70.\n\n Various flags for the password.\n\n Since: 2.30"]
pub use self::_GTlsPasswordFlags as GTlsPasswordFlags;
pub const GTlsInteractionResult_G_TLS_INTERACTION_UNHANDLED: GTlsInteractionResult = 0;
pub const GTlsInteractionResult_G_TLS_INTERACTION_HANDLED: GTlsInteractionResult = 1;
pub const GTlsInteractionResult_G_TLS_INTERACTION_FAILED: GTlsInteractionResult = 2;
#[doc = " GTlsInteractionResult:\n @G_TLS_INTERACTION_UNHANDLED: The interaction was unhandled (i.e. not\n     implemented).\n @G_TLS_INTERACTION_HANDLED: The interaction completed, and resulting data\n     is available.\n @G_TLS_INTERACTION_FAILED: The interaction has failed, or was cancelled.\n     and the operation should be aborted.\n\n #GTlsInteractionResult is returned by various functions in #GTlsInteraction\n when finishing an interaction request.\n\n Since: 2.30"]
pub type GTlsInteractionResult = ::std::os::raw::c_uint;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_NONE:
    GDBusInterfaceSkeletonFlags = 0;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD : GDBusInterfaceSkeletonFlags = 1 ;
#[doc = " GDBusInterfaceSkeletonFlags:\n @G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: No flags set.\n @G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: Each method invocation is handled in\n   a thread dedicated to the invocation. This means that the method implementation can use blocking IO\n   without blocking any other part of the process. It also means that the method implementation must\n   use locking to access data structures used by other threads.\n\n Flags describing the behavior of a #GDBusInterfaceSkeleton instance.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeletonFlags = ::std::os::raw::c_uint;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE:
    GDBusObjectManagerClientFlags = 0;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START:
    GDBusObjectManagerClientFlags = 1;
#[doc = " GDBusObjectManagerClientFlags:\n @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: No flags set.\n @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: If not set and the\n   manager is for a well-known name, then request the bus to launch\n   an owner for the name if no-one owns the name. This flag can only\n   be used in managers for well-known names.\n\n Flags used when constructing a #GDBusObjectManagerClient.\n\n Since: 2.30"]
pub type GDBusObjectManagerClientFlags = ::std::os::raw::c_uint;
pub const GTlsDatabaseVerifyFlags_G_TLS_DATABASE_VERIFY_NONE: GTlsDatabaseVerifyFlags = 0;
#[doc = " GTlsDatabaseVerifyFlags:\n @G_TLS_DATABASE_VERIFY_NONE: No verification flags\n\n Flags for g_tls_database_verify_chain().\n\n Since: 2.30"]
pub type GTlsDatabaseVerifyFlags = ::std::os::raw::c_uint;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_NONE: GTlsDatabaseLookupFlags = 0;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_KEYPAIR: GTlsDatabaseLookupFlags = 1;
#[doc = " GTlsDatabaseLookupFlags:\n @G_TLS_DATABASE_LOOKUP_NONE: No lookup flags\n @G_TLS_DATABASE_LOOKUP_KEYPAIR: Restrict lookup to certificates that have\n     a private key.\n\n Flags for g_tls_database_lookup_certificate_for_handle(),\n g_tls_database_lookup_certificate_issuer(),\n and g_tls_database_lookup_certificates_issued_by().\n\n Since: 2.30"]
pub type GTlsDatabaseLookupFlags = ::std::os::raw::c_uint;
pub const GTlsCertificateRequestFlags_G_TLS_CERTIFICATE_REQUEST_NONE: GTlsCertificateRequestFlags =
    0;
#[doc = " GTlsCertificateRequestFlags:\n @G_TLS_CERTIFICATE_REQUEST_NONE: No flags\n\n Flags for g_tls_interaction_request_certificate(),\n g_tls_interaction_request_certificate_async(), and\n g_tls_interaction_invoke_request_certificate().\n\n Since: 2.40"]
pub type GTlsCertificateRequestFlags = ::std::os::raw::c_uint;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_UNKNOWN: GTlsProtocolVersion = 0;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_SSL_3_0: GTlsProtocolVersion = 1;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_0: GTlsProtocolVersion = 2;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_1: GTlsProtocolVersion = 3;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_2: GTlsProtocolVersion = 4;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_3: GTlsProtocolVersion = 5;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_0: GTlsProtocolVersion = 201;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_2: GTlsProtocolVersion = 202;
#[doc = " GTlsProtocolVersion:\n @G_TLS_PROTOCOL_VERSION_UNKNOWN: No protocol version or unknown protocol version\n @G_TLS_PROTOCOL_VERSION_SSL_3_0: SSL 3.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_0: TLS 1.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_1: TLS 1.1, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_2: TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)\n @G_TLS_PROTOCOL_VERSION_TLS_1_3: TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)\n @G_TLS_PROTOCOL_VERSION_DTLS_1_0: DTLS 1.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_DTLS_1_2: DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)\n\n The TLS or DTLS protocol version used by a #GTlsConnection or\n #GDtlsConnection. The integer values of these versions are sequential\n to ensure newer known protocol versions compare greater than older\n known versions. Any known DTLS protocol version will compare greater\n than any SSL or TLS protocol version. The protocol version may be\n %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer\n protocol version that GLib does not yet know about. This means that\n it's possible for an unknown DTLS protocol version to compare less\n than the TLS protocol versions.\n\n Since: 2.70"]
pub type GTlsProtocolVersion = ::std::os::raw::c_uint;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_NONE: GIOModuleScopeFlags = 0;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: GIOModuleScopeFlags = 1;
#[doc = " GIOModuleScopeFlags:\n @G_IO_MODULE_SCOPE_NONE: No module scan flags\n @G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: When using this scope to load or\n     scan modules, automatically block a modules which has the same base\n     basename as previously loaded module.\n\n Flags for use with g_io_module_scope_new().\n\n Since: 2.30"]
pub type GIOModuleScopeFlags = ::std::os::raw::c_uint;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVING: GSocketClientEvent = 0;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVED: GSocketClientEvent = 1;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTING: GSocketClientEvent = 2;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTED: GSocketClientEvent = 3;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATING: GSocketClientEvent = 4;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATED: GSocketClientEvent = 5;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKING: GSocketClientEvent = 6;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKED: GSocketClientEvent = 7;
pub const GSocketClientEvent_G_SOCKET_CLIENT_COMPLETE: GSocketClientEvent = 8;
#[doc = " GSocketClientEvent:\n @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.\n @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.\n @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote\n   host (either a proxy or the destination server).\n @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote\n   host.\n @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating\n   with a proxy to connect to the destination server.\n @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated\n   with the proxy server.\n @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a\n   TLS handshake.\n @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a\n   TLS handshake.\n @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular\n   #GSocketConnectable.\n\n Describes an event occurring on a #GSocketClient. See the\n #GSocketClient::event signal for more details.\n\n Additional values may be added to this type in the future.\n\n Since: 2.32"]
pub type GSocketClientEvent = ::std::os::raw::c_uint;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BINDING: GSocketListenerEvent = 0;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BOUND: GSocketListenerEvent = 1;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENING: GSocketListenerEvent = 2;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENED: GSocketListenerEvent = 3;
#[doc = " GSocketListenerEvent:\n @G_SOCKET_LISTENER_BINDING: The listener is about to bind a socket.\n @G_SOCKET_LISTENER_BOUND: The listener has bound a socket.\n @G_SOCKET_LISTENER_LISTENING: The listener is about to start\n    listening on this socket.\n @G_SOCKET_LISTENER_LISTENED: The listener is now listening on\n   this socket.\n\n Describes an event occurring on a #GSocketListener. See the\n #GSocketListener::event signal for more details.\n\n Additional values may be added to this type in the future.\n\n Since: 2.46"]
pub type GSocketListenerEvent = ::std::os::raw::c_uint;
pub const GTestDBusFlags_G_TEST_DBUS_NONE: GTestDBusFlags = 0;
#[doc = " GTestDBusFlags:\n @G_TEST_DBUS_NONE: No flags.\n\n Flags to define future #GTestDBus behaviour.\n\n Since: 2.34"]
pub type GTestDBusFlags = ::std::os::raw::c_uint;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_NONE: GSubprocessFlags = 0;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_PIPE: GSubprocessFlags = 1;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_INHERIT: GSubprocessFlags = 2;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_PIPE: GSubprocessFlags = 4;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_SILENCE: GSubprocessFlags = 8;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_PIPE: GSubprocessFlags = 16;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_SILENCE: GSubprocessFlags = 32;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_MERGE: GSubprocessFlags = 64;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_INHERIT_FDS: GSubprocessFlags = 128;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: GSubprocessFlags = 256;
#[doc = " GSubprocessFlags:\n @G_SUBPROCESS_FLAGS_NONE: No flags.\n @G_SUBPROCESS_FLAGS_STDIN_PIPE: create a pipe for the stdin of the\n   spawned process that can be accessed with\n   g_subprocess_get_stdin_pipe().\n @G_SUBPROCESS_FLAGS_STDIN_INHERIT: stdin is inherited from the\n   calling process.\n @G_SUBPROCESS_FLAGS_STDOUT_PIPE: create a pipe for the stdout of the\n   spawned process that can be accessed with\n   g_subprocess_get_stdout_pipe().\n @G_SUBPROCESS_FLAGS_STDOUT_SILENCE: silence the stdout of the spawned\n   process (ie: redirect to `/dev/null`).\n @G_SUBPROCESS_FLAGS_STDERR_PIPE: create a pipe for the stderr of the\n   spawned process that can be accessed with\n   g_subprocess_get_stderr_pipe().\n @G_SUBPROCESS_FLAGS_STDERR_SILENCE: silence the stderr of the spawned\n   process (ie: redirect to `/dev/null`).\n @G_SUBPROCESS_FLAGS_STDERR_MERGE: merge the stderr of the spawned\n   process with whatever the stdout happens to be.  This is a good way\n   of directing both streams to a common log file, for example.\n @G_SUBPROCESS_FLAGS_INHERIT_FDS: spawned processes will inherit the\n   file descriptors of their parent, unless those descriptors have\n   been explicitly marked as close-on-exec.  This flag has no effect\n   over the \"standard\" file descriptors (stdin, stdout, stderr).\n @G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: if path searching is\n   needed when spawning the subprocess, use the `PATH` in the launcher\n   environment. (Since: 2.72)\n\n Flags to define the behaviour of a #GSubprocess.\n\n Note that the default for stdin is to redirect from `/dev/null`.  For\n stdout and stderr the default are for them to inherit the\n corresponding descriptor from the calling process.\n\n Note that it is a programmer error to mix 'incompatible' flags.  For\n example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and\n %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.\n\n Since: 2.40"]
pub type GSubprocessFlags = ::std::os::raw::c_uint;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_NORMAL: GNotificationPriority = 0;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_LOW: GNotificationPriority = 1;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_HIGH: GNotificationPriority = 2;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_URGENT: GNotificationPriority = 3;
#[doc = " GNotificationPriority:\n @G_NOTIFICATION_PRIORITY_LOW: for notifications that do not require\n   immediate attention - typically used for contextual background\n   information, such as contact birthdays or local weather\n @G_NOTIFICATION_PRIORITY_NORMAL: the default priority, to be used for the\n   majority of notifications (for example email messages, software updates,\n   completed download/sync operations)\n @G_NOTIFICATION_PRIORITY_HIGH: for events that require more attention,\n   usually because responses are time-sensitive (for example chat and SMS\n   messages or alarms)\n @G_NOTIFICATION_PRIORITY_URGENT: for urgent notifications, or notifications\n   that require a response in a short space of time (for example phone calls\n   or emergency warnings)\n\n Priority levels for #GNotifications.\n\n Since: 2.42"]
pub type GNotificationPriority = ::std::os::raw::c_uint;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LOCAL: GNetworkConnectivity = 1;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LIMITED: GNetworkConnectivity = 2;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_PORTAL: GNetworkConnectivity = 3;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_FULL: GNetworkConnectivity = 4;
#[doc = " GNetworkConnectivity:\n @G_NETWORK_CONNECTIVITY_LOCAL: The host is not configured with a\n   route to the Internet; it may or may not be connected to a local\n   network.\n @G_NETWORK_CONNECTIVITY_LIMITED: The host is connected to a network, but\n   does not appear to be able to reach the full Internet, perhaps\n   due to upstream network problems.\n @G_NETWORK_CONNECTIVITY_PORTAL: The host is behind a captive portal and\n   cannot reach the full Internet.\n @G_NETWORK_CONNECTIVITY_FULL: The host is connected to a network, and\n   appears to be able to reach the full Internet.\n\n The host's network connectivity state, as reported by #GNetworkMonitor.\n\n Since: 2.44"]
pub type GNetworkConnectivity = ::std::os::raw::c_uint;
pub const GPollableReturn_G_POLLABLE_RETURN_FAILED: GPollableReturn = 0;
pub const GPollableReturn_G_POLLABLE_RETURN_OK: GPollableReturn = 1;
pub const GPollableReturn_G_POLLABLE_RETURN_WOULD_BLOCK: GPollableReturn = -27;
#[doc = " GPollableReturn:\n @G_POLLABLE_RETURN_FAILED: Generic error condition for when an operation fails.\n @G_POLLABLE_RETURN_OK: The operation was successfully finished.\n @G_POLLABLE_RETURN_WOULD_BLOCK: The operation would block.\n\n Return value for various IO operations that signal errors via the\n return value and not necessarily via a #GError.\n\n This enum exists to be able to return errors to callers without having to\n allocate a #GError. Allocating #GErrors can be quite expensive for\n regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.\n\n In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the\n operation to give details about the error that happened.\n\n Since: 2.60"]
pub type GPollableReturn = ::std::os::raw::c_int;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_LOW:
    GMemoryMonitorWarningLevel = 50;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM:
    GMemoryMonitorWarningLevel = 100;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL:
    GMemoryMonitorWarningLevel = 255;
#[doc = " GMemoryMonitorWarningLevel:\n @G_MEMORY_MONITOR_WARNING_LEVEL_LOW: Memory on the device is low, processes\n   should free up unneeded resources (for example, in-memory caches) so they can\n   be used elsewhere.\n @G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM: Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW\n   but the device has even less free memory, so processes should try harder to free\n   up unneeded resources. If your process does not need to stay running, it is a\n   good time for it to quit.\n @G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL: The system will soon start terminating\n   processes to reclaim memory, including background processes.\n\n Memory availability warning levels.\n\n Note that because new values might be added, it is recommended that applications check\n #GMemoryMonitorWarningLevel as ranges, for example:\n |[<!-- language=\"C\" -->\n if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)\n   drop_caches ();\n ]|\n\n Since: 2.64"]
pub type GMemoryMonitorWarningLevel = ::std::os::raw::c_uint;
#[doc = " GAppLaunchContext:\n\n Integrating the launch with the launching application. This is used to\n handle for instance startup notification and launching the new application\n on the same screen as the launching window."]
pub type GAppLaunchContext = _GAppLaunchContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfo {
    _unused: [u8; 0],
}
pub type GAppInfo = _GAppInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResult {
    _unused: [u8; 0],
}
pub type GAsyncResult = _GAsyncResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitable {
    _unused: [u8; 0],
}
pub type GAsyncInitable = _GAsyncInitable;
pub type GBufferedInputStream = _GBufferedInputStream;
pub type GBufferedOutputStream = _GBufferedOutputStream;
pub type GCancellable = _GCancellable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverter {
    _unused: [u8; 0],
}
pub type GCharsetConverter = _GCharsetConverter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverter {
    _unused: [u8; 0],
}
pub type GConverter = _GConverter;
pub type GConverterInputStream = _GConverterInputStream;
pub type GConverterOutputStream = _GConverterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBased {
    _unused: [u8; 0],
}
pub type GDatagramBased = _GDatagramBased;
pub type GDataInputStream = _GDataInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimplePermission {
    _unused: [u8; 0],
}
pub type GSimplePermission = _GSimplePermission;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressor {
    _unused: [u8; 0],
}
pub type GZlibCompressor = _GZlibCompressor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressor {
    _unused: [u8; 0],
}
pub type GZlibDecompressor = _GZlibDecompressor;
pub type GSimpleActionGroup = _GSimpleActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroup {
    _unused: [u8; 0],
}
pub type GRemoteActionGroup = _GRemoteActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusActionGroup {
    _unused: [u8; 0],
}
pub type GDBusActionGroup = _GDBusActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMap {
    _unused: [u8; 0],
}
pub type GActionMap = _GActionMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroup {
    _unused: [u8; 0],
}
pub type GActionGroup = _GActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPropertyAction {
    _unused: [u8; 0],
}
pub type GPropertyAction = _GPropertyAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAction {
    _unused: [u8; 0],
}
pub type GSimpleAction = _GSimpleAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAction {
    _unused: [u8; 0],
}
pub type GAction = _GAction;
pub type GApplication = _GApplication;
pub type GApplicationCommandLine = _GApplicationCommandLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsBackend {
    _unused: [u8; 0],
}
pub type GSettingsBackend = _GSettingsBackend;
pub type GSettings = _GSettings;
pub type GPermission = _GPermission;
pub type GMenuModel = _GMenuModel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNotification {
    _unused: [u8; 0],
}
pub type GNotification = _GNotification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDrive {
    _unused: [u8; 0],
}
pub type GDrive = _GDrive;
pub type GFileEnumerator = _GFileEnumerator;
pub type GFileMonitor = _GFileMonitor;
pub type GFilterInputStream = _GFilterInputStream;
pub type GFilterOutputStream = _GFilterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFile {
    _unused: [u8; 0],
}
pub type GFile = _GFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfo {
    _unused: [u8; 0],
}
pub type GFileInfo = _GFileInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeMatcher {
    _unused: [u8; 0],
}
#[doc = " GFileAttributeMatcher:\n\n Determines if a string matches a file attribute."]
pub type GFileAttributeMatcher = _GFileAttributeMatcher;
#[doc = " GFileAttributeInfo:\n @name: the name of the attribute.\n @type: the #GFileAttributeType type of the attribute.\n @flags: a set of #GFileAttributeInfoFlags.\n\n Information about a specific attribute."]
pub type GFileAttributeInfo = _GFileAttributeInfo;
#[doc = " GFileAttributeInfoList:\n @infos: an array of #GFileAttributeInfos.\n @n_infos: the number of values in the array.\n\n Acts as a lightweight registry for possible valid file attributes.\n The registry stores Key-Value pair formats as #GFileAttributeInfos."]
pub type GFileAttributeInfoList = _GFileAttributeInfoList;
pub type GFileInputStream = _GFileInputStream;
pub type GFileOutputStream = _GFileOutputStream;
pub type GFileIOStream = _GFileIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIcon {
    _unused: [u8; 0],
}
pub type GFileIcon = _GFileIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleter {
    _unused: [u8; 0],
}
pub type GFilenameCompleter = _GFilenameCompleter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIcon {
    _unused: [u8; 0],
}
pub type GIcon = _GIcon;
pub type GInetAddress = _GInetAddress;
pub type GInetAddressMask = _GInetAddressMask;
pub type GInetSocketAddress = _GInetSocketAddress;
pub type GNativeSocketAddress = _GNativeSocketAddress;
pub type GInputStream = _GInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitable {
    _unused: [u8; 0],
}
pub type GInitable = _GInitable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModule {
    _unused: [u8; 0],
}
pub type GIOModule = _GIOModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtensionPoint {
    _unused: [u8; 0],
}
pub type GIOExtensionPoint = _GIOExtensionPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtension {
    _unused: [u8; 0],
}
pub type GIOExtension = _GIOExtension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOSchedulerJob {
    _unused: [u8; 0],
}
#[doc = " GIOSchedulerJob:\n\n Opaque class for defining and scheduling IO jobs.\n\n Deprecated: 2.36: Use [struct@GLib.ThreadPool] or\n   [method@Gio.Task.run_in_thread]"]
pub type GIOSchedulerJob = _GIOSchedulerJob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamAdapter {
    _unused: [u8; 0],
}
pub type GIOStreamAdapter = _GIOStreamAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIcon {
    _unused: [u8; 0],
}
pub type GLoadableIcon = _GLoadableIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytesIcon {
    _unused: [u8; 0],
}
pub type GBytesIcon = _GBytesIcon;
pub type GMemoryInputStream = _GMemoryInputStream;
pub type GMemoryOutputStream = _GMemoryOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMount {
    _unused: [u8; 0],
}
pub type GMount = _GMount;
pub type GMountOperation = _GMountOperation;
pub type GNetworkAddress = _GNetworkAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitor {
    _unused: [u8; 0],
}
pub type GNetworkMonitor = _GNetworkMonitor;
pub type GNetworkService = _GNetworkService;
pub type GOutputStream = _GOutputStream;
pub type GIOStream = _GIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleIOStream {
    _unused: [u8; 0],
}
pub type GSimpleIOStream = _GSimpleIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStream {
    _unused: [u8; 0],
}
pub type GPollableInputStream = _GPollableInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStream {
    _unused: [u8; 0],
}
pub type GPollableOutputStream = _GPollableOutputStream;
pub type GResolver = _GResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResource {
    _unused: [u8; 0],
}
pub type GResource = _GResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekable {
    _unused: [u8; 0],
}
pub type GSeekable = _GSeekable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResult {
    _unused: [u8; 0],
}
pub type GSimpleAsyncResult = _GSimpleAsyncResult;
pub type GSocket = _GSocket;
pub type GSocketControlMessage = _GSocketControlMessage;
pub type GSocketClient = _GSocketClient;
pub type GSocketConnection = _GSocketConnection;
pub type GSocketListener = _GSocketListener;
pub type GSocketService = _GSocketService;
pub type GSocketAddress = _GSocketAddress;
pub type GSocketAddressEnumerator = _GSocketAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectable {
    _unused: [u8; 0],
}
pub type GSocketConnectable = _GSocketConnectable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSrvTarget {
    _unused: [u8; 0],
}
pub type GSrvTarget = _GSrvTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTask {
    _unused: [u8; 0],
}
pub type GTask = _GTask;
pub type GTcpConnection = _GTcpConnection;
pub type GTcpWrapperConnection = _GTcpWrapperConnection;
pub type GThreadedSocketService = _GThreadedSocketService;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnection {
    _unused: [u8; 0],
}
pub type GDtlsConnection = _GDtlsConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnection {
    _unused: [u8; 0],
}
pub type GDtlsClientConnection = _GDtlsClientConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnection {
    _unused: [u8; 0],
}
pub type GDtlsServerConnection = _GDtlsServerConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIcon {
    _unused: [u8; 0],
}
pub type GThemedIcon = _GThemedIcon;
pub type GTlsCertificate = _GTlsCertificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnection {
    _unused: [u8; 0],
}
pub type GTlsClientConnection = _GTlsClientConnection;
pub type GTlsConnection = _GTlsConnection;
pub type GTlsDatabase = _GTlsDatabase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabase {
    _unused: [u8; 0],
}
pub type GTlsFileDatabase = _GTlsFileDatabase;
pub type GTlsInteraction = _GTlsInteraction;
pub type GTlsPassword = _GTlsPassword;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnection {
    _unused: [u8; 0],
}
pub type GTlsServerConnection = _GTlsServerConnection;
pub type GVfs = _GVfs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolver {
    _unused: [u8; 0],
}
pub type GProxyResolver = _GProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxy {
    _unused: [u8; 0],
}
pub type GProxy = _GProxy;
pub type GProxyAddress = _GProxyAddress;
pub type GProxyAddressEnumerator = _GProxyAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolume {
    _unused: [u8; 0],
}
pub type GVolume = _GVolume;
pub type GVolumeMonitor = _GVolumeMonitor;
#[doc = " GAsyncReadyCallback:\n @source_object: (nullable): the object the asynchronous operation was started with.\n @res: a #GAsyncResult.\n @data: user data passed to the callback.\n\n Type definition for a function that will be called back when an asynchronous\n operation within GIO has been completed. #GAsyncReadyCallback\n callbacks from #GTask are guaranteed to be invoked in a later\n iteration of the\n [thread-default main context][g-main-context-push-thread-default]\n where the #GTask was created. All other users of\n #GAsyncReadyCallback must likewise call it asynchronously in a\n later iteration of the main context.\n\n The asynchronous operation is guaranteed to have held a reference to\n @source_object from the time when the `*_async()` function was called, until\n after this callback returns."]
pub type GAsyncReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(source_object: *mut GObject, res: *mut GAsyncResult, data: gpointer),
>;
#[doc = " GFileProgressCallback:\n @current_num_bytes: the current number of bytes in the operation.\n @total_num_bytes: the total number of bytes in the operation.\n @data: user data passed to the callback.\n\n When doing file operations that may take a while, such as moving\n a file or copying a file, a progress callback is used to pass how\n far along that operation is to the application."]
pub type GFileProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(current_num_bytes: goffset, total_num_bytes: goffset, data: gpointer),
>;
#[doc = " GFileReadMoreCallback:\n @file_contents: the data as currently read.\n @file_size: the size of the data currently read.\n @callback_data: data passed to the callback.\n\n When loading the partial contents of a file with g_file_load_partial_contents_async(),\n it may become necessary to determine if any more data from the file should be loaded.\n A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data\n should be read, or %FALSE otherwise.\n\n Returns: %TRUE if more data should be read back. %FALSE otherwise."]
pub type GFileReadMoreCallback = ::std::option::Option<
    unsafe extern "C" fn(
        file_contents: *const ::std::os::raw::c_char,
        file_size: goffset,
        callback_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GFileMeasureProgressCallback:\n @reporting: %TRUE if more reports will come\n @current_size: the current cumulative size measurement\n @num_dirs: the number of directories visited so far\n @num_files: the number of non-directory files encountered\n @data: the data passed to the original request for this callback\n\n This callback type is used by g_file_measure_disk_usage() to make\n periodic progress reports when measuring the amount of disk spaced\n used by a directory.\n\n These calls are made on a best-effort basis and not all types of\n #GFile will support them.  At the minimum, however, one call will\n always be made immediately.\n\n In the case that there is no support, @reporting will be set to\n %FALSE (and the other values undefined) and no further calls will be\n made.  Otherwise, the @reporting will be %TRUE and the other values\n all-zeros during the first (immediate) call.  In this way, you can\n know which type of progress UI to show without a delay.\n\n For g_file_measure_disk_usage() the callback is made directly.  For\n g_file_measure_disk_usage_async() the callback is made via the\n default main context of the calling thread (ie: the same way that the\n final async result would be reported).\n\n @current_size is in the same units as requested by the operation (see\n %G_FILE_MEASURE_APPARENT_SIZE).\n\n The frequency of the updates is implementation defined, but is\n ideally about once every 200ms.\n\n The last progress callback may or may not be equal to the final\n result.  Always check the async result to get the final value.\n\n Since: 2.38"]
pub type GFileMeasureProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        reporting: gboolean,
        current_size: guint64,
        num_dirs: guint64,
        num_files: guint64,
        data: gpointer,
    ),
>;
#[doc = " GIOSchedulerJobFunc:\n @job: a #GIOSchedulerJob.\n @cancellable: optional #GCancellable object, %NULL to ignore.\n @data: data passed to the callback function\n\n I/O Job function.\n\n Long-running jobs should periodically check the @cancellable\n to see if they have been cancelled.\n\n Returns: %TRUE if this function should be called again to\n    complete the job, %FALSE if the job is complete (or cancelled)\n Deprecated: 2.36: Use [struct@GLib.ThreadPool] or\n   [method@Gio.Task.run_in_thread]"]
pub type GIOSchedulerJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        job: *mut GIOSchedulerJob,
        cancellable: *mut GCancellable,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSimpleAsyncThreadFunc:\n @res: a #GSimpleAsyncResult.\n @object: a #GObject.\n @cancellable: optional #GCancellable object, %NULL to ignore.\n\n Simple thread function that runs an asynchronous operation and\n checks for cancellation."]
pub type GSimpleAsyncThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        res: *mut GSimpleAsyncResult,
        object: *mut GObject,
        cancellable: *mut GCancellable,
    ),
>;
#[doc = " GSocketSourceFunc:\n @socket: the #GSocket\n @condition: the current condition at the source fired.\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_socket_create_source().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.22"]
pub type GSocketSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(socket: *mut GSocket, condition: GIOCondition, data: gpointer) -> gboolean,
>;
#[doc = " GDatagramBasedSourceFunc:\n @datagram_based: the #GDatagramBased\n @condition: the current condition at the source fired\n @data: data passed in by the user\n\n This is the function type of the callback used for the #GSource\n returned by g_datagram_based_create_source().\n\n Returns: %G_SOURCE_REMOVE if the source should be removed,\n   %G_SOURCE_CONTINUE otherwise\n\n Since: 2.48"]
pub type GDatagramBasedSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GInputVector:\n @buffer: Pointer to a buffer where data will be written.\n @size: the available size in @buffer.\n\n Structure used for scatter/gather data input.\n You generally pass in an array of #GInputVectors\n and the operation will store the read data starting in the\n first buffer, switching to the next as needed.\n\n Since: 2.22"]
pub type GInputVector = _GInputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputVector {
    pub buffer: gpointer,
    pub size: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInputVector"][::std::mem::size_of::<_GInputVector>() - 16usize];
    ["Alignment of _GInputVector"][::std::mem::align_of::<_GInputVector>() - 8usize];
    ["Offset of field: _GInputVector::buffer"]
        [::std::mem::offset_of!(_GInputVector, buffer) - 0usize];
    ["Offset of field: _GInputVector::size"][::std::mem::offset_of!(_GInputVector, size) - 8usize];
};
#[doc = " GInputMessage:\n @address: (optional) (out) (transfer full): return location\n   for a #GSocketAddress, or %NULL\n @vectors: (array length=num_vectors) (out): pointer to an\n   array of input vectors\n @num_vectors: the number of input vectors pointed to by @vectors\n @bytes_received: (out): will be set to the number of bytes that have been\n   received\n @flags: (out): collection of #GSocketMsgFlags for the received message,\n   outputted by the call\n @control_messages: (array length=num_control_messages) (optional)\n   (out) (transfer full): return location for a\n   caller-allocated array of #GSocketControlMessages, or %NULL\n @num_control_messages: (out) (optional): return location for the number of\n   elements in @control_messages\n\n Structure used for scatter/gather data input when receiving multiple\n messages or packets in one go. You generally pass in an array of empty\n #GInputVectors and the operation will use all the buffers as if they\n were one buffer, and will set @bytes_received to the total number of bytes\n received across all #GInputVectors.\n\n This structure closely mirrors `struct mmsghdr` and `struct msghdr` from\n the POSIX sockets API (see `man 2 recvmmsg`).\n\n If @address is non-%NULL then it is set to the source address the message\n was received from, and the caller must free it afterwards.\n\n If @control_messages is non-%NULL then it is set to an array of control\n messages received with the message (if any), and the caller must free it\n afterwards. @num_control_messages is set to the number of elements in\n this array, which may be zero.\n\n Flags relevant to this message will be returned in @flags. For example,\n `MSG_EOR` or `MSG_TRUNC`.\n\n Since: 2.48"]
pub type GInputMessage = _GInputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputMessage {
    pub address: *mut *mut GSocketAddress,
    pub vectors: *mut GInputVector,
    pub num_vectors: guint,
    pub bytes_received: gsize,
    pub flags: gint,
    pub control_messages: *mut *mut *mut GSocketControlMessage,
    pub num_control_messages: *mut guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInputMessage"][::std::mem::size_of::<_GInputMessage>() - 56usize];
    ["Alignment of _GInputMessage"][::std::mem::align_of::<_GInputMessage>() - 8usize];
    ["Offset of field: _GInputMessage::address"]
        [::std::mem::offset_of!(_GInputMessage, address) - 0usize];
    ["Offset of field: _GInputMessage::vectors"]
        [::std::mem::offset_of!(_GInputMessage, vectors) - 8usize];
    ["Offset of field: _GInputMessage::num_vectors"]
        [::std::mem::offset_of!(_GInputMessage, num_vectors) - 16usize];
    ["Offset of field: _GInputMessage::bytes_received"]
        [::std::mem::offset_of!(_GInputMessage, bytes_received) - 24usize];
    ["Offset of field: _GInputMessage::flags"]
        [::std::mem::offset_of!(_GInputMessage, flags) - 32usize];
    ["Offset of field: _GInputMessage::control_messages"]
        [::std::mem::offset_of!(_GInputMessage, control_messages) - 40usize];
    ["Offset of field: _GInputMessage::num_control_messages"]
        [::std::mem::offset_of!(_GInputMessage, num_control_messages) - 48usize];
};
#[doc = " GOutputVector:\n @buffer: Pointer to a buffer of data to read.\n @size: the size of @buffer.\n\n Structure used for scatter/gather data output.\n You generally pass in an array of #GOutputVectors\n and the operation will use all the buffers as if they were\n one buffer.\n\n Since: 2.22"]
pub type GOutputVector = _GOutputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputVector {
    pub buffer: gconstpointer,
    pub size: gsize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOutputVector"][::std::mem::size_of::<_GOutputVector>() - 16usize];
    ["Alignment of _GOutputVector"][::std::mem::align_of::<_GOutputVector>() - 8usize];
    ["Offset of field: _GOutputVector::buffer"]
        [::std::mem::offset_of!(_GOutputVector, buffer) - 0usize];
    ["Offset of field: _GOutputVector::size"]
        [::std::mem::offset_of!(_GOutputVector, size) - 8usize];
};
#[doc = " GOutputMessage:\n @address: (nullable): a #GSocketAddress, or %NULL\n @vectors: pointer to an array of output vectors\n @num_vectors: the number of output vectors pointed to by @vectors.\n @bytes_sent: initialize to 0. Will be set to the number of bytes\n     that have been sent\n @control_messages: (array length=num_control_messages) (nullable): a pointer\n   to an array of #GSocketControlMessages, or %NULL.\n @num_control_messages: number of elements in @control_messages.\n\n Structure used for scatter/gather data output when sending multiple\n messages or packets in one go. You generally pass in an array of\n #GOutputVectors and the operation will use all the buffers as if they\n were one buffer.\n\n If @address is %NULL then the message is sent to the default receiver\n (as previously set by g_socket_connect()).\n\n Since: 2.44"]
pub type GOutputMessage = _GOutputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: guint,
    pub bytes_sent: guint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOutputMessage"][::std::mem::size_of::<_GOutputMessage>() - 40usize];
    ["Alignment of _GOutputMessage"][::std::mem::align_of::<_GOutputMessage>() - 8usize];
    ["Offset of field: _GOutputMessage::address"]
        [::std::mem::offset_of!(_GOutputMessage, address) - 0usize];
    ["Offset of field: _GOutputMessage::vectors"]
        [::std::mem::offset_of!(_GOutputMessage, vectors) - 8usize];
    ["Offset of field: _GOutputMessage::num_vectors"]
        [::std::mem::offset_of!(_GOutputMessage, num_vectors) - 16usize];
    ["Offset of field: _GOutputMessage::bytes_sent"]
        [::std::mem::offset_of!(_GOutputMessage, bytes_sent) - 20usize];
    ["Offset of field: _GOutputMessage::control_messages"]
        [::std::mem::offset_of!(_GOutputMessage, control_messages) - 24usize];
    ["Offset of field: _GOutputMessage::num_control_messages"]
        [::std::mem::offset_of!(_GOutputMessage, num_control_messages) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentials {
    _unused: [u8; 0],
}
pub type GCredentials = _GCredentials;
pub type GUnixCredentialsMessage = _GUnixCredentialsMessage;
pub type GUnixFDList = _GUnixFDList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMessage {
    _unused: [u8; 0],
}
pub type GDBusMessage = _GDBusMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusConnection {
    _unused: [u8; 0],
}
pub type GDBusConnection = _GDBusConnection;
pub type GDBusProxy = _GDBusProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInvocation {
    _unused: [u8; 0],
}
pub type GDBusMethodInvocation = _GDBusMethodInvocation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusServer {
    _unused: [u8; 0],
}
pub type GDBusServer = _GDBusServer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAuthObserver {
    _unused: [u8; 0],
}
pub type GDBusAuthObserver = _GDBusAuthObserver;
#[doc = " GDBusErrorEntry:\n @error_code: An error code.\n @dbus_error_name: The D-Bus error name to associate with @error_code.\n\n Struct used in g_dbus_error_register_error_domain().\n\n Since: 2.26"]
pub type GDBusErrorEntry = _GDBusErrorEntry;
#[doc = " GDBusInterfaceVTable:\n @method_call: Function for handling incoming method calls.\n @get_property: Function for getting a property.\n @set_property: Function for setting a property.\n\n Virtual table for handling properties and method calls for a D-Bus\n interface.\n\n Since 2.38, if you want to handle getting/setting D-Bus properties\n asynchronously, give %NULL as your get_property() or set_property()\n function. The D-Bus call will be directed to your @method_call function,\n with the provided @interface_name set to \"org.freedesktop.DBus.Properties\".\n\n Ownership of the #GDBusMethodInvocation object passed to the\n method_call() function is transferred to your handler; you must\n call one of the methods of #GDBusMethodInvocation to return a reply\n (possibly empty), or an error. These functions also take ownership\n of the passed-in invocation object, so unless the invocation\n object has otherwise been referenced, it will be then be freed.\n Calling one of these functions may be done within your\n method_call() implementation but it also can be done at a later\n point to handle the method asynchronously.\n\n The usual checks on the validity of the calls is performed. For\n `Get` calls, an error is automatically returned if the property does\n not exist or the permissions do not allow access. The same checks are\n performed for `Set` calls, and the provided value is also checked for\n being the correct type.\n\n For both `Get` and `Set` calls, the #GDBusMethodInvocation\n passed to the @method_call handler can be queried with\n g_dbus_method_invocation_get_property_info() to get a pointer\n to the #GDBusPropertyInfo of the property.\n\n If you have readable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @get_property()\n function or provide implementations of both the `Get` and `GetAll`\n methods on org.freedesktop.DBus.Properties interface in your @method_call\n function. Note that the required return type of the `Get` call is\n `(v)`, not the type of the property. `GetAll` expects a return value\n of type `a{sv}`.\n\n If you have writable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @set_property()\n function or provide an implementation of the `Set` call. If implementing\n the call, you must return the value of type %G_VARIANT_TYPE_UNIT.\n\n Since: 2.26"]
pub type GDBusInterfaceVTable = _GDBusInterfaceVTable;
#[doc = " GDBusSubtreeVTable:\n @enumerate: Function for enumerating child nodes.\n @introspect: Function for introspecting a child node.\n @dispatch: Function for dispatching a remote call on a child node.\n\n Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().\n\n Since: 2.26"]
pub type GDBusSubtreeVTable = _GDBusSubtreeVTable;
#[doc = " GDBusAnnotationInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @key: The name of the annotation, e.g. \"org.freedesktop.DBus.Deprecated\".\n @value: The value of the annotation.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an annotation.\n\n Since: 2.26"]
pub type GDBusAnnotationInfo = _GDBusAnnotationInfo;
#[doc = " GDBusArgInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: Name of the argument, e.g. @unix_user_id.\n @signature: D-Bus signature of the argument (a single complete type).\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an argument for a method or a signal.\n\n Since: 2.26"]
pub type GDBusArgInfo = _GDBusArgInfo;
#[doc = " GDBusMethodInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus method, e.g. @RequestName.\n @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.\n @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a method on an D-Bus interface.\n\n Since: 2.26"]
pub type GDBusMethodInfo = _GDBusMethodInfo;
#[doc = " GDBusSignalInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus signal, e.g. \"NameOwnerChanged\".\n @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a signal on a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusSignalInfo = _GDBusSignalInfo;
#[doc = " GDBusPropertyInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus property, e.g. \"SupportedFilesystems\".\n @signature: The D-Bus signature of the property (a single complete type).\n @flags: Access control flags for the property.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus property on a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusPropertyInfo = _GDBusPropertyInfo;
#[doc = " GDBusInterfaceInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus interface, e.g. \"org.freedesktop.DBus.Properties\".\n @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.\n @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.\n @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusInterfaceInfo = _GDBusInterfaceInfo;
#[doc = " GDBusNodeInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.\n @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.\n @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about nodes in a remote object hierarchy.\n\n Since: 2.26"]
pub type GDBusNodeInfo = _GDBusNodeInfo;
#[doc = " GCancellableSourceFunc:\n @cancellable: the #GCancellable\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_cancellable_source_new().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.28"]
pub type GCancellableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(cancellable: *mut GCancellable, data: gpointer) -> gboolean,
>;
#[doc = " GPollableSourceFunc:\n @pollable_stream: the #GPollableInputStream or #GPollableOutputStream\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_pollable_input_stream_create_source() and\n g_pollable_output_stream_create_source().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.28"]
pub type GPollableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(pollable_stream: *mut GObject, data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterface {
    _unused: [u8; 0],
}
pub type GDBusInterface = _GDBusInterface;
pub type GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObject {
    _unused: [u8; 0],
}
pub type GDBusObject = _GDBusObject;
pub type GDBusObjectSkeleton = _GDBusObjectSkeleton;
pub type GDBusObjectProxy = _GDBusObjectProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManager {
    _unused: [u8; 0],
}
pub type GDBusObjectManager = _GDBusObjectManager;
pub type GDBusObjectManagerClient = _GDBusObjectManagerClient;
pub type GDBusObjectManagerServer = _GDBusObjectManagerServer;
#[doc = " GDBusProxyTypeFunc:\n @manager: A #GDBusObjectManagerClient.\n @object_path: The object path of the remote object.\n @interface_name: (nullable): The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.\n @data: data passed in by the user.\n\n Function signature for a function used to determine the #GType to\n use for an interface proxy (if @interface_name is not %NULL) or\n object proxy (if @interface_name is %NULL).\n\n This function is called in the\n [thread-default main loop][g-main-context-push-thread-default]\n that @manager was constructed in.\n\n Returns: A #GType to use for the remote object. The returned type\n   must be a #GDBusProxy or #GDBusObjectProxy -derived\n   type.\n\n Since: 2.30"]
pub type GDBusProxyTypeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        manager: *mut GDBusObjectManagerClient,
        object_path: *const gchar,
        interface_name: *const gchar,
        data: gpointer,
    ) -> GType,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTestDBus {
    _unused: [u8; 0],
}
pub type GTestDBus = _GTestDBus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocess {
    _unused: [u8; 0],
}
pub type GSubprocess = _GSubprocess;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocessLauncher {
    _unused: [u8; 0],
}
pub type GSubprocessLauncher = _GSubprocessLauncher;
pub type GActionInterface = _GActionInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionInterface {
    pub g_iface: GTypeInterface,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const gchar>,
    pub get_parameter_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_hint:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub get_enabled: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> gboolean>,
    pub get_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub change_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, value: *mut GVariant)>,
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, parameter: *mut GVariant)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GActionInterface"][::std::mem::size_of::<_GActionInterface>() - 80usize];
    ["Alignment of _GActionInterface"][::std::mem::align_of::<_GActionInterface>() - 8usize];
    ["Offset of field: _GActionInterface::g_iface"]
        [::std::mem::offset_of!(_GActionInterface, g_iface) - 0usize];
    ["Offset of field: _GActionInterface::get_name"]
        [::std::mem::offset_of!(_GActionInterface, get_name) - 16usize];
    ["Offset of field: _GActionInterface::get_parameter_type"]
        [::std::mem::offset_of!(_GActionInterface, get_parameter_type) - 24usize];
    ["Offset of field: _GActionInterface::get_state_type"]
        [::std::mem::offset_of!(_GActionInterface, get_state_type) - 32usize];
    ["Offset of field: _GActionInterface::get_state_hint"]
        [::std::mem::offset_of!(_GActionInterface, get_state_hint) - 40usize];
    ["Offset of field: _GActionInterface::get_enabled"]
        [::std::mem::offset_of!(_GActionInterface, get_enabled) - 48usize];
    ["Offset of field: _GActionInterface::get_state"]
        [::std::mem::offset_of!(_GActionInterface, get_state) - 56usize];
    ["Offset of field: _GActionInterface::change_state"]
        [::std::mem::offset_of!(_GActionInterface, change_state) - 64usize];
    ["Offset of field: _GActionInterface::activate"]
        [::std::mem::offset_of!(_GActionInterface, activate) - 72usize];
};
unsafe extern "C" {
    pub fn g_action_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_action_get_name(action: *mut GAction) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_action_get_parameter_type(action: *mut GAction) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_action_get_state_type(action: *mut GAction) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
}
unsafe extern "C" {
    pub fn g_action_get_state(action: *mut GAction) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_action_change_state(action: *mut GAction, value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_action_activate(action: *mut GAction, parameter: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_action_name_is_valid(action_name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_action_parse_detailed_name(
        detailed_name: *const gchar,
        action_name: *mut *mut gchar,
        target_value: *mut *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_action_print_detailed_name(
        action_name: *const gchar,
        target_value: *mut GVariant,
    ) -> *mut gchar;
}
pub type GActionGroupInterface = _GActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub has_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> gboolean,
    >,
    pub list_actions: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup) -> *mut *mut gchar,
    >,
    pub get_action_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> gboolean,
    >,
    pub get_action_parameter_type: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *const GVariantType,
    >,
    pub get_action_state_type: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *const GVariantType,
    >,
    pub get_action_state_hint: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *mut GVariant,
    >,
    pub get_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *mut GVariant,
    >,
    pub change_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
        ),
    >,
    pub activate_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
        ),
    >,
    pub action_added: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_removed: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_enabled_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: gboolean,
        ),
    >,
    pub action_state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            state: *mut GVariant,
        ),
    >,
    pub query_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: *mut gboolean,
            parameter_type: *mut *const GVariantType,
            state_type: *mut *const GVariantType,
            state_hint: *mut *mut GVariant,
            state: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GActionGroupInterface"][::std::mem::size_of::<_GActionGroupInterface>() - 128usize];
    ["Alignment of _GActionGroupInterface"]
        [::std::mem::align_of::<_GActionGroupInterface>() - 8usize];
    ["Offset of field: _GActionGroupInterface::g_iface"]
        [::std::mem::offset_of!(_GActionGroupInterface, g_iface) - 0usize];
    ["Offset of field: _GActionGroupInterface::has_action"]
        [::std::mem::offset_of!(_GActionGroupInterface, has_action) - 16usize];
    ["Offset of field: _GActionGroupInterface::list_actions"]
        [::std::mem::offset_of!(_GActionGroupInterface, list_actions) - 24usize];
    ["Offset of field: _GActionGroupInterface::get_action_enabled"]
        [::std::mem::offset_of!(_GActionGroupInterface, get_action_enabled) - 32usize];
    ["Offset of field: _GActionGroupInterface::get_action_parameter_type"]
        [::std::mem::offset_of!(_GActionGroupInterface, get_action_parameter_type) - 40usize];
    ["Offset of field: _GActionGroupInterface::get_action_state_type"]
        [::std::mem::offset_of!(_GActionGroupInterface, get_action_state_type) - 48usize];
    ["Offset of field: _GActionGroupInterface::get_action_state_hint"]
        [::std::mem::offset_of!(_GActionGroupInterface, get_action_state_hint) - 56usize];
    ["Offset of field: _GActionGroupInterface::get_action_state"]
        [::std::mem::offset_of!(_GActionGroupInterface, get_action_state) - 64usize];
    ["Offset of field: _GActionGroupInterface::change_action_state"]
        [::std::mem::offset_of!(_GActionGroupInterface, change_action_state) - 72usize];
    ["Offset of field: _GActionGroupInterface::activate_action"]
        [::std::mem::offset_of!(_GActionGroupInterface, activate_action) - 80usize];
    ["Offset of field: _GActionGroupInterface::action_added"]
        [::std::mem::offset_of!(_GActionGroupInterface, action_added) - 88usize];
    ["Offset of field: _GActionGroupInterface::action_removed"]
        [::std::mem::offset_of!(_GActionGroupInterface, action_removed) - 96usize];
    ["Offset of field: _GActionGroupInterface::action_enabled_changed"]
        [::std::mem::offset_of!(_GActionGroupInterface, action_enabled_changed) - 104usize];
    ["Offset of field: _GActionGroupInterface::action_state_changed"]
        [::std::mem::offset_of!(_GActionGroupInterface, action_state_changed) - 112usize];
    ["Offset of field: _GActionGroupInterface::query_action"]
        [::std::mem::offset_of!(_GActionGroupInterface, query_action) - 120usize];
};
unsafe extern "C" {
    pub fn g_action_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_action_group_has_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_action_group_get_action_parameter_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_action_group_get_action_state_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_action_group_get_action_state_hint(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_action_group_get_action_enabled(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_action_group_get_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_action_group_change_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_action_group_activate_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_action_group_action_added(action_group: *mut GActionGroup, action_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_action_group_action_removed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_action_group_action_enabled_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_action_group_action_state_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        state: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_action_group_query_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: *mut gboolean,
        parameter_type: *mut *const GVariantType,
        state_type: *mut *const GVariantType,
        state_hint: *mut *mut GVariant,
        state: *mut *mut GVariant,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_export_action_group(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        action_group: *mut GActionGroup,
        error: *mut *mut GError,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_unexport_action_group(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
pub type GActionMapInterface = _GActionMapInterface;
pub type GActionEntry = _GActionEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMapInterface {
    pub g_iface: GTypeInterface,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_map: *mut GActionMap,
            action_name: *const gchar,
        ) -> *mut GAction,
    >,
    pub add_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action: *mut GAction),
    >,
    pub remove_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action_name: *const gchar),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GActionMapInterface"][::std::mem::size_of::<_GActionMapInterface>() - 40usize];
    ["Alignment of _GActionMapInterface"][::std::mem::align_of::<_GActionMapInterface>() - 8usize];
    ["Offset of field: _GActionMapInterface::g_iface"]
        [::std::mem::offset_of!(_GActionMapInterface, g_iface) - 0usize];
    ["Offset of field: _GActionMapInterface::lookup_action"]
        [::std::mem::offset_of!(_GActionMapInterface, lookup_action) - 16usize];
    ["Offset of field: _GActionMapInterface::add_action"]
        [::std::mem::offset_of!(_GActionMapInterface, add_action) - 24usize];
    ["Offset of field: _GActionMapInterface::remove_action"]
        [::std::mem::offset_of!(_GActionMapInterface, remove_action) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionEntry {
    pub name: *const gchar,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut GSimpleAction,
            parameter: *mut GVariant,
            user_data: gpointer,
        ),
    >,
    pub parameter_type: *const gchar,
    pub state: *const gchar,
    pub change_state: ::std::option::Option<
        unsafe extern "C" fn(action: *mut GSimpleAction, value: *mut GVariant, user_data: gpointer),
    >,
    pub padding: [gsize; 3usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GActionEntry"][::std::mem::size_of::<_GActionEntry>() - 64usize];
    ["Alignment of _GActionEntry"][::std::mem::align_of::<_GActionEntry>() - 8usize];
    ["Offset of field: _GActionEntry::name"][::std::mem::offset_of!(_GActionEntry, name) - 0usize];
    ["Offset of field: _GActionEntry::activate"]
        [::std::mem::offset_of!(_GActionEntry, activate) - 8usize];
    ["Offset of field: _GActionEntry::parameter_type"]
        [::std::mem::offset_of!(_GActionEntry, parameter_type) - 16usize];
    ["Offset of field: _GActionEntry::state"]
        [::std::mem::offset_of!(_GActionEntry, state) - 24usize];
    ["Offset of field: _GActionEntry::change_state"]
        [::std::mem::offset_of!(_GActionEntry, change_state) - 32usize];
    ["Offset of field: _GActionEntry::padding"]
        [::std::mem::offset_of!(_GActionEntry, padding) - 40usize];
};
unsafe extern "C" {
    pub fn g_action_map_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_action_map_lookup_action(
        action_map: *mut GActionMap,
        action_name: *const gchar,
    ) -> *mut GAction;
}
unsafe extern "C" {
    pub fn g_action_map_add_action(action_map: *mut GActionMap, action: *mut GAction);
}
unsafe extern "C" {
    pub fn g_action_map_remove_action(action_map: *mut GActionMap, action_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_action_map_add_action_entries(
        action_map: *mut GActionMap,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_action_map_remove_action_entries(
        action_map: *mut GActionMap,
        entries: *const GActionEntry,
        n_entries: gint,
    );
}
pub type GAppLaunchContextClass = _GAppLaunchContextClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextPrivate {
    _unused: [u8; 0],
}
pub type GAppLaunchContextPrivate = _GAppLaunchContextPrivate;
#[doc = " GAppInfoIface:\n @g_iface: The parent interface.\n @dup: Copies a #GAppInfo.\n @equal: Checks two #GAppInfos for equality.\n @get_id: Gets a string identifier for a #GAppInfo.\n @get_name: Gets the name of the application for a #GAppInfo.\n @get_description: Gets a short description for the application described by the #GAppInfo.\n @get_executable: Gets the executable name for the #GAppInfo.\n @get_icon: Gets the #GIcon for the #GAppInfo.\n @launch: Launches an application specified by the #GAppInfo.\n @supports_uris: Indicates whether the application specified supports launching URIs.\n @supports_files: Indicates whether the application specified accepts filename arguments.\n @launch_uris: Launches an application with a list of URIs.\n @should_show: Returns whether an application should be shown (e.g. when getting a list of installed applications).\n [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).\n @set_as_default_for_type: Sets an application as default for a given content type.\n @set_as_default_for_extension: Sets an application as default for a given file extension.\n @add_supports_type: Adds to the #GAppInfo information about supported file types.\n @can_remove_supports_type: Checks for support for removing supported file types from a #GAppInfo.\n @remove_supports_type: Removes a supported application type from a #GAppInfo.\n @can_delete: Checks if a #GAppInfo can be deleted. Since 2.20\n @do_delete: Deletes a #GAppInfo. Since 2.20\n @get_commandline: Gets the commandline for the #GAppInfo. Since 2.20\n @get_display_name: Gets the display name for the #GAppInfo. Since 2.24\n @set_as_last_used_for_type: Sets the application as the last used. See g_app_info_set_as_last_used_for_type().\n @get_supported_types: Retrieves the list of content types that @app_info claims to support.\n @launch_uris_async: Asynchronously launches an application with a list of URIs. (Since: 2.60)\n @launch_uris_finish: Finishes an operation started with @launch_uris_async. (Since: 2.60)\n\n Application Information interface, for operating system portability."]
pub type GAppInfoIface = _GAppInfoIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GAppInfo>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean,
    >,
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_executable: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GIcon>,
    pub launch: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            files: *mut GList,
            context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_uris:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub supports_files:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub launch_uris: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub should_show:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub set_as_default_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_as_default_for_extension: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            extension: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub add_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_remove_supports_type:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub remove_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub do_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub get_commandline: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub set_as_last_used_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_supported_types: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut *const ::std::os::raw::c_char,
    >,
    pub launch_uris_async: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            context: *mut GAppLaunchContext,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub launch_uris_finish: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GAppInfoIface"][::std::mem::size_of::<_GAppInfoIface>() - 216usize];
    ["Alignment of _GAppInfoIface"][::std::mem::align_of::<_GAppInfoIface>() - 8usize];
    ["Offset of field: _GAppInfoIface::g_iface"]
        [::std::mem::offset_of!(_GAppInfoIface, g_iface) - 0usize];
    ["Offset of field: _GAppInfoIface::dup"][::std::mem::offset_of!(_GAppInfoIface, dup) - 16usize];
    ["Offset of field: _GAppInfoIface::equal"]
        [::std::mem::offset_of!(_GAppInfoIface, equal) - 24usize];
    ["Offset of field: _GAppInfoIface::get_id"]
        [::std::mem::offset_of!(_GAppInfoIface, get_id) - 32usize];
    ["Offset of field: _GAppInfoIface::get_name"]
        [::std::mem::offset_of!(_GAppInfoIface, get_name) - 40usize];
    ["Offset of field: _GAppInfoIface::get_description"]
        [::std::mem::offset_of!(_GAppInfoIface, get_description) - 48usize];
    ["Offset of field: _GAppInfoIface::get_executable"]
        [::std::mem::offset_of!(_GAppInfoIface, get_executable) - 56usize];
    ["Offset of field: _GAppInfoIface::get_icon"]
        [::std::mem::offset_of!(_GAppInfoIface, get_icon) - 64usize];
    ["Offset of field: _GAppInfoIface::launch"]
        [::std::mem::offset_of!(_GAppInfoIface, launch) - 72usize];
    ["Offset of field: _GAppInfoIface::supports_uris"]
        [::std::mem::offset_of!(_GAppInfoIface, supports_uris) - 80usize];
    ["Offset of field: _GAppInfoIface::supports_files"]
        [::std::mem::offset_of!(_GAppInfoIface, supports_files) - 88usize];
    ["Offset of field: _GAppInfoIface::launch_uris"]
        [::std::mem::offset_of!(_GAppInfoIface, launch_uris) - 96usize];
    ["Offset of field: _GAppInfoIface::should_show"]
        [::std::mem::offset_of!(_GAppInfoIface, should_show) - 104usize];
    ["Offset of field: _GAppInfoIface::set_as_default_for_type"]
        [::std::mem::offset_of!(_GAppInfoIface, set_as_default_for_type) - 112usize];
    ["Offset of field: _GAppInfoIface::set_as_default_for_extension"]
        [::std::mem::offset_of!(_GAppInfoIface, set_as_default_for_extension) - 120usize];
    ["Offset of field: _GAppInfoIface::add_supports_type"]
        [::std::mem::offset_of!(_GAppInfoIface, add_supports_type) - 128usize];
    ["Offset of field: _GAppInfoIface::can_remove_supports_type"]
        [::std::mem::offset_of!(_GAppInfoIface, can_remove_supports_type) - 136usize];
    ["Offset of field: _GAppInfoIface::remove_supports_type"]
        [::std::mem::offset_of!(_GAppInfoIface, remove_supports_type) - 144usize];
    ["Offset of field: _GAppInfoIface::can_delete"]
        [::std::mem::offset_of!(_GAppInfoIface, can_delete) - 152usize];
    ["Offset of field: _GAppInfoIface::do_delete"]
        [::std::mem::offset_of!(_GAppInfoIface, do_delete) - 160usize];
    ["Offset of field: _GAppInfoIface::get_commandline"]
        [::std::mem::offset_of!(_GAppInfoIface, get_commandline) - 168usize];
    ["Offset of field: _GAppInfoIface::get_display_name"]
        [::std::mem::offset_of!(_GAppInfoIface, get_display_name) - 176usize];
    ["Offset of field: _GAppInfoIface::set_as_last_used_for_type"]
        [::std::mem::offset_of!(_GAppInfoIface, set_as_last_used_for_type) - 184usize];
    ["Offset of field: _GAppInfoIface::get_supported_types"]
        [::std::mem::offset_of!(_GAppInfoIface, get_supported_types) - 192usize];
    ["Offset of field: _GAppInfoIface::launch_uris_async"]
        [::std::mem::offset_of!(_GAppInfoIface, launch_uris_async) - 200usize];
    ["Offset of field: _GAppInfoIface::launch_uris_finish"]
        [::std::mem::offset_of!(_GAppInfoIface, launch_uris_finish) - 208usize];
};
unsafe extern "C" {
    pub fn g_app_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_app_info_create_from_commandline(
        commandline: *const ::std::os::raw::c_char,
        application_name: *const ::std::os::raw::c_char,
        flags: GAppInfoCreateFlags,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_app_info_launch(
        appinfo: *mut GAppInfo,
        files: *mut GList,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_launch_uris(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_launch_uris_async(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_app_info_launch_uris_finish(
        appinfo: *mut GAppInfo,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_set_as_default_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_set_as_default_for_extension(
        appinfo: *mut GAppInfo,
        extension: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_add_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_remove_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_get_supported_types(
        appinfo: *mut GAppInfo,
    ) -> *mut *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_set_as_last_used_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_get_all() -> *mut GList;
}
unsafe extern "C" {
    pub fn g_app_info_get_all_for_type(content_type: *const ::std::os::raw::c_char) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_app_info_get_recommended_for_type(content_type: *const gchar) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_app_info_get_fallback_for_type(content_type: *const gchar) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_app_info_reset_type_associations(content_type: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_app_info_get_default_for_type(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_app_info_get_default_for_type_async(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_app_info_get_default_for_type_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme(
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme_async(
        uri_scheme: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_app_info_launch_default_for_uri(
        uri: *const ::std::os::raw::c_char,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_app_info_launch_default_for_uri_async(
        uri: *const ::std::os::raw::c_char,
        context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_app_info_launch_default_for_uri_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GAppLaunchContext:\n\n Integrating the launch with the launching application. This is used to\n handle for instance startup notification and launching the new application\n on the same screen as the launching window."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContext {
    pub parent_instance: GObject,
    pub priv_: *mut GAppLaunchContextPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GAppLaunchContext"][::std::mem::size_of::<_GAppLaunchContext>() - 32usize];
    ["Alignment of _GAppLaunchContext"][::std::mem::align_of::<_GAppLaunchContext>() - 8usize];
    ["Offset of field: _GAppLaunchContext::parent_instance"]
        [::std::mem::offset_of!(_GAppLaunchContext, parent_instance) - 0usize];
    ["Offset of field: _GAppLaunchContext::priv_"]
        [::std::mem::offset_of!(_GAppLaunchContext, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextClass {
    pub parent_class: GObjectClass,
    pub get_display: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub get_startup_notify_id: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub launch_failed: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            startup_notify_id: *const ::std::os::raw::c_char,
        ),
    >,
    pub launched: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub launch_started: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GAppLaunchContextClass"]
        [::std::mem::size_of::<_GAppLaunchContextClass>() - 200usize];
    ["Alignment of _GAppLaunchContextClass"]
        [::std::mem::align_of::<_GAppLaunchContextClass>() - 8usize];
    ["Offset of field: _GAppLaunchContextClass::parent_class"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, parent_class) - 0usize];
    ["Offset of field: _GAppLaunchContextClass::get_display"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, get_display) - 136usize];
    ["Offset of field: _GAppLaunchContextClass::get_startup_notify_id"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, get_startup_notify_id) - 144usize];
    ["Offset of field: _GAppLaunchContextClass::launch_failed"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, launch_failed) - 152usize];
    ["Offset of field: _GAppLaunchContextClass::launched"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, launched) - 160usize];
    ["Offset of field: _GAppLaunchContextClass::launch_started"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, launch_started) - 168usize];
    ["Offset of field: _GAppLaunchContextClass::_g_reserved1"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, _g_reserved1) - 176usize];
    ["Offset of field: _GAppLaunchContextClass::_g_reserved2"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, _g_reserved2) - 184usize];
    ["Offset of field: _GAppLaunchContextClass::_g_reserved3"]
        [::std::mem::offset_of!(_GAppLaunchContextClass, _g_reserved3) - 192usize];
};
unsafe extern "C" {
    pub fn g_app_launch_context_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
}
unsafe extern "C" {
    pub fn g_app_launch_context_setenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_app_launch_context_unsetenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_app_launch_context_get_environment(
        context: *mut GAppLaunchContext,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_launch_context_get_display(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_launch_context_get_startup_notify_id(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_app_launch_context_launch_failed(
        context: *mut GAppLaunchContext,
        startup_notify_id: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoMonitor {
    _unused: [u8; 0],
}
pub type GAppInfoMonitor = _GAppInfoMonitor;
unsafe extern "C" {
    pub fn g_app_info_monitor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationPrivate {
    _unused: [u8; 0],
}
pub type GApplicationPrivate = _GApplicationPrivate;
pub type GApplicationClass = _GApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplication {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GApplication"][::std::mem::size_of::<_GApplication>() - 32usize];
    ["Alignment of _GApplication"][::std::mem::align_of::<_GApplication>() - 8usize];
    ["Offset of field: _GApplication::parent_instance"]
        [::std::mem::offset_of!(_GApplication, parent_instance) - 0usize];
    ["Offset of field: _GApplication::priv_"]
        [::std::mem::offset_of!(_GApplication, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationClass {
    pub parent_class: GObjectClass,
    pub startup: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            files: *mut *mut GFile,
            n_files: gint,
            hint: *const gchar,
        ),
    >,
    pub command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            command_line: *mut GApplicationCommandLine,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " GApplicationClass::local_command_line:\n @application: a #GApplication\n @arguments: (inout) (array zero-terminated=1): array of command line arguments\n @exit_status: (out): exit status to fill after processing the command line.\n\n This virtual function is always invoked in the local instance. It\n gets passed a pointer to a %NULL-terminated copy of @argv and is\n expected to remove arguments that it handled (shifting up remaining\n arguments).\n\n The last argument to local_command_line() is a pointer to the @status\n variable which can used to set the exit status that is returned from\n g_application_run().\n\n See g_application_run() for more details on #GApplication startup.\n\n Returns: %TRUE if the commandline has been completely handled"]
    pub local_command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            arguments: *mut *mut *mut gchar,
            exit_status: *mut ::std::os::raw::c_int,
        ) -> gboolean,
    >,
    pub before_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub after_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub add_platform_data: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, builder: *mut GVariantBuilder),
    >,
    pub quit_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub run_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub dbus_register: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub dbus_unregister: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
        ),
    >,
    pub handle_local_options: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, options: *mut GVariantDict) -> gint,
    >,
    pub name_lost:
        ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication) -> gboolean>,
    pub padding: [gpointer; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GApplicationClass"][::std::mem::size_of::<_GApplicationClass>() - 312usize];
    ["Alignment of _GApplicationClass"][::std::mem::align_of::<_GApplicationClass>() - 8usize];
    ["Offset of field: _GApplicationClass::parent_class"]
        [::std::mem::offset_of!(_GApplicationClass, parent_class) - 0usize];
    ["Offset of field: _GApplicationClass::startup"]
        [::std::mem::offset_of!(_GApplicationClass, startup) - 136usize];
    ["Offset of field: _GApplicationClass::activate"]
        [::std::mem::offset_of!(_GApplicationClass, activate) - 144usize];
    ["Offset of field: _GApplicationClass::open"]
        [::std::mem::offset_of!(_GApplicationClass, open) - 152usize];
    ["Offset of field: _GApplicationClass::command_line"]
        [::std::mem::offset_of!(_GApplicationClass, command_line) - 160usize];
    ["Offset of field: _GApplicationClass::local_command_line"]
        [::std::mem::offset_of!(_GApplicationClass, local_command_line) - 168usize];
    ["Offset of field: _GApplicationClass::before_emit"]
        [::std::mem::offset_of!(_GApplicationClass, before_emit) - 176usize];
    ["Offset of field: _GApplicationClass::after_emit"]
        [::std::mem::offset_of!(_GApplicationClass, after_emit) - 184usize];
    ["Offset of field: _GApplicationClass::add_platform_data"]
        [::std::mem::offset_of!(_GApplicationClass, add_platform_data) - 192usize];
    ["Offset of field: _GApplicationClass::quit_mainloop"]
        [::std::mem::offset_of!(_GApplicationClass, quit_mainloop) - 200usize];
    ["Offset of field: _GApplicationClass::run_mainloop"]
        [::std::mem::offset_of!(_GApplicationClass, run_mainloop) - 208usize];
    ["Offset of field: _GApplicationClass::shutdown"]
        [::std::mem::offset_of!(_GApplicationClass, shutdown) - 216usize];
    ["Offset of field: _GApplicationClass::dbus_register"]
        [::std::mem::offset_of!(_GApplicationClass, dbus_register) - 224usize];
    ["Offset of field: _GApplicationClass::dbus_unregister"]
        [::std::mem::offset_of!(_GApplicationClass, dbus_unregister) - 232usize];
    ["Offset of field: _GApplicationClass::handle_local_options"]
        [::std::mem::offset_of!(_GApplicationClass, handle_local_options) - 240usize];
    ["Offset of field: _GApplicationClass::name_lost"]
        [::std::mem::offset_of!(_GApplicationClass, name_lost) - 248usize];
    ["Offset of field: _GApplicationClass::padding"]
        [::std::mem::offset_of!(_GApplicationClass, padding) - 256usize];
};
unsafe extern "C" {
    pub fn g_application_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_application_id_is_valid(application_id: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_application_new(
        application_id: *const gchar,
        flags: GApplicationFlags,
    ) -> *mut GApplication;
}
unsafe extern "C" {
    pub fn g_application_get_application_id(application: *mut GApplication) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_application_set_application_id(
        application: *mut GApplication,
        application_id: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_get_version(application: *mut GApplication) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_application_set_version(application: *mut GApplication, version: *const gchar);
}
unsafe extern "C" {
    pub fn g_application_get_dbus_connection(
        application: *mut GApplication,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_application_get_dbus_object_path(application: *mut GApplication) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_application_get_inactivity_timeout(application: *mut GApplication) -> guint;
}
unsafe extern "C" {
    pub fn g_application_set_inactivity_timeout(
        application: *mut GApplication,
        inactivity_timeout: guint,
    );
}
unsafe extern "C" {
    pub fn g_application_get_flags(application: *mut GApplication) -> GApplicationFlags;
}
unsafe extern "C" {
    pub fn g_application_set_flags(application: *mut GApplication, flags: GApplicationFlags);
}
unsafe extern "C" {
    pub fn g_application_get_resource_base_path(application: *mut GApplication) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_application_set_resource_base_path(
        application: *mut GApplication,
        resource_path: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_set_action_group(
        application: *mut GApplication,
        action_group: *mut GActionGroup,
    );
}
unsafe extern "C" {
    pub fn g_application_add_main_option_entries(
        application: *mut GApplication,
        entries: *const GOptionEntry,
    );
}
unsafe extern "C" {
    pub fn g_application_add_main_option(
        application: *mut GApplication,
        long_name: *const ::std::os::raw::c_char,
        short_name: ::std::os::raw::c_char,
        flags: GOptionFlags,
        arg: GOptionArg,
        description: *const ::std::os::raw::c_char,
        arg_description: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_application_add_option_group(application: *mut GApplication, group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn g_application_set_option_context_parameter_string(
        application: *mut GApplication,
        parameter_string: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_set_option_context_summary(
        application: *mut GApplication,
        summary: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_set_option_context_description(
        application: *mut GApplication,
        description: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_get_is_registered(application: *mut GApplication) -> gboolean;
}
unsafe extern "C" {
    pub fn g_application_get_is_remote(application: *mut GApplication) -> gboolean;
}
unsafe extern "C" {
    pub fn g_application_register(
        application: *mut GApplication,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_application_hold(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_release(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_activate(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_open(
        application: *mut GApplication,
        files: *mut *mut GFile,
        n_files: gint,
        hint: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_run(
        application: *mut GApplication,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_application_quit(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_get_default() -> *mut GApplication;
}
unsafe extern "C" {
    pub fn g_application_set_default(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_mark_busy(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_unmark_busy(application: *mut GApplication);
}
unsafe extern "C" {
    pub fn g_application_get_is_busy(application: *mut GApplication) -> gboolean;
}
unsafe extern "C" {
    pub fn g_application_send_notification(
        application: *mut GApplication,
        id: *const gchar,
        notification: *mut GNotification,
    );
}
unsafe extern "C" {
    pub fn g_application_withdraw_notification(application: *mut GApplication, id: *const gchar);
}
unsafe extern "C" {
    pub fn g_application_bind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_unbind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLinePrivate {
    _unused: [u8; 0],
}
pub type GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate;
pub type GApplicationCommandLineClass = _GApplicationCommandLineClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLine {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationCommandLinePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GApplicationCommandLine"]
        [::std::mem::size_of::<_GApplicationCommandLine>() - 32usize];
    ["Alignment of _GApplicationCommandLine"]
        [::std::mem::align_of::<_GApplicationCommandLine>() - 8usize];
    ["Offset of field: _GApplicationCommandLine::parent_instance"]
        [::std::mem::offset_of!(_GApplicationCommandLine, parent_instance) - 0usize];
    ["Offset of field: _GApplicationCommandLine::priv_"]
        [::std::mem::offset_of!(_GApplicationCommandLine, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLineClass {
    pub parent_class: GObjectClass,
    pub print_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub printerr_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub get_stdin: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine) -> *mut GInputStream,
    >,
    pub done: ::std::option::Option<unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine)>,
    pub padding: [gpointer; 10usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GApplicationCommandLineClass"]
        [::std::mem::size_of::<_GApplicationCommandLineClass>() - 248usize];
    ["Alignment of _GApplicationCommandLineClass"]
        [::std::mem::align_of::<_GApplicationCommandLineClass>() - 8usize];
    ["Offset of field: _GApplicationCommandLineClass::parent_class"]
        [::std::mem::offset_of!(_GApplicationCommandLineClass, parent_class) - 0usize];
    ["Offset of field: _GApplicationCommandLineClass::print_literal"]
        [::std::mem::offset_of!(_GApplicationCommandLineClass, print_literal) - 136usize];
    ["Offset of field: _GApplicationCommandLineClass::printerr_literal"]
        [::std::mem::offset_of!(_GApplicationCommandLineClass, printerr_literal) - 144usize];
    ["Offset of field: _GApplicationCommandLineClass::get_stdin"]
        [::std::mem::offset_of!(_GApplicationCommandLineClass, get_stdin) - 152usize];
    ["Offset of field: _GApplicationCommandLineClass::done"]
        [::std::mem::offset_of!(_GApplicationCommandLineClass, done) - 160usize];
    ["Offset of field: _GApplicationCommandLineClass::padding"]
        [::std::mem::offset_of!(_GApplicationCommandLineClass, padding) - 168usize];
};
unsafe extern "C" {
    pub fn g_application_command_line_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_application_command_line_get_arguments(
        cmdline: *mut GApplicationCommandLine,
        argc: *mut ::std::os::raw::c_int,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_application_command_line_get_options_dict(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariantDict;
}
unsafe extern "C" {
    pub fn g_application_command_line_get_stdin(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_application_command_line_get_environ(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_application_command_line_getenv(
        cmdline: *mut GApplicationCommandLine,
        name: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_application_command_line_get_cwd(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_application_command_line_get_is_remote(
        cmdline: *mut GApplicationCommandLine,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_application_command_line_print_literal(
        cmdline: *mut GApplicationCommandLine,
        message: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_command_line_printerr_literal(
        cmdline: *mut GApplicationCommandLine,
        message: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_application_command_line_print(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_application_command_line_printerr(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_application_command_line_get_exit_status(
        cmdline: *mut GApplicationCommandLine,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_application_command_line_set_exit_status(
        cmdline: *mut GApplicationCommandLine,
        exit_status: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn g_application_command_line_get_platform_data(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_application_command_line_create_file_for_arg(
        cmdline: *mut GApplicationCommandLine,
        arg: *const gchar,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_application_command_line_done(cmdline: *mut GApplicationCommandLine);
}
#[doc = " GInitableIface:\n @g_iface: The parent interface.\n @init: Initializes the object.\n\n Provides an interface for initializing object such that initialization\n may fail.\n\n Since: 2.22"]
pub type GInitableIface = _GInitableIface;
#[doc = " GInitableIface:\n @g_iface: The parent interface.\n @init: Initializes the object.\n\n Provides an interface for initializing object such that initialization\n may fail.\n\n Since: 2.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitableIface {
    pub g_iface: GTypeInterface,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GInitable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInitableIface"][::std::mem::size_of::<_GInitableIface>() - 24usize];
    ["Alignment of _GInitableIface"][::std::mem::align_of::<_GInitableIface>() - 8usize];
    ["Offset of field: _GInitableIface::g_iface"]
        [::std::mem::offset_of!(_GInitableIface, g_iface) - 0usize];
    ["Offset of field: _GInitableIface::init"]
        [::std::mem::offset_of!(_GInitableIface, init) - 16usize];
};
unsafe extern "C" {
    pub fn g_initable_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_initable_init(
        initable: *mut GInitable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_initable_new(
        object_type: GType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        first_property_name: *const gchar,
        ...
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_initable_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_initable_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
#[doc = " GAsyncInitableIface:\n @g_iface: The parent interface.\n @init_async: Starts initialization of the object.\n @init_finish: Finishes initialization of the object.\n\n Provides an interface for asynchronous initializing object such that\n initialization may fail.\n\n Since: 2.22"]
pub type GAsyncInitableIface = _GAsyncInitableIface;
#[doc = " GAsyncInitableIface:\n @g_iface: The parent interface.\n @init_async: Starts initialization of the object.\n @init_finish: Finishes initialization of the object.\n\n Provides an interface for asynchronous initializing object such that\n initialization may fail.\n\n Since: 2.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitableIface {
    pub g_iface: GTypeInterface,
    pub init_async: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub init_finish: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GAsyncInitableIface"][::std::mem::size_of::<_GAsyncInitableIface>() - 32usize];
    ["Alignment of _GAsyncInitableIface"][::std::mem::align_of::<_GAsyncInitableIface>() - 8usize];
    ["Offset of field: _GAsyncInitableIface::g_iface"]
        [::std::mem::offset_of!(_GAsyncInitableIface, g_iface) - 0usize];
    ["Offset of field: _GAsyncInitableIface::init_async"]
        [::std::mem::offset_of!(_GAsyncInitableIface, init_async) - 16usize];
    ["Offset of field: _GAsyncInitableIface::init_finish"]
        [::std::mem::offset_of!(_GAsyncInitableIface, init_finish) - 24usize];
};
unsafe extern "C" {
    pub fn g_async_initable_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_async_initable_init_async(
        initable: *mut GAsyncInitable,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_initable_init_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_initable_new_async(
        object_type: GType,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        first_property_name: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_async_initable_newv_async(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_initable_new_valist_async(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_async_initable_new_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
#[doc = " GAsyncResultIface:\n @g_iface: The parent interface.\n @get_user_data: Gets the user data passed to the callback.\n @get_source_object: Gets the source object that issued the asynchronous operation.\n @is_tagged: Checks if a result is tagged with a particular source.\n\n Interface definition for #GAsyncResult."]
pub type GAsyncResultIface = _GAsyncResultIface;
#[doc = " GAsyncResultIface:\n @g_iface: The parent interface.\n @get_user_data: Gets the user data passed to the callback.\n @get_source_object: Gets the source object that issued the asynchronous operation.\n @is_tagged: Checks if a result is tagged with a particular source.\n\n Interface definition for #GAsyncResult."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResultIface {
    pub g_iface: GTypeInterface,
    pub get_user_data:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> gpointer>,
    pub get_source_object:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> *mut GObject>,
    pub is_tagged: ::std::option::Option<
        unsafe extern "C" fn(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GAsyncResultIface"][::std::mem::size_of::<_GAsyncResultIface>() - 40usize];
    ["Alignment of _GAsyncResultIface"][::std::mem::align_of::<_GAsyncResultIface>() - 8usize];
    ["Offset of field: _GAsyncResultIface::g_iface"]
        [::std::mem::offset_of!(_GAsyncResultIface, g_iface) - 0usize];
    ["Offset of field: _GAsyncResultIface::get_user_data"]
        [::std::mem::offset_of!(_GAsyncResultIface, get_user_data) - 16usize];
    ["Offset of field: _GAsyncResultIface::get_source_object"]
        [::std::mem::offset_of!(_GAsyncResultIface, get_source_object) - 24usize];
    ["Offset of field: _GAsyncResultIface::is_tagged"]
        [::std::mem::offset_of!(_GAsyncResultIface, is_tagged) - 32usize];
};
unsafe extern "C" {
    pub fn g_async_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
}
unsafe extern "C" {
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_async_result_legacy_propagate_error(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean;
}
pub type GInputStreamClass = _GInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GInputStreamPrivate = _GInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GInputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInputStream"][::std::mem::size_of::<_GInputStream>() - 32usize];
    ["Alignment of _GInputStream"][::std::mem::align_of::<_GInputStream>() - 8usize];
    ["Offset of field: _GInputStream::parent_instance"]
        [::std::mem::offset_of!(_GInputStream, parent_instance) - 0usize];
    ["Offset of field: _GInputStream::priv_"]
        [::std::mem::offset_of!(_GInputStream, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamClass {
    pub parent_class: GObjectClass,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub skip_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInputStreamClass"][::std::mem::size_of::<_GInputStreamClass>() - 248usize];
    ["Alignment of _GInputStreamClass"][::std::mem::align_of::<_GInputStreamClass>() - 8usize];
    ["Offset of field: _GInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GInputStreamClass::read_fn"]
        [::std::mem::offset_of!(_GInputStreamClass, read_fn) - 136usize];
    ["Offset of field: _GInputStreamClass::skip"]
        [::std::mem::offset_of!(_GInputStreamClass, skip) - 144usize];
    ["Offset of field: _GInputStreamClass::close_fn"]
        [::std::mem::offset_of!(_GInputStreamClass, close_fn) - 152usize];
    ["Offset of field: _GInputStreamClass::read_async"]
        [::std::mem::offset_of!(_GInputStreamClass, read_async) - 160usize];
    ["Offset of field: _GInputStreamClass::read_finish"]
        [::std::mem::offset_of!(_GInputStreamClass, read_finish) - 168usize];
    ["Offset of field: _GInputStreamClass::skip_async"]
        [::std::mem::offset_of!(_GInputStreamClass, skip_async) - 176usize];
    ["Offset of field: _GInputStreamClass::skip_finish"]
        [::std::mem::offset_of!(_GInputStreamClass, skip_finish) - 184usize];
    ["Offset of field: _GInputStreamClass::close_async"]
        [::std::mem::offset_of!(_GInputStreamClass, close_async) - 192usize];
    ["Offset of field: _GInputStreamClass::close_finish"]
        [::std::mem::offset_of!(_GInputStreamClass, close_finish) - 200usize];
    ["Offset of field: _GInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GInputStreamClass, _g_reserved1) - 208usize];
    ["Offset of field: _GInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GInputStreamClass, _g_reserved2) - 216usize];
    ["Offset of field: _GInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GInputStreamClass, _g_reserved3) - 224usize];
    ["Offset of field: _GInputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GInputStreamClass, _g_reserved4) - 232usize];
    ["Offset of field: _GInputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GInputStreamClass, _g_reserved5) - 240usize];
};
unsafe extern "C" {
    pub fn g_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_input_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_input_stream_read_all(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        bytes_read: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_read_bytes(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_input_stream_skip(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_input_stream_close(
        stream: *mut GInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_read_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_input_stream_read_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_input_stream_read_all_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_input_stream_read_all_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_read_bytes_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_input_stream_read_bytes_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_input_stream_skip_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_input_stream_skip_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_input_stream_close_async(
        stream: *mut GInputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_input_stream_close_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_set_pending(
        stream: *mut GInputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
}
pub type GFilterInputStreamClass = _GFilterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFilterInputStream"][::std::mem::size_of::<_GFilterInputStream>() - 40usize];
    ["Alignment of _GFilterInputStream"][::std::mem::align_of::<_GFilterInputStream>() - 8usize];
    ["Offset of field: _GFilterInputStream::parent_instance"]
        [::std::mem::offset_of!(_GFilterInputStream, parent_instance) - 0usize];
    ["Offset of field: _GFilterInputStream::base_stream"]
        [::std::mem::offset_of!(_GFilterInputStream, base_stream) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFilterInputStreamClass"]
        [::std::mem::size_of::<_GFilterInputStreamClass>() - 272usize];
    ["Alignment of _GFilterInputStreamClass"]
        [::std::mem::align_of::<_GFilterInputStreamClass>() - 8usize];
    ["Offset of field: _GFilterInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GFilterInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GFilterInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFilterInputStreamClass, _g_reserved1) - 248usize];
    ["Offset of field: _GFilterInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFilterInputStreamClass, _g_reserved2) - 256usize];
    ["Offset of field: _GFilterInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFilterInputStreamClass, _g_reserved3) - 264usize];
};
unsafe extern "C" {
    pub fn g_filter_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_filter_input_stream_get_base_stream(
        stream: *mut GFilterInputStream,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_filter_input_stream_get_close_base_stream(stream: *mut GFilterInputStream)
        -> gboolean;
}
unsafe extern "C" {
    pub fn g_filter_input_stream_set_close_base_stream(
        stream: *mut GFilterInputStream,
        close_base: gboolean,
    );
}
pub type GBufferedInputStreamClass = _GBufferedInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GBufferedInputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GBufferedInputStream"][::std::mem::size_of::<_GBufferedInputStream>() - 48usize];
    ["Alignment of _GBufferedInputStream"]
        [::std::mem::align_of::<_GBufferedInputStream>() - 8usize];
    ["Offset of field: _GBufferedInputStream::parent_instance"]
        [::std::mem::offset_of!(_GBufferedInputStream, parent_instance) - 0usize];
    ["Offset of field: _GBufferedInputStream::priv_"]
        [::std::mem::offset_of!(_GBufferedInputStream, priv_) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub fill_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub fill_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GBufferedInputStreamClass"]
        [::std::mem::size_of::<_GBufferedInputStreamClass>() - 336usize];
    ["Alignment of _GBufferedInputStreamClass"]
        [::std::mem::align_of::<_GBufferedInputStreamClass>() - 8usize];
    ["Offset of field: _GBufferedInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GBufferedInputStreamClass::fill"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, fill) - 272usize];
    ["Offset of field: _GBufferedInputStreamClass::fill_async"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, fill_async) - 280usize];
    ["Offset of field: _GBufferedInputStreamClass::fill_finish"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, fill_finish) - 288usize];
    ["Offset of field: _GBufferedInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, _g_reserved1) - 296usize];
    ["Offset of field: _GBufferedInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, _g_reserved2) - 304usize];
    ["Offset of field: _GBufferedInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, _g_reserved3) - 312usize];
    ["Offset of field: _GBufferedInputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, _g_reserved4) - 320usize];
    ["Offset of field: _GBufferedInputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GBufferedInputStreamClass, _g_reserved5) - 328usize];
};
unsafe extern "C" {
    pub fn g_buffered_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_new_sized(
        base_stream: *mut GInputStream,
        size: gsize,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_get_buffer_size(stream: *mut GBufferedInputStream) -> gsize;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_set_buffer_size(stream: *mut GBufferedInputStream, size: gsize);
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_get_available(stream: *mut GBufferedInputStream) -> gsize;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_peek(
        stream: *mut GBufferedInputStream,
        buffer: *mut ::std::os::raw::c_void,
        offset: gsize,
        count: gsize,
    ) -> gsize;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_peek_buffer(
        stream: *mut GBufferedInputStream,
        count: *mut gsize,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_fill(
        stream: *mut GBufferedInputStream,
        count: gssize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_fill_async(
        stream: *mut GBufferedInputStream,
        count: gssize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_fill_finish(
        stream: *mut GBufferedInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_buffered_input_stream_read_byte(
        stream: *mut GBufferedInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> ::std::os::raw::c_int;
}
pub type GOutputStreamClass = _GOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GOutputStreamPrivate = _GOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GOutputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOutputStream"][::std::mem::size_of::<_GOutputStream>() - 32usize];
    ["Alignment of _GOutputStream"][::std::mem::align_of::<_GOutputStream>() - 8usize];
    ["Offset of field: _GOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GOutputStream::priv_"]
        [::std::mem::offset_of!(_GOutputStream, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamClass {
    pub parent_class: GObjectClass,
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub write_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub write_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub splice_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub flush_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub writev_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            bytes_written: *mut gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub writev_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub writev_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GOutputStreamClass"][::std::mem::size_of::<_GOutputStreamClass>() - 296usize];
    ["Alignment of _GOutputStreamClass"][::std::mem::align_of::<_GOutputStreamClass>() - 8usize];
    ["Offset of field: _GOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GOutputStreamClass::write_fn"]
        [::std::mem::offset_of!(_GOutputStreamClass, write_fn) - 136usize];
    ["Offset of field: _GOutputStreamClass::splice"]
        [::std::mem::offset_of!(_GOutputStreamClass, splice) - 144usize];
    ["Offset of field: _GOutputStreamClass::flush"]
        [::std::mem::offset_of!(_GOutputStreamClass, flush) - 152usize];
    ["Offset of field: _GOutputStreamClass::close_fn"]
        [::std::mem::offset_of!(_GOutputStreamClass, close_fn) - 160usize];
    ["Offset of field: _GOutputStreamClass::write_async"]
        [::std::mem::offset_of!(_GOutputStreamClass, write_async) - 168usize];
    ["Offset of field: _GOutputStreamClass::write_finish"]
        [::std::mem::offset_of!(_GOutputStreamClass, write_finish) - 176usize];
    ["Offset of field: _GOutputStreamClass::splice_async"]
        [::std::mem::offset_of!(_GOutputStreamClass, splice_async) - 184usize];
    ["Offset of field: _GOutputStreamClass::splice_finish"]
        [::std::mem::offset_of!(_GOutputStreamClass, splice_finish) - 192usize];
    ["Offset of field: _GOutputStreamClass::flush_async"]
        [::std::mem::offset_of!(_GOutputStreamClass, flush_async) - 200usize];
    ["Offset of field: _GOutputStreamClass::flush_finish"]
        [::std::mem::offset_of!(_GOutputStreamClass, flush_finish) - 208usize];
    ["Offset of field: _GOutputStreamClass::close_async"]
        [::std::mem::offset_of!(_GOutputStreamClass, close_async) - 216usize];
    ["Offset of field: _GOutputStreamClass::close_finish"]
        [::std::mem::offset_of!(_GOutputStreamClass, close_finish) - 224usize];
    ["Offset of field: _GOutputStreamClass::writev_fn"]
        [::std::mem::offset_of!(_GOutputStreamClass, writev_fn) - 232usize];
    ["Offset of field: _GOutputStreamClass::writev_async"]
        [::std::mem::offset_of!(_GOutputStreamClass, writev_async) - 240usize];
    ["Offset of field: _GOutputStreamClass::writev_finish"]
        [::std::mem::offset_of!(_GOutputStreamClass, writev_finish) - 248usize];
    ["Offset of field: _GOutputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GOutputStreamClass, _g_reserved4) - 256usize];
    ["Offset of field: _GOutputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GOutputStreamClass, _g_reserved5) - 264usize];
    ["Offset of field: _GOutputStreamClass::_g_reserved6"]
        [::std::mem::offset_of!(_GOutputStreamClass, _g_reserved6) - 272usize];
    ["Offset of field: _GOutputStreamClass::_g_reserved7"]
        [::std::mem::offset_of!(_GOutputStreamClass, _g_reserved7) - 280usize];
    ["Offset of field: _GOutputStreamClass::_g_reserved8"]
        [::std::mem::offset_of!(_GOutputStreamClass, _g_reserved8) - 288usize];
};
unsafe extern "C" {
    pub fn g_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_output_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_output_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_writev(
        stream: *mut GOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_writev_all(
        stream: *mut GOutputStream,
        vectors: *mut GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_printf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_vprintf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_write_bytes(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_output_stream_splice(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_output_stream_flush(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_close(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_write_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_write_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_output_stream_write_all_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_write_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_writev_async(
        stream: *mut GOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_writev_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_writev_all_async(
        stream: *mut GOutputStream,
        vectors: *mut GOutputVector,
        n_vectors: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_writev_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_write_bytes_async(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_write_bytes_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_output_stream_splice_async(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_splice_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_output_stream_flush_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_flush_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_close_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_output_stream_close_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_set_pending(
        stream: *mut GOutputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
}
pub type GFilterOutputStreamClass = _GFilterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFilterOutputStream"][::std::mem::size_of::<_GFilterOutputStream>() - 40usize];
    ["Alignment of _GFilterOutputStream"][::std::mem::align_of::<_GFilterOutputStream>() - 8usize];
    ["Offset of field: _GFilterOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GFilterOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GFilterOutputStream::base_stream"]
        [::std::mem::offset_of!(_GFilterOutputStream, base_stream) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFilterOutputStreamClass"]
        [::std::mem::size_of::<_GFilterOutputStreamClass>() - 320usize];
    ["Alignment of _GFilterOutputStreamClass"]
        [::std::mem::align_of::<_GFilterOutputStreamClass>() - 8usize];
    ["Offset of field: _GFilterOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GFilterOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GFilterOutputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFilterOutputStreamClass, _g_reserved1) - 296usize];
    ["Offset of field: _GFilterOutputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFilterOutputStreamClass, _g_reserved2) - 304usize];
    ["Offset of field: _GFilterOutputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFilterOutputStreamClass, _g_reserved3) - 312usize];
};
unsafe extern "C" {
    pub fn g_filter_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_filter_output_stream_get_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_filter_output_stream_get_close_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_filter_output_stream_set_close_base_stream(
        stream: *mut GFilterOutputStream,
        close_base: gboolean,
    );
}
pub type GBufferedOutputStreamClass = _GBufferedOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GBufferedOutputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GBufferedOutputStream"][::std::mem::size_of::<_GBufferedOutputStream>() - 48usize];
    ["Alignment of _GBufferedOutputStream"]
        [::std::mem::align_of::<_GBufferedOutputStream>() - 8usize];
    ["Offset of field: _GBufferedOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GBufferedOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GBufferedOutputStream::priv_"]
        [::std::mem::offset_of!(_GBufferedOutputStream, priv_) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GBufferedOutputStreamClass"]
        [::std::mem::size_of::<_GBufferedOutputStreamClass>() - 336usize];
    ["Alignment of _GBufferedOutputStreamClass"]
        [::std::mem::align_of::<_GBufferedOutputStreamClass>() - 8usize];
    ["Offset of field: _GBufferedOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GBufferedOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GBufferedOutputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GBufferedOutputStreamClass, _g_reserved1) - 320usize];
    ["Offset of field: _GBufferedOutputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GBufferedOutputStreamClass, _g_reserved2) - 328usize];
};
unsafe extern "C" {
    pub fn g_buffered_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_buffered_output_stream_new_sized(
        base_stream: *mut GOutputStream,
        size: gsize,
    ) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_buffered_output_stream_get_buffer_size(stream: *mut GBufferedOutputStream) -> gsize;
}
unsafe extern "C" {
    pub fn g_buffered_output_stream_set_buffer_size(
        stream: *mut GBufferedOutputStream,
        size: gsize,
    );
}
unsafe extern "C" {
    pub fn g_buffered_output_stream_get_auto_grow(stream: *mut GBufferedOutputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_buffered_output_stream_set_auto_grow(
        stream: *mut GBufferedOutputStream,
        auto_grow: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_bytes_icon_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bytes_icon_new(bytes: *mut GBytes) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut GBytes;
}
pub type GCancellableClass = _GCancellableClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellablePrivate {
    _unused: [u8; 0],
}
pub type GCancellablePrivate = _GCancellablePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellable {
    pub parent_instance: GObject,
    pub priv_: *mut GCancellablePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCancellable"][::std::mem::size_of::<_GCancellable>() - 32usize];
    ["Alignment of _GCancellable"][::std::mem::align_of::<_GCancellable>() - 8usize];
    ["Offset of field: _GCancellable::parent_instance"]
        [::std::mem::offset_of!(_GCancellable, parent_instance) - 0usize];
    ["Offset of field: _GCancellable::priv_"]
        [::std::mem::offset_of!(_GCancellable, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellableClass {
    pub parent_class: GObjectClass,
    pub cancelled: ::std::option::Option<unsafe extern "C" fn(cancellable: *mut GCancellable)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCancellableClass"][::std::mem::size_of::<_GCancellableClass>() - 184usize];
    ["Alignment of _GCancellableClass"][::std::mem::align_of::<_GCancellableClass>() - 8usize];
    ["Offset of field: _GCancellableClass::parent_class"]
        [::std::mem::offset_of!(_GCancellableClass, parent_class) - 0usize];
    ["Offset of field: _GCancellableClass::cancelled"]
        [::std::mem::offset_of!(_GCancellableClass, cancelled) - 136usize];
    ["Offset of field: _GCancellableClass::_g_reserved1"]
        [::std::mem::offset_of!(_GCancellableClass, _g_reserved1) - 144usize];
    ["Offset of field: _GCancellableClass::_g_reserved2"]
        [::std::mem::offset_of!(_GCancellableClass, _g_reserved2) - 152usize];
    ["Offset of field: _GCancellableClass::_g_reserved3"]
        [::std::mem::offset_of!(_GCancellableClass, _g_reserved3) - 160usize];
    ["Offset of field: _GCancellableClass::_g_reserved4"]
        [::std::mem::offset_of!(_GCancellableClass, _g_reserved4) - 168usize];
    ["Offset of field: _GCancellableClass::_g_reserved5"]
        [::std::mem::offset_of!(_GCancellableClass, _g_reserved5) - 176usize];
};
unsafe extern "C" {
    pub fn g_cancellable_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_cancellable_new() -> *mut GCancellable;
}
unsafe extern "C" {
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable) -> gboolean;
}
unsafe extern "C" {
    pub fn g_cancellable_set_error_if_cancelled(
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_cancellable_make_pollfd(
        cancellable: *mut GCancellable,
        pollfd: *mut GPollFD,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
}
unsafe extern "C" {
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_cancellable_get_current() -> *mut GCancellable;
}
unsafe extern "C" {
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
}
unsafe extern "C" {
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
}
unsafe extern "C" {
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
}
unsafe extern "C" {
    pub fn g_cancellable_connect(
        cancellable: *mut GCancellable,
        callback: GCallback,
        data: gpointer,
        data_destroy_func: GDestroyNotify,
    ) -> gulong;
}
unsafe extern "C" {
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable, handler_id: gulong);
}
unsafe extern "C" {
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
}
#[doc = " GConverterIface:\n @g_iface: The parent interface.\n @convert: Converts data.\n @reset: Reverts the internal state of the converter to its initial state.\n\n Provides an interface for converting data from one type\n to another type. The conversion can be stateful\n and may fail at any place.\n\n Since: 2.24"]
pub type GConverterIface = _GConverterIface;
#[doc = " GConverterIface:\n @g_iface: The parent interface.\n @convert: Converts data.\n @reset: Reverts the internal state of the converter to its initial state.\n\n Provides an interface for converting data from one type\n to another type. The conversion can be stateful\n and may fail at any place.\n\n Since: 2.24"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterIface {
    pub g_iface: GTypeInterface,
    pub convert: ::std::option::Option<
        unsafe extern "C" fn(
            converter: *mut GConverter,
            inbuf: *const ::std::os::raw::c_void,
            inbuf_size: gsize,
            outbuf: *mut ::std::os::raw::c_void,
            outbuf_size: gsize,
            flags: GConverterFlags,
            bytes_read: *mut gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GConverterResult,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(converter: *mut GConverter)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GConverterIface"][::std::mem::size_of::<_GConverterIface>() - 32usize];
    ["Alignment of _GConverterIface"][::std::mem::align_of::<_GConverterIface>() - 8usize];
    ["Offset of field: _GConverterIface::g_iface"]
        [::std::mem::offset_of!(_GConverterIface, g_iface) - 0usize];
    ["Offset of field: _GConverterIface::convert"]
        [::std::mem::offset_of!(_GConverterIface, convert) - 16usize];
    ["Offset of field: _GConverterIface::reset"]
        [::std::mem::offset_of!(_GConverterIface, reset) - 24usize];
};
unsafe extern "C" {
    pub fn g_converter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_converter_convert(
        converter: *mut GConverter,
        inbuf: *const ::std::os::raw::c_void,
        inbuf_size: gsize,
        outbuf: *mut ::std::os::raw::c_void,
        outbuf_size: gsize,
        flags: GConverterFlags,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GConverterResult;
}
unsafe extern "C" {
    pub fn g_converter_reset(converter: *mut GConverter);
}
pub type GCharsetConverterClass = _GCharsetConverterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverterClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GCharsetConverterClass"]
        [::std::mem::size_of::<_GCharsetConverterClass>() - 136usize];
    ["Alignment of _GCharsetConverterClass"]
        [::std::mem::align_of::<_GCharsetConverterClass>() - 8usize];
    ["Offset of field: _GCharsetConverterClass::parent_class"]
        [::std::mem::offset_of!(_GCharsetConverterClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_charset_converter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_charset_converter_new(
        to_charset: *const gchar,
        from_charset: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GCharsetConverter;
}
unsafe extern "C" {
    pub fn g_charset_converter_set_use_fallback(
        converter: *mut GCharsetConverter,
        use_fallback: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_charset_converter_get_use_fallback(converter: *mut GCharsetConverter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_charset_converter_get_num_fallbacks(converter: *mut GCharsetConverter) -> guint;
}
unsafe extern "C" {
    pub fn g_content_type_equals(type1: *const gchar, type2: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_content_type_is_a(type_: *const gchar, supertype: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_content_type_is_mime_type(type_: *const gchar, mime_type: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_content_type_is_unknown(type_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_content_type_get_description(type_: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_content_type_get_mime_type(type_: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_content_type_get_icon(type_: *const gchar) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_content_type_get_symbolic_icon(type_: *const gchar) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_content_type_get_generic_icon_name(type_: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_content_type_can_be_executable(type_: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_content_type_from_mime_type(mime_type: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_content_type_guess(
        filename: *const gchar,
        data: *const guchar,
        data_size: gsize,
        result_uncertain: *mut gboolean,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_content_types_get_registered() -> *mut GList;
}
unsafe extern "C" {
    pub fn g_content_type_get_mime_dirs() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_content_type_set_mime_dirs(dirs: *const *const gchar);
}
pub type GConverterInputStreamClass = _GConverterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterInputStreamPrivate = _GConverterInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GConverterInputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GConverterInputStream"][::std::mem::size_of::<_GConverterInputStream>() - 48usize];
    ["Alignment of _GConverterInputStream"]
        [::std::mem::align_of::<_GConverterInputStream>() - 8usize];
    ["Offset of field: _GConverterInputStream::parent_instance"]
        [::std::mem::offset_of!(_GConverterInputStream, parent_instance) - 0usize];
    ["Offset of field: _GConverterInputStream::priv_"]
        [::std::mem::offset_of!(_GConverterInputStream, priv_) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GConverterInputStreamClass"]
        [::std::mem::size_of::<_GConverterInputStreamClass>() - 312usize];
    ["Alignment of _GConverterInputStreamClass"]
        [::std::mem::align_of::<_GConverterInputStreamClass>() - 8usize];
    ["Offset of field: _GConverterInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GConverterInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GConverterInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GConverterInputStreamClass, _g_reserved1) - 272usize];
    ["Offset of field: _GConverterInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GConverterInputStreamClass, _g_reserved2) - 280usize];
    ["Offset of field: _GConverterInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GConverterInputStreamClass, _g_reserved3) - 288usize];
    ["Offset of field: _GConverterInputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GConverterInputStreamClass, _g_reserved4) - 296usize];
    ["Offset of field: _GConverterInputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GConverterInputStreamClass, _g_reserved5) - 304usize];
};
unsafe extern "C" {
    pub fn g_converter_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_converter_input_stream_new(
        base_stream: *mut GInputStream,
        converter: *mut GConverter,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_converter_input_stream_get_converter(
        converter_stream: *mut GConverterInputStream,
    ) -> *mut GConverter;
}
pub type GConverterOutputStreamClass = _GConverterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GConverterOutputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GConverterOutputStream"][::std::mem::size_of::<_GConverterOutputStream>() - 48usize];
    ["Alignment of _GConverterOutputStream"]
        [::std::mem::align_of::<_GConverterOutputStream>() - 8usize];
    ["Offset of field: _GConverterOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GConverterOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GConverterOutputStream::priv_"]
        [::std::mem::offset_of!(_GConverterOutputStream, priv_) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GConverterOutputStreamClass"]
        [::std::mem::size_of::<_GConverterOutputStreamClass>() - 360usize];
    ["Alignment of _GConverterOutputStreamClass"]
        [::std::mem::align_of::<_GConverterOutputStreamClass>() - 8usize];
    ["Offset of field: _GConverterOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GConverterOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GConverterOutputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GConverterOutputStreamClass, _g_reserved1) - 320usize];
    ["Offset of field: _GConverterOutputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GConverterOutputStreamClass, _g_reserved2) - 328usize];
    ["Offset of field: _GConverterOutputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GConverterOutputStreamClass, _g_reserved3) - 336usize];
    ["Offset of field: _GConverterOutputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GConverterOutputStreamClass, _g_reserved4) - 344usize];
    ["Offset of field: _GConverterOutputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GConverterOutputStreamClass, _g_reserved5) - 352usize];
};
unsafe extern "C" {
    pub fn g_converter_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_converter_output_stream_new(
        base_stream: *mut GOutputStream,
        converter: *mut GConverter,
    ) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_converter_output_stream_get_converter(
        converter_stream: *mut GConverterOutputStream,
    ) -> *mut GConverter;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
unsafe extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
unsafe extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
unsafe extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_21 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_21 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_21 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_21 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_21 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_21 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_21 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_21 = 7;
pub const _PC_VDISABLE: _bindgen_ty_21 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_21 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_21 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_21 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_21 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_21 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_21 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_21 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_21 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_21 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_21 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_21 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_21 = 20;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_22 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_22 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_22 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_22 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_22 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_22 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_22 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_22 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_22 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_22 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_22 = 10;
pub const _SC_TIMERS: _bindgen_ty_22 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_22 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_22 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_22 = 14;
pub const _SC_FSYNC: _bindgen_ty_22 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_22 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_22 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_22 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_22 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_22 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_22 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_22 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_22 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_22 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_22 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_22 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_22 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_22 = 28;
pub const _SC_VERSION: _bindgen_ty_22 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_22 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_22 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_22 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_22 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_22 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_22 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_22 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_22 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_22 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_22 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_22 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_22 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_22 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_22 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_22 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_22 = 45;
pub const _SC_2_VERSION: _bindgen_ty_22 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_22 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_22 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_22 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_22 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_22 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_22 = 52;
pub const _SC_PII: _bindgen_ty_22 = 53;
pub const _SC_PII_XTI: _bindgen_ty_22 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_22 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_22 = 56;
pub const _SC_PII_OSI: _bindgen_ty_22 = 57;
pub const _SC_POLL: _bindgen_ty_22 = 58;
pub const _SC_SELECT: _bindgen_ty_22 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_22 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_22 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_22 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_22 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_22 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_22 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_22 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_22 = 66;
pub const _SC_THREADS: _bindgen_ty_22 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_22 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_22 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_22 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_22 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_22 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_22 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_22 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_22 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_22 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_22 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_22 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_22 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_22 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_22 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_22 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_22 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_22 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_22 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_22 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_22 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_22 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_22 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_22 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_22 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_22 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_22 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_22 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_22 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_22 = 96;
pub const _SC_2_UPE: _bindgen_ty_22 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_22 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_22 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_22 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_22 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_22 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_22 = 103;
pub const _SC_INT_MAX: _bindgen_ty_22 = 104;
pub const _SC_INT_MIN: _bindgen_ty_22 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_22 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_22 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_22 = 108;
pub const _SC_NZERO: _bindgen_ty_22 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_22 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_22 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_22 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_22 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_22 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_22 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_22 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_22 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_22 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_22 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_22 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_22 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_22 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_22 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_22 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_22 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_22 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_22 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_22 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_22 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_22 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_22 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_22 = 132;
pub const _SC_BARRIERS: _bindgen_ty_22 = 133;
pub const _SC_BASE: _bindgen_ty_22 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_22 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_22 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_22 = 137;
pub const _SC_CPUTIME: _bindgen_ty_22 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_22 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_22 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_22 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_22 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_22 = 143;
pub const _SC_FIFO: _bindgen_ty_22 = 144;
pub const _SC_PIPE: _bindgen_ty_22 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_22 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_22 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_22 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_22 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_22 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_22 = 151;
pub const _SC_NETWORKING: _bindgen_ty_22 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_22 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_22 = 154;
pub const _SC_REGEXP: _bindgen_ty_22 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_22 = 156;
pub const _SC_SHELL: _bindgen_ty_22 = 157;
pub const _SC_SIGNALS: _bindgen_ty_22 = 158;
pub const _SC_SPAWN: _bindgen_ty_22 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_22 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_22 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_22 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_22 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_22 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_22 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_22 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_22 = 167;
pub const _SC_2_PBS: _bindgen_ty_22 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_22 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_22 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_22 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_22 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_22 = 173;
pub const _SC_STREAMS: _bindgen_ty_22 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_22 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_22 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_22 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_22 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_22 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_22 = 180;
pub const _SC_TRACE: _bindgen_ty_22 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_22 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_22 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_22 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_22 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_22 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_22 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_22 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_22 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_22 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_22 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_22 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_22 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_22 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_22 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_22 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_22 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_22 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_22 = 199;
pub const _SC_IPV6: _bindgen_ty_22 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_22 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_22 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_22 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_22 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_22 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_22 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_22 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_22 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_22 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_22 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_22 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_22 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_22 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_22 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_22 = 250;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_23 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_23 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_23 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_23 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_23 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_23 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_23 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_23 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_23 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_23 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_23 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_23 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_23 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_23 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_23 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_23 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_23 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_23 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_23 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_23 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_23 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_23 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_23 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_23 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_23 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_23 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_23 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_23 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_23 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_23 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_23 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_23 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_23 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_23 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_23 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_23 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_23 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_23 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_23 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_23 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_23 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_23 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_23 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_23 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_23 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_23 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_23 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_23 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_23 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_23 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_23 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_23 = 1149;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn getpid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getppid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgrp() -> __pid_t;
}
unsafe extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setsid() -> __pid_t;
}
unsafe extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
unsafe extern "C" {
    pub fn getuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn geteuid() -> __uid_t;
}
unsafe extern "C" {
    pub fn getgid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getegid() -> __gid_t;
}
unsafe extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fork() -> __pid_t;
}
unsafe extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
unsafe extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
unsafe extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn endusershell();
}
unsafe extern "C" {
    pub fn setusershell();
}
unsafe extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn sync();
}
unsafe extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentialsClass {
    _unused: [u8; 0],
}
pub type GCredentialsClass = _GCredentialsClass;
unsafe extern "C" {
    pub fn g_credentials_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_credentials_new() -> *mut GCredentials;
}
unsafe extern "C" {
    pub fn g_credentials_to_string(credentials: *mut GCredentials) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_credentials_get_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_credentials_set_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
        native: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_credentials_is_same_user(
        credentials: *mut GCredentials,
        other_credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_credentials_get_unix_pid(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> pid_t;
}
unsafe extern "C" {
    pub fn g_credentials_get_unix_user(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> uid_t;
}
unsafe extern "C" {
    pub fn g_credentials_set_unix_user(
        credentials: *mut GCredentials,
        uid: uid_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GDatagramBasedInterface:\n @g_iface: The parent interface.\n @receive_messages: Virtual method for g_datagram_based_receive_messages().\n @send_messages: Virtual method for g_datagram_based_send_messages().\n @create_source: Virtual method for g_datagram_based_create_source().\n @condition_check: Virtual method for g_datagram_based_condition_check().\n @condition_wait: Virtual method for\n   g_datagram_based_condition_wait().\n\n Provides an interface for socket-like objects which have datagram semantics,\n following the Berkeley sockets API. The interface methods are thin wrappers\n around the corresponding virtual methods, and no pre-processing of inputs is\n implemented — so implementations of this API must handle all functionality\n documented in the interface methods.\n\n Since: 2.48"]
pub type GDatagramBasedInterface = _GDatagramBasedInterface;
#[doc = " GDatagramBasedInterface:\n @g_iface: The parent interface.\n @receive_messages: Virtual method for g_datagram_based_receive_messages().\n @send_messages: Virtual method for g_datagram_based_send_messages().\n @create_source: Virtual method for g_datagram_based_create_source().\n @condition_check: Virtual method for g_datagram_based_condition_check().\n @condition_wait: Virtual method for\n   g_datagram_based_condition_wait().\n\n Provides an interface for socket-like objects which have datagram semantics,\n following the Berkeley sockets API. The interface methods are thin wrappers\n around the corresponding virtual methods, and no pre-processing of inputs is\n implemented — so implementations of this API must handle all functionality\n documented in the interface methods.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBasedInterface {
    pub g_iface: GTypeInterface,
    pub receive_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GInputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub send_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GOutputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub condition_check: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
        ) -> GIOCondition,
    >,
    pub condition_wait: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDatagramBasedInterface"]
        [::std::mem::size_of::<_GDatagramBasedInterface>() - 56usize];
    ["Alignment of _GDatagramBasedInterface"]
        [::std::mem::align_of::<_GDatagramBasedInterface>() - 8usize];
    ["Offset of field: _GDatagramBasedInterface::g_iface"]
        [::std::mem::offset_of!(_GDatagramBasedInterface, g_iface) - 0usize];
    ["Offset of field: _GDatagramBasedInterface::receive_messages"]
        [::std::mem::offset_of!(_GDatagramBasedInterface, receive_messages) - 16usize];
    ["Offset of field: _GDatagramBasedInterface::send_messages"]
        [::std::mem::offset_of!(_GDatagramBasedInterface, send_messages) - 24usize];
    ["Offset of field: _GDatagramBasedInterface::create_source"]
        [::std::mem::offset_of!(_GDatagramBasedInterface, create_source) - 32usize];
    ["Offset of field: _GDatagramBasedInterface::condition_check"]
        [::std::mem::offset_of!(_GDatagramBasedInterface, condition_check) - 40usize];
    ["Offset of field: _GDatagramBasedInterface::condition_wait"]
        [::std::mem::offset_of!(_GDatagramBasedInterface, condition_wait) - 48usize];
};
unsafe extern "C" {
    pub fn g_datagram_based_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_datagram_based_receive_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_datagram_based_send_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_datagram_based_create_source(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_datagram_based_condition_check(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
    ) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_datagram_based_condition_wait(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GDataInputStreamClass = _GDataInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataInputStreamPrivate = _GDataInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    pub priv_: *mut GDataInputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDataInputStream"][::std::mem::size_of::<_GDataInputStream>() - 56usize];
    ["Alignment of _GDataInputStream"][::std::mem::align_of::<_GDataInputStream>() - 8usize];
    ["Offset of field: _GDataInputStream::parent_instance"]
        [::std::mem::offset_of!(_GDataInputStream, parent_instance) - 0usize];
    ["Offset of field: _GDataInputStream::priv_"]
        [::std::mem::offset_of!(_GDataInputStream, priv_) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDataInputStreamClass"][::std::mem::size_of::<_GDataInputStreamClass>() - 376usize];
    ["Alignment of _GDataInputStreamClass"]
        [::std::mem::align_of::<_GDataInputStreamClass>() - 8usize];
    ["Offset of field: _GDataInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GDataInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GDataInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GDataInputStreamClass, _g_reserved1) - 336usize];
    ["Offset of field: _GDataInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GDataInputStreamClass, _g_reserved2) - 344usize];
    ["Offset of field: _GDataInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GDataInputStreamClass, _g_reserved3) - 352usize];
    ["Offset of field: _GDataInputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GDataInputStreamClass, _g_reserved4) - 360usize];
    ["Offset of field: _GDataInputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GDataInputStreamClass, _g_reserved5) - 368usize];
};
unsafe extern "C" {
    pub fn g_data_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream) -> *mut GDataInputStream;
}
unsafe extern "C" {
    pub fn g_data_input_stream_set_byte_order(
        stream: *mut GDataInputStream,
        order: GDataStreamByteOrder,
    );
}
unsafe extern "C" {
    pub fn g_data_input_stream_get_byte_order(
        stream: *mut GDataInputStream,
    ) -> GDataStreamByteOrder;
}
unsafe extern "C" {
    pub fn g_data_input_stream_set_newline_type(
        stream: *mut GDataInputStream,
        type_: GDataStreamNewlineType,
    );
}
unsafe extern "C" {
    pub fn g_data_input_stream_get_newline_type(
        stream: *mut GDataInputStream,
    ) -> GDataStreamNewlineType;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_byte(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guchar;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_int16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint16;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_uint16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint16;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_int32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint32;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_uint32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint32;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_int64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_uint64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_line(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_line_utf8(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_line_async(
        stream: *mut GDataInputStream,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_line_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_line_finish_utf8(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_until(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_until_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_until_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_upto(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_upto_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_data_input_stream_read_upto_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
pub type GDataOutputStream = _GDataOutputStream;
pub type GDataOutputStreamClass = _GDataOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataOutputStreamPrivate = _GDataOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GDataOutputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDataOutputStream"][::std::mem::size_of::<_GDataOutputStream>() - 48usize];
    ["Alignment of _GDataOutputStream"][::std::mem::align_of::<_GDataOutputStream>() - 8usize];
    ["Offset of field: _GDataOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GDataOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GDataOutputStream::priv_"]
        [::std::mem::offset_of!(_GDataOutputStream, priv_) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDataOutputStreamClass"]
        [::std::mem::size_of::<_GDataOutputStreamClass>() - 360usize];
    ["Alignment of _GDataOutputStreamClass"]
        [::std::mem::align_of::<_GDataOutputStreamClass>() - 8usize];
    ["Offset of field: _GDataOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GDataOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GDataOutputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GDataOutputStreamClass, _g_reserved1) - 320usize];
    ["Offset of field: _GDataOutputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GDataOutputStreamClass, _g_reserved2) - 328usize];
    ["Offset of field: _GDataOutputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GDataOutputStreamClass, _g_reserved3) - 336usize];
    ["Offset of field: _GDataOutputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GDataOutputStreamClass, _g_reserved4) - 344usize];
    ["Offset of field: _GDataOutputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GDataOutputStreamClass, _g_reserved5) - 352usize];
};
unsafe extern "C" {
    pub fn g_data_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream) -> *mut GDataOutputStream;
}
unsafe extern "C" {
    pub fn g_data_output_stream_set_byte_order(
        stream: *mut GDataOutputStream,
        order: GDataStreamByteOrder,
    );
}
unsafe extern "C" {
    pub fn g_data_output_stream_get_byte_order(
        stream: *mut GDataOutputStream,
    ) -> GDataStreamByteOrder;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_byte(
        stream: *mut GDataOutputStream,
        data: guchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_int16(
        stream: *mut GDataOutputStream,
        data: gint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_uint16(
        stream: *mut GDataOutputStream,
        data: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_int32(
        stream: *mut GDataOutputStream,
        data: gint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_uint32(
        stream: *mut GDataOutputStream,
        data: guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_int64(
        stream: *mut GDataOutputStream,
        data: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_uint64(
        stream: *mut GDataOutputStream,
        data: guint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_data_output_stream_put_string(
        stream: *mut GDataOutputStream,
        str_: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_action_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_action_group_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusActionGroup;
}
unsafe extern "C" {
    pub fn g_dbus_address_escape_value(string: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_is_address(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_is_supported_address(string: *const gchar, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_address_get_stream(
        address: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_address_get_stream_finish(
        res: *mut GAsyncResult,
        out_guid: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_dbus_address_get_stream_sync(
        address: *const gchar,
        out_guid: *mut *mut gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_dbus_address_get_for_bus_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_auth_observer_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
}
unsafe extern "C" {
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(
        observer: *mut GDBusAuthObserver,
        stream: *mut GIOStream,
        credentials: *mut GCredentials,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_auth_observer_allow_mechanism(
        observer: *mut GDBusAuthObserver,
        mechanism: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bus_get(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_bus_get_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_bus_get_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_connection_new(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_connection_new_sync(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_connection_new_for_address(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_new_for_address_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_connection_new_for_address_sync(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_connection_start_message_processing(connection: *mut GDBusConnection);
}
unsafe extern "C" {
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_peer_credentials(
        connection: *mut GDBusConnection,
    ) -> *mut GCredentials;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection) -> guint32;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_exit_on_close(connection: *mut GDBusConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_set_exit_on_close(
        connection: *mut GDBusConnection,
        exit_on_close: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_capabilities(
        connection: *mut GDBusConnection,
    ) -> GDBusCapabilityFlags;
}
unsafe extern "C" {
    pub fn g_dbus_connection_get_flags(connection: *mut GDBusConnection) -> GDBusConnectionFlags;
}
unsafe extern "C" {
    pub fn g_dbus_connection_close(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_close_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_close_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_flush(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_flush_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_flush_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_send_message(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        out_serial: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_send_message_with_reply(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_send_message_with_reply_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_connection_send_message_with_reply_sync(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_connection_emit_signal(
        connection: *mut GDBusConnection,
        destination_bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_connection_call(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_call_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_connection_call_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(
        connection: *mut GDBusConnection,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
#[doc = " GDBusInterfaceMethodCallFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name the method was invoked on.\n @method_name: The name of the method that was invoked.\n @parameters: A #GVariant tuple with parameters.\n @invocation: (transfer full): A #GDBusMethodInvocation object that must be used to return a value or error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @method_call function in #GDBusInterfaceVTable.\n\n Since: 2.26"]
pub type GDBusInterfaceMethodCallFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        invocation: *mut GDBusMethodInvocation,
        user_data: gpointer,
    ),
>;
#[doc = " GDBusInterfaceGetPropertyFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name for the property.\n @property_name: The name of the property to get the value of.\n @error: Return location for error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @get_property function in #GDBusInterfaceVTable.\n\n Returns: A #GVariant with the value for @property_name or %NULL if\n     @error is set. If the returned #GVariant is floating, it is\n     consumed - otherwise its reference count is decreased by one.\n\n Since: 2.26"]
pub type GDBusInterfaceGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
#[doc = " GDBusInterfaceSetPropertyFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name for the property.\n @property_name: The name of the property to get the value of.\n @value: The value to set the property to.\n @error: Return location for error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @set_property function in #GDBusInterfaceVTable.\n\n Returns: %TRUE if the property was set to @value, %FALSE if @error is set.\n\n Since: 2.26"]
pub type GDBusInterfaceSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        value: *mut GVariant,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GDBusInterfaceVTable:\n @method_call: Function for handling incoming method calls.\n @get_property: Function for getting a property.\n @set_property: Function for setting a property.\n\n Virtual table for handling properties and method calls for a D-Bus\n interface.\n\n Since 2.38, if you want to handle getting/setting D-Bus properties\n asynchronously, give %NULL as your get_property() or set_property()\n function. The D-Bus call will be directed to your @method_call function,\n with the provided @interface_name set to \"org.freedesktop.DBus.Properties\".\n\n Ownership of the #GDBusMethodInvocation object passed to the\n method_call() function is transferred to your handler; you must\n call one of the methods of #GDBusMethodInvocation to return a reply\n (possibly empty), or an error. These functions also take ownership\n of the passed-in invocation object, so unless the invocation\n object has otherwise been referenced, it will be then be freed.\n Calling one of these functions may be done within your\n method_call() implementation but it also can be done at a later\n point to handle the method asynchronously.\n\n The usual checks on the validity of the calls is performed. For\n `Get` calls, an error is automatically returned if the property does\n not exist or the permissions do not allow access. The same checks are\n performed for `Set` calls, and the provided value is also checked for\n being the correct type.\n\n For both `Get` and `Set` calls, the #GDBusMethodInvocation\n passed to the @method_call handler can be queried with\n g_dbus_method_invocation_get_property_info() to get a pointer\n to the #GDBusPropertyInfo of the property.\n\n If you have readable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @get_property()\n function or provide implementations of both the `Get` and `GetAll`\n methods on org.freedesktop.DBus.Properties interface in your @method_call\n function. Note that the required return type of the `Get` call is\n `(v)`, not the type of the property. `GetAll` expects a return value\n of type `a{sv}`.\n\n If you have writable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @set_property()\n function or provide an implementation of the `Set` call. If implementing\n the call, you must return the value of type %G_VARIANT_TYPE_UNIT.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceVTable {
    pub method_call: GDBusInterfaceMethodCallFunc,
    pub get_property: GDBusInterfaceGetPropertyFunc,
    pub set_property: GDBusInterfaceSetPropertyFunc,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusInterfaceVTable"][::std::mem::size_of::<_GDBusInterfaceVTable>() - 88usize];
    ["Alignment of _GDBusInterfaceVTable"]
        [::std::mem::align_of::<_GDBusInterfaceVTable>() - 8usize];
    ["Offset of field: _GDBusInterfaceVTable::method_call"]
        [::std::mem::offset_of!(_GDBusInterfaceVTable, method_call) - 0usize];
    ["Offset of field: _GDBusInterfaceVTable::get_property"]
        [::std::mem::offset_of!(_GDBusInterfaceVTable, get_property) - 8usize];
    ["Offset of field: _GDBusInterfaceVTable::set_property"]
        [::std::mem::offset_of!(_GDBusInterfaceVTable, set_property) - 16usize];
    ["Offset of field: _GDBusInterfaceVTable::padding"]
        [::std::mem::offset_of!(_GDBusInterfaceVTable, padding) - 24usize];
};
unsafe extern "C" {
    pub fn g_dbus_connection_register_object(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        vtable: *const GDBusInterfaceVTable,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_register_object_with_closures(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        method_call_closure: *mut GClosure,
        get_property_closure: *mut GClosure,
        set_property_closure: *mut GClosure,
        error: *mut *mut GError,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_unregister_object(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
#[doc = " GDBusSubtreeEnumerateFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @enumerate function in #GDBusSubtreeVTable.\n\n This function is called when generating introspection data and also\n when preparing to dispatch incoming messages in the event that the\n %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not\n specified (ie: to verify that the object path is valid).\n\n Hierarchies are not supported; the items that you return should not\n contain the `/` character.\n\n The return value will be freed with g_strfreev().\n\n Returns: (array zero-terminated=1) (transfer full): A newly allocated array of strings for node names that are children of @object_path.\n\n Since: 2.26"]
pub type GDBusSubtreeEnumerateFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut gchar,
>;
#[doc = " GDBusSubtreeIntrospectFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @introspect function in #GDBusSubtreeVTable.\n\n Subtrees are flat.  @node, if non-%NULL, is always exactly one\n segment of the object path (ie: it never contains a slash).\n\n This function should return %NULL to indicate that there is no object\n at this node.\n\n If this function returns non-%NULL, the return value is expected to\n be a %NULL-terminated array of pointers to #GDBusInterfaceInfo\n structures describing the interfaces implemented by @node.  This\n array will have g_dbus_interface_info_unref() called on each item\n before being freed with g_free().\n\n The difference between returning %NULL and an array containing zero\n items is that the standard DBus interfaces will returned to the\n remote introspector in the empty array case, but not in the %NULL\n case.\n\n Returns: (array zero-terminated=1) (nullable) (transfer full): A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.\n\n Since: 2.26"]
pub type GDBusSubtreeIntrospectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        node: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut GDBusInterfaceInfo,
>;
#[doc = " GDBusSubtreeDispatchFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @interface_name: The D-Bus interface name that the method call or property access is for.\n @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.\n @out_user_data: (nullable) (not optional): Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @dispatch function in #GDBusSubtreeVTable.\n\n Subtrees are flat.  @node, if non-%NULL, is always exactly one\n segment of the object path (ie: it never contains a slash).\n\n Returns: (nullable): A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.\n\n Since: 2.26"]
pub type GDBusSubtreeDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        node: *const gchar,
        out_user_data: *mut gpointer,
        user_data: gpointer,
    ) -> *const GDBusInterfaceVTable,
>;
#[doc = " GDBusSubtreeVTable:\n @enumerate: Function for enumerating child nodes.\n @introspect: Function for introspecting a child node.\n @dispatch: Function for dispatching a remote call on a child node.\n\n Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusSubtreeVTable {
    pub enumerate: GDBusSubtreeEnumerateFunc,
    pub introspect: GDBusSubtreeIntrospectFunc,
    pub dispatch: GDBusSubtreeDispatchFunc,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusSubtreeVTable"][::std::mem::size_of::<_GDBusSubtreeVTable>() - 88usize];
    ["Alignment of _GDBusSubtreeVTable"][::std::mem::align_of::<_GDBusSubtreeVTable>() - 8usize];
    ["Offset of field: _GDBusSubtreeVTable::enumerate"]
        [::std::mem::offset_of!(_GDBusSubtreeVTable, enumerate) - 0usize];
    ["Offset of field: _GDBusSubtreeVTable::introspect"]
        [::std::mem::offset_of!(_GDBusSubtreeVTable, introspect) - 8usize];
    ["Offset of field: _GDBusSubtreeVTable::dispatch"]
        [::std::mem::offset_of!(_GDBusSubtreeVTable, dispatch) - 16usize];
    ["Offset of field: _GDBusSubtreeVTable::padding"]
        [::std::mem::offset_of!(_GDBusSubtreeVTable, padding) - 24usize];
};
unsafe extern "C" {
    pub fn g_dbus_connection_register_subtree(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        vtable: *const GDBusSubtreeVTable,
        flags: GDBusSubtreeFlags,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_unregister_subtree(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
#[doc = " GDBusSignalCallback:\n @connection: A #GDBusConnection.\n @sender_name: (nullable): The unique bus name of the sender of the signal,\nor %NULL on a peer-to-peer D-Bus connection.\n @object_path: The object path that the signal was emitted on.\n @interface_name: The name of the interface.\n @signal_name: The name of the signal.\n @parameters: A #GVariant tuple with parameters for the signal.\n @user_data: User data passed when subscribing to the signal.\n\n Signature for callback function used in g_dbus_connection_signal_subscribe().\n\n Since: 2.26"]
pub type GDBusSignalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        user_data: gpointer,
    ),
>;
unsafe extern "C" {
    pub fn g_dbus_connection_signal_subscribe(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        interface_name: *const gchar,
        member: *const gchar,
        object_path: *const gchar,
        arg0: *const gchar,
        flags: GDBusSignalFlags,
        callback: GDBusSignalCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_signal_unsubscribe(
        connection: *mut GDBusConnection,
        subscription_id: guint,
    );
}
#[doc = " GDBusMessageFilterFunction:\n @connection: (transfer none): A #GDBusConnection.\n @message: (transfer full): A locked #GDBusMessage that the filter function takes ownership of.\n @incoming: %TRUE if it is a message received from the other peer, %FALSE if it is\n a message to be sent to the other peer.\n @user_data: User data passed when adding the filter.\n\n Signature for function used in g_dbus_connection_add_filter().\n\n A filter function is passed a #GDBusMessage and expected to return\n a #GDBusMessage too. Passive filter functions that don't modify the\n message can simply return the @message object:\n |[\n static GDBusMessage *\n passive_filter (GDBusConnection *connection\n                 GDBusMessage    *message,\n                 gboolean         incoming,\n                 gpointer         user_data)\n {\n   // inspect @message\n   return message;\n }\n ]|\n Filter functions that wants to drop a message can simply return %NULL:\n |[\n static GDBusMessage *\n drop_filter (GDBusConnection *connection\n              GDBusMessage    *message,\n              gboolean         incoming,\n              gpointer         user_data)\n {\n   if (should_drop_message)\n     {\n       g_object_unref (message);\n       message = NULL;\n     }\n   return message;\n }\n ]|\n Finally, a filter function may modify a message by copying it:\n |[\n static GDBusMessage *\n modifying_filter (GDBusConnection *connection\n                   GDBusMessage    *message,\n                   gboolean         incoming,\n                   gpointer         user_data)\n {\n   GDBusMessage *copy;\n   GError *error;\n\n   error = NULL;\n   copy = g_dbus_message_copy (message, &error);\n   // handle @error being set\n   g_object_unref (message);\n\n   // modify @copy\n\n   return copy;\n }\n ]|\n If the returned #GDBusMessage is different from @message and cannot\n be sent on @connection (it could use features, such as file\n descriptors, not compatible with @connection), then a warning is\n logged to standard error. Applications can\n check this ahead of time using g_dbus_message_to_blob() passing a\n #GDBusCapabilityFlags value obtained from @connection.\n\n Returns: (transfer full) (nullable): A #GDBusMessage that will be freed with\n g_object_unref() or %NULL to drop the message. Passive filter\n functions can simply return the passed @message object.\n\n Since: 2.26"]
pub type GDBusMessageFilterFunction = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        incoming: gboolean,
        user_data: gpointer,
    ) -> *mut GDBusMessage,
>;
unsafe extern "C" {
    pub fn g_dbus_connection_add_filter(
        connection: *mut GDBusConnection,
        filter_function: GDBusMessageFilterFunction,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection, filter_id: guint);
}
unsafe extern "C" {
    pub fn g_dbus_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_dbus_error_is_remote_error(error: *const GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_error_get_remote_error(error: *const GError) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_error_strip_remote_error(error: *mut GError) -> gboolean;
}
#[doc = " GDBusErrorEntry:\n @error_code: An error code.\n @dbus_error_name: The D-Bus error name to associate with @error_code.\n\n Struct used in g_dbus_error_register_error_domain().\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusErrorEntry {
    pub error_code: gint,
    pub dbus_error_name: *const gchar,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusErrorEntry"][::std::mem::size_of::<_GDBusErrorEntry>() - 16usize];
    ["Alignment of _GDBusErrorEntry"][::std::mem::align_of::<_GDBusErrorEntry>() - 8usize];
    ["Offset of field: _GDBusErrorEntry::error_code"]
        [::std::mem::offset_of!(_GDBusErrorEntry, error_code) - 0usize];
    ["Offset of field: _GDBusErrorEntry::dbus_error_name"]
        [::std::mem::offset_of!(_GDBusErrorEntry, dbus_error_name) - 8usize];
};
unsafe extern "C" {
    pub fn g_dbus_error_register_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_error_unregister_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_error_register_error_domain(
        error_domain_quark_name: *const gchar,
        quark_volatile: *mut gsize,
        entries: *const GDBusErrorEntry,
        num_entries: guint,
    );
}
unsafe extern "C" {
    pub fn g_dbus_error_new_for_dbus_error(
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
    ) -> *mut GError;
}
unsafe extern "C" {
    pub fn g_dbus_error_set_dbus_error(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_dbus_error_set_dbus_error_valist(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_dbus_error_encode_gerror(error: *const GError) -> *mut gchar;
}
#[doc = " GDBusInterfaceIface:\n @parent_iface: The parent interface.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info().\n @get_object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().\n @set_object: Sets the enclosing #GDBusObject. See g_dbus_interface_set_object().\n @dup_object: Gets a reference to the enclosing #GDBusObject. See g_dbus_interface_dup_object(). Added in 2.32.\n\n Base type for D-Bus interfaces.\n\n Since: 2.30"]
pub type GDBusInterfaceIface = _GDBusInterfaceIface;
#[doc = " GDBusInterfaceIface:\n @parent_iface: The parent interface.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info().\n @get_object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().\n @set_object: Sets the enclosing #GDBusObject. See g_dbus_interface_set_object().\n @dup_object: Gets a reference to the enclosing #GDBusObject. See g_dbus_interface_dup_object(). Added in 2.32.\n\n Base type for D-Bus interfaces.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceIface {
    pub parent_iface: GTypeInterface,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo,
    >,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
    pub set_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface, object: *mut GDBusObject),
    >,
    pub dup_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusInterfaceIface"][::std::mem::size_of::<_GDBusInterfaceIface>() - 48usize];
    ["Alignment of _GDBusInterfaceIface"][::std::mem::align_of::<_GDBusInterfaceIface>() - 8usize];
    ["Offset of field: _GDBusInterfaceIface::parent_iface"]
        [::std::mem::offset_of!(_GDBusInterfaceIface, parent_iface) - 0usize];
    ["Offset of field: _GDBusInterfaceIface::get_info"]
        [::std::mem::offset_of!(_GDBusInterfaceIface, get_info) - 16usize];
    ["Offset of field: _GDBusInterfaceIface::get_object"]
        [::std::mem::offset_of!(_GDBusInterfaceIface, get_object) - 24usize];
    ["Offset of field: _GDBusInterfaceIface::set_object"]
        [::std::mem::offset_of!(_GDBusInterfaceIface, set_object) - 32usize];
    ["Offset of field: _GDBusInterfaceIface::dup_object"]
        [::std::mem::offset_of!(_GDBusInterfaceIface, dup_object) - 40usize];
};
unsafe extern "C" {
    pub fn g_dbus_interface_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo;
}
unsafe extern "C" {
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
unsafe extern "C" {
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface, object: *mut GDBusObject);
}
unsafe extern "C" {
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
#[doc = " GDBusInterfaceSkeletonClass:\n @parent_class: The parent class.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.\n @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.\n @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().\n @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().\n @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.\n\n Class structure for #GDBusInterfaceSkeleton.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeletonClass = _GDBusInterfaceSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusInterfaceSkeletonPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusInterfaceSkeleton"][::std::mem::size_of::<_GDBusInterfaceSkeleton>() - 32usize];
    ["Alignment of _GDBusInterfaceSkeleton"]
        [::std::mem::align_of::<_GDBusInterfaceSkeleton>() - 8usize];
    ["Offset of field: _GDBusInterfaceSkeleton::parent_instance"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeleton, parent_instance) - 0usize];
    ["Offset of field: _GDBusInterfaceSkeleton::priv_"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeleton, priv_) - 24usize];
};
#[doc = " GDBusInterfaceSkeletonClass:\n @parent_class: The parent class.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.\n @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.\n @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().\n @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().\n @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.\n\n Class structure for #GDBusInterfaceSkeleton.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonClass {
    pub parent_class: GObjectClass,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo,
    >,
    pub get_vtable: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable,
    >,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GVariant,
    >,
    pub flush: ::std::option::Option<unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton)>,
    pub vfunc_padding: [gpointer; 8usize],
    pub g_authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub signal_padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusInterfaceSkeletonClass"]
        [::std::mem::size_of::<_GDBusInterfaceSkeletonClass>() - 304usize];
    ["Alignment of _GDBusInterfaceSkeletonClass"]
        [::std::mem::align_of::<_GDBusInterfaceSkeletonClass>() - 8usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::parent_class"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, parent_class) - 0usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::get_info"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, get_info) - 136usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::get_vtable"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, get_vtable) - 144usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::get_properties"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, get_properties) - 152usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::flush"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, flush) - 160usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::vfunc_padding"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, vfunc_padding) - 168usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::g_authorize_method"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, g_authorize_method) - 232usize];
    ["Offset of field: _GDBusInterfaceSkeletonClass::signal_padding"]
        [::std::mem::offset_of!(_GDBusInterfaceSkeletonClass, signal_padding) - 240usize];
};
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_flags(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> GDBusInterfaceSkeletonFlags;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_set_flags(
        interface_: *mut GDBusInterfaceSkeleton,
        flags: GDBusInterfaceSkeletonFlags,
    );
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_info(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceInfo;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_vtable(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceVTable;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_properties(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_flush(interface_: *mut GDBusInterfaceSkeleton);
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_export(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_unexport(interface_: *mut GDBusInterfaceSkeleton);
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_unexport_from_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    );
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_connection(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_connections(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_has_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_get_object_path(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *const gchar;
}
#[doc = " GDBusAnnotationInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @key: The name of the annotation, e.g. \"org.freedesktop.DBus.Deprecated\".\n @value: The value of the annotation.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an annotation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAnnotationInfo {
    pub ref_count: gint,
    pub key: *mut gchar,
    pub value: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusAnnotationInfo"][::std::mem::size_of::<_GDBusAnnotationInfo>() - 32usize];
    ["Alignment of _GDBusAnnotationInfo"][::std::mem::align_of::<_GDBusAnnotationInfo>() - 8usize];
    ["Offset of field: _GDBusAnnotationInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusAnnotationInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusAnnotationInfo::key"]
        [::std::mem::offset_of!(_GDBusAnnotationInfo, key) - 8usize];
    ["Offset of field: _GDBusAnnotationInfo::value"]
        [::std::mem::offset_of!(_GDBusAnnotationInfo, value) - 16usize];
    ["Offset of field: _GDBusAnnotationInfo::annotations"]
        [::std::mem::offset_of!(_GDBusAnnotationInfo, annotations) - 24usize];
};
#[doc = " GDBusArgInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: Name of the argument, e.g. @unix_user_id.\n @signature: D-Bus signature of the argument (a single complete type).\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an argument for a method or a signal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusArgInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusArgInfo"][::std::mem::size_of::<_GDBusArgInfo>() - 32usize];
    ["Alignment of _GDBusArgInfo"][::std::mem::align_of::<_GDBusArgInfo>() - 8usize];
    ["Offset of field: _GDBusArgInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusArgInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusArgInfo::name"][::std::mem::offset_of!(_GDBusArgInfo, name) - 8usize];
    ["Offset of field: _GDBusArgInfo::signature"]
        [::std::mem::offset_of!(_GDBusArgInfo, signature) - 16usize];
    ["Offset of field: _GDBusArgInfo::annotations"]
        [::std::mem::offset_of!(_GDBusArgInfo, annotations) - 24usize];
};
#[doc = " GDBusMethodInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus method, e.g. @RequestName.\n @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.\n @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a method on an D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusMethodInfo"][::std::mem::size_of::<_GDBusMethodInfo>() - 40usize];
    ["Alignment of _GDBusMethodInfo"][::std::mem::align_of::<_GDBusMethodInfo>() - 8usize];
    ["Offset of field: _GDBusMethodInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusMethodInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusMethodInfo::name"]
        [::std::mem::offset_of!(_GDBusMethodInfo, name) - 8usize];
    ["Offset of field: _GDBusMethodInfo::in_args"]
        [::std::mem::offset_of!(_GDBusMethodInfo, in_args) - 16usize];
    ["Offset of field: _GDBusMethodInfo::out_args"]
        [::std::mem::offset_of!(_GDBusMethodInfo, out_args) - 24usize];
    ["Offset of field: _GDBusMethodInfo::annotations"]
        [::std::mem::offset_of!(_GDBusMethodInfo, annotations) - 32usize];
};
#[doc = " GDBusSignalInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus signal, e.g. \"NameOwnerChanged\".\n @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a signal on a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusSignalInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusSignalInfo"][::std::mem::size_of::<_GDBusSignalInfo>() - 32usize];
    ["Alignment of _GDBusSignalInfo"][::std::mem::align_of::<_GDBusSignalInfo>() - 8usize];
    ["Offset of field: _GDBusSignalInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusSignalInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusSignalInfo::name"]
        [::std::mem::offset_of!(_GDBusSignalInfo, name) - 8usize];
    ["Offset of field: _GDBusSignalInfo::args"]
        [::std::mem::offset_of!(_GDBusSignalInfo, args) - 16usize];
    ["Offset of field: _GDBusSignalInfo::annotations"]
        [::std::mem::offset_of!(_GDBusSignalInfo, annotations) - 24usize];
};
#[doc = " GDBusPropertyInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus property, e.g. \"SupportedFilesystems\".\n @signature: The D-Bus signature of the property (a single complete type).\n @flags: Access control flags for the property.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus property on a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusPropertyInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusPropertyInfo"][::std::mem::size_of::<_GDBusPropertyInfo>() - 40usize];
    ["Alignment of _GDBusPropertyInfo"][::std::mem::align_of::<_GDBusPropertyInfo>() - 8usize];
    ["Offset of field: _GDBusPropertyInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusPropertyInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusPropertyInfo::name"]
        [::std::mem::offset_of!(_GDBusPropertyInfo, name) - 8usize];
    ["Offset of field: _GDBusPropertyInfo::signature"]
        [::std::mem::offset_of!(_GDBusPropertyInfo, signature) - 16usize];
    ["Offset of field: _GDBusPropertyInfo::flags"]
        [::std::mem::offset_of!(_GDBusPropertyInfo, flags) - 24usize];
    ["Offset of field: _GDBusPropertyInfo::annotations"]
        [::std::mem::offset_of!(_GDBusPropertyInfo, annotations) - 32usize];
};
#[doc = " GDBusInterfaceInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus interface, e.g. \"org.freedesktop.DBus.Properties\".\n @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.\n @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.\n @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusInterfaceInfo"][::std::mem::size_of::<_GDBusInterfaceInfo>() - 48usize];
    ["Alignment of _GDBusInterfaceInfo"][::std::mem::align_of::<_GDBusInterfaceInfo>() - 8usize];
    ["Offset of field: _GDBusInterfaceInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusInterfaceInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusInterfaceInfo::name"]
        [::std::mem::offset_of!(_GDBusInterfaceInfo, name) - 8usize];
    ["Offset of field: _GDBusInterfaceInfo::methods"]
        [::std::mem::offset_of!(_GDBusInterfaceInfo, methods) - 16usize];
    ["Offset of field: _GDBusInterfaceInfo::signals"]
        [::std::mem::offset_of!(_GDBusInterfaceInfo, signals) - 24usize];
    ["Offset of field: _GDBusInterfaceInfo::properties"]
        [::std::mem::offset_of!(_GDBusInterfaceInfo, properties) - 32usize];
    ["Offset of field: _GDBusInterfaceInfo::annotations"]
        [::std::mem::offset_of!(_GDBusInterfaceInfo, annotations) - 40usize];
};
#[doc = " GDBusNodeInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.\n @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.\n @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about nodes in a remote object hierarchy.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusNodeInfo {
    pub ref_count: gint,
    pub path: *mut gchar,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusNodeInfo"][::std::mem::size_of::<_GDBusNodeInfo>() - 40usize];
    ["Alignment of _GDBusNodeInfo"][::std::mem::align_of::<_GDBusNodeInfo>() - 8usize];
    ["Offset of field: _GDBusNodeInfo::ref_count"]
        [::std::mem::offset_of!(_GDBusNodeInfo, ref_count) - 0usize];
    ["Offset of field: _GDBusNodeInfo::path"]
        [::std::mem::offset_of!(_GDBusNodeInfo, path) - 8usize];
    ["Offset of field: _GDBusNodeInfo::interfaces"]
        [::std::mem::offset_of!(_GDBusNodeInfo, interfaces) - 16usize];
    ["Offset of field: _GDBusNodeInfo::nodes"]
        [::std::mem::offset_of!(_GDBusNodeInfo, nodes) - 24usize];
    ["Offset of field: _GDBusNodeInfo::annotations"]
        [::std::mem::offset_of!(_GDBusNodeInfo, annotations) - 32usize];
};
unsafe extern "C" {
    pub fn g_dbus_annotation_info_lookup(
        annotations: *mut *mut GDBusAnnotationInfo,
        name: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_lookup_method(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusMethodInfo;
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_lookup_signal(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusSignalInfo;
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_lookup_property(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusPropertyInfo;
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_generate_xml(
        info: *mut GDBusInterfaceInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
unsafe extern "C" {
    pub fn g_dbus_node_info_new_for_xml(
        xml_data: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GDBusNodeInfo;
}
unsafe extern "C" {
    pub fn g_dbus_node_info_lookup_interface(
        info: *mut GDBusNodeInfo,
        name: *const gchar,
    ) -> *mut GDBusInterfaceInfo;
}
unsafe extern "C" {
    pub fn g_dbus_node_info_generate_xml(
        info: *mut GDBusNodeInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
unsafe extern "C" {
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo) -> *mut GDBusNodeInfo;
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo) -> *mut GDBusInterfaceInfo;
}
unsafe extern "C" {
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo) -> *mut GDBusMethodInfo;
}
unsafe extern "C" {
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo) -> *mut GDBusSignalInfo;
}
unsafe extern "C" {
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo) -> *mut GDBusPropertyInfo;
}
unsafe extern "C" {
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
}
unsafe extern "C" {
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo) -> *mut GDBusAnnotationInfo;
}
unsafe extern "C" {
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);
}
unsafe extern "C" {
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);
}
unsafe extern "C" {
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);
}
unsafe extern "C" {
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);
}
unsafe extern "C" {
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);
}
unsafe extern "C" {
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
}
unsafe extern "C" {
    pub fn g_dbus_node_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_interface_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_method_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_signal_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_property_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_arg_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_annotation_info_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMenuModel {
    _unused: [u8; 0],
}
pub type GDBusMenuModel = _GDBusMenuModel;
unsafe extern "C" {
    pub fn g_dbus_menu_model_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_menu_model_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusMenuModel;
}
unsafe extern "C" {
    pub fn g_dbus_message_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_signal(
        path: *const gchar,
        interface_: *const gchar,
        signal: *const gchar,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_method_call(
        name: *const gchar,
        path: *const gchar,
        interface_: *const gchar,
        method: *const gchar,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_method_reply(
        method_call_message: *mut GDBusMessage,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_method_error(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        ...
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_method_error_valist(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_method_error_literal(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message: *const gchar,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: guint) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
}
unsafe extern "C" {
    pub fn g_dbus_message_copy(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage) -> GDBusMessageByteOrder;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_byte_order(
        message: *mut GDBusMessage,
        byte_order: GDBusMessageByteOrder,
    );
}
unsafe extern "C" {
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage) -> GDBusMessageType;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage, type_: GDBusMessageType);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage) -> GDBusMessageFlags;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage, flags: GDBusMessageFlags);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> guint32;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage, serial: guint32);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage, body: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage) -> *mut GUnixFDList;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage, fd_list: *mut GUnixFDList);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage) -> guint32;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage, value: guint32);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage, value: *const gchar);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage) -> guint32;
}
unsafe extern "C" {
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage, value: guint32);
}
unsafe extern "C" {
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_get_arg0_path(message: *mut GDBusMessage) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_new_from_blob(
        blob: *mut guchar,
        blob_len: gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_message_bytes_needed(
        blob: *mut guchar,
        blob_len: gsize,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_dbus_message_to_blob(
        message: *mut GDBusMessage,
        out_size: *mut gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut guchar;
}
unsafe extern "C" {
    pub fn g_dbus_message_to_gerror(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_sender(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_object_path(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_interface_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_method_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_method_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusMethodInfo;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_property_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusPropertyInfo;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_connection(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_message(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusMessage;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_parameters(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_get_user_data(
        invocation: *mut GDBusMethodInvocation,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_value(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
        fd_list: *mut GUnixFDList,
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_error(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_error_valist(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_error_literal(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_gerror(
        invocation: *mut GDBusMethodInvocation,
        error: *const GError,
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_take_error(
        invocation: *mut GDBusMethodInvocation,
        error: *mut GError,
    );
}
unsafe extern "C" {
    pub fn g_dbus_method_invocation_return_dbus_error(
        invocation: *mut GDBusMethodInvocation,
        error_name: *const gchar,
        error_message: *const gchar,
    );
}
#[doc = " GBusAcquiredCallback:\n @connection: The #GDBusConnection to a message bus.\n @name: The name that is requested to be owned.\n @user_data: User data passed to g_bus_own_name().\n\n Invoked when a connection to a message bus has been obtained.\n\n Since: 2.26"]
pub type GBusAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
#[doc = " GBusNameAcquiredCallback:\n @connection: The #GDBusConnection on which to acquired the name.\n @name: The name being owned.\n @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().\n\n Invoked when the name is acquired.\n\n Since: 2.26"]
pub type GBusNameAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
#[doc = " GBusNameLostCallback:\n @connection: The #GDBusConnection on which to acquire the name or %NULL if\n the connection was disconnected.\n @name: The name being owned.\n @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().\n\n Invoked when the name is lost or @connection has been closed.\n\n Since: 2.26"]
pub type GBusNameLostCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
unsafe extern "C" {
    pub fn g_bus_own_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_handler: GBusAcquiredCallback,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_own_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_own_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_closure: *mut GClosure,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_own_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_unown_name(owner_id: guint);
}
#[doc = " GBusNameAppearedCallback:\n @connection: The #GDBusConnection the name is being watched on.\n @name: The name being watched.\n @name_owner: Unique name of the owner of the name being watched.\n @user_data: User data passed to g_bus_watch_name().\n\n Invoked when the name being watched is known to have to have an owner.\n\n Since: 2.26"]
pub type GBusNameAppearedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        name: *const gchar,
        name_owner: *const gchar,
        user_data: gpointer,
    ),
>;
#[doc = " GBusNameVanishedCallback:\n @connection: The #GDBusConnection the name is being watched on, or\n     %NULL.\n @name: The name being watched.\n @user_data: User data passed to g_bus_watch_name().\n\n Invoked when the name being watched is known not to have to have an owner.\n\n This is also invoked when the #GDBusConnection on which the watch was\n established has been closed.  In that case, @connection will be\n %NULL.\n\n Since: 2.26"]
pub type GBusNameVanishedCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
unsafe extern "C" {
    pub fn g_bus_watch_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_watch_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_watch_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_watch_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_bus_unwatch_name(watcher_id: guint);
}
#[doc = " GDBusObjectIface:\n @parent_iface: The parent interface.\n @get_object_path: Returns the object path. See g_dbus_object_get_object_path().\n @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().\n @get_interface: Returns an interface by name. See g_dbus_object_get_interface().\n @interface_added: Signal handler for the #GDBusObject::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.\n\n Base object type for D-Bus objects.\n\n Since: 2.30"]
pub type GDBusObjectIface = _GDBusObjectIface;
#[doc = " GDBusObjectIface:\n @parent_iface: The parent interface.\n @get_object_path: Returns the object path. See g_dbus_object_get_object_path().\n @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().\n @get_interface: Returns an interface by name. See g_dbus_object_get_interface().\n @interface_added: Signal handler for the #GDBusObject::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.\n\n Base object type for D-Bus objects.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *const gchar>,
    pub get_interfaces:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *mut GList>,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObject,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectIface"][::std::mem::size_of::<_GDBusObjectIface>() - 56usize];
    ["Alignment of _GDBusObjectIface"][::std::mem::align_of::<_GDBusObjectIface>() - 8usize];
    ["Offset of field: _GDBusObjectIface::parent_iface"]
        [::std::mem::offset_of!(_GDBusObjectIface, parent_iface) - 0usize];
    ["Offset of field: _GDBusObjectIface::get_object_path"]
        [::std::mem::offset_of!(_GDBusObjectIface, get_object_path) - 16usize];
    ["Offset of field: _GDBusObjectIface::get_interfaces"]
        [::std::mem::offset_of!(_GDBusObjectIface, get_interfaces) - 24usize];
    ["Offset of field: _GDBusObjectIface::get_interface"]
        [::std::mem::offset_of!(_GDBusObjectIface, get_interface) - 32usize];
    ["Offset of field: _GDBusObjectIface::interface_added"]
        [::std::mem::offset_of!(_GDBusObjectIface, interface_added) - 40usize];
    ["Offset of field: _GDBusObjectIface::interface_removed"]
        [::std::mem::offset_of!(_GDBusObjectIface, interface_removed) - 48usize];
};
unsafe extern "C" {
    pub fn g_dbus_object_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_dbus_object_get_interface(
        object: *mut GDBusObject,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
#[doc = " GDBusObjectManagerIface:\n @parent_iface: The parent interface.\n @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().\n @get_objects: Virtual function for g_dbus_object_manager_get_objects().\n @get_object: Virtual function for g_dbus_object_manager_get_object().\n @get_interface: Virtual function for g_dbus_object_manager_get_interface().\n @object_added: Signal handler for the #GDBusObjectManager::object-added signal.\n @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.\n @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.\n\n Base type for D-Bus object managers.\n\n Since: 2.30"]
pub type GDBusObjectManagerIface = _GDBusObjectManagerIface;
#[doc = " GDBusObjectManagerIface:\n @parent_iface: The parent interface.\n @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().\n @get_objects: Virtual function for g_dbus_object_manager_get_objects().\n @get_object: Virtual function for g_dbus_object_manager_get_object().\n @get_interface: Virtual function for g_dbus_object_manager_get_interface().\n @object_added: Signal handler for the #GDBusObjectManager::object-added signal.\n @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.\n @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.\n\n Base type for D-Bus object managers.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *const gchar,
    >,
    pub get_objects:
        ::std::option::Option<unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *mut GList>,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
        ) -> *mut GDBusObject,
    >,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub object_added: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub object_removed: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectManagerIface"]
        [::std::mem::size_of::<_GDBusObjectManagerIface>() - 80usize];
    ["Alignment of _GDBusObjectManagerIface"]
        [::std::mem::align_of::<_GDBusObjectManagerIface>() - 8usize];
    ["Offset of field: _GDBusObjectManagerIface::parent_iface"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, parent_iface) - 0usize];
    ["Offset of field: _GDBusObjectManagerIface::get_object_path"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, get_object_path) - 16usize];
    ["Offset of field: _GDBusObjectManagerIface::get_objects"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, get_objects) - 24usize];
    ["Offset of field: _GDBusObjectManagerIface::get_object"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, get_object) - 32usize];
    ["Offset of field: _GDBusObjectManagerIface::get_interface"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, get_interface) - 40usize];
    ["Offset of field: _GDBusObjectManagerIface::object_added"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, object_added) - 48usize];
    ["Offset of field: _GDBusObjectManagerIface::object_removed"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, object_removed) - 56usize];
    ["Offset of field: _GDBusObjectManagerIface::interface_added"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, interface_added) - 64usize];
    ["Offset of field: _GDBusObjectManagerIface::interface_removed"]
        [::std::mem::offset_of!(_GDBusObjectManagerIface, interface_removed) - 72usize];
};
unsafe extern "C" {
    pub fn g_dbus_object_manager_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_get_object_path(manager: *mut GDBusObjectManager) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_get_object(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
    ) -> *mut GDBusObject;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_get_interface(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
#[doc = " GDBusObjectManagerClientClass:\n @parent_class: The parent class.\n @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.\n @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.\n\n Class structure for #GDBusObjectManagerClient.\n\n Since: 2.30"]
pub type GDBusObjectManagerClientClass = _GDBusObjectManagerClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClient {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerClientPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectManagerClient"]
        [::std::mem::size_of::<_GDBusObjectManagerClient>() - 32usize];
    ["Alignment of _GDBusObjectManagerClient"]
        [::std::mem::align_of::<_GDBusObjectManagerClient>() - 8usize];
    ["Offset of field: _GDBusObjectManagerClient::parent_instance"]
        [::std::mem::offset_of!(_GDBusObjectManagerClient, parent_instance) - 0usize];
    ["Offset of field: _GDBusObjectManagerClient::priv_"]
        [::std::mem::offset_of!(_GDBusObjectManagerClient, priv_) - 24usize];
};
#[doc = " GDBusObjectManagerClientClass:\n @parent_class: The parent class.\n @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.\n @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.\n\n Class structure for #GDBusObjectManagerClient.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientClass {
    pub parent_class: GObjectClass,
    pub interface_proxy_signal: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub interface_proxy_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectManagerClientClass"]
        [::std::mem::size_of::<_GDBusObjectManagerClientClass>() - 216usize];
    ["Alignment of _GDBusObjectManagerClientClass"]
        [::std::mem::align_of::<_GDBusObjectManagerClientClass>() - 8usize];
    ["Offset of field: _GDBusObjectManagerClientClass::parent_class"]
        [::std::mem::offset_of!(_GDBusObjectManagerClientClass, parent_class) - 0usize];
    ["Offset of field: _GDBusObjectManagerClientClass::interface_proxy_signal"]
        [::std::mem::offset_of!(_GDBusObjectManagerClientClass, interface_proxy_signal) - 136usize];
    ["Offset of field: _GDBusObjectManagerClientClass::interface_proxy_properties_changed"][::std::mem::offset_of!(
        _GDBusObjectManagerClientClass,
        interface_proxy_properties_changed
    )
        - 144usize];
    ["Offset of field: _GDBusObjectManagerClientClass::padding"]
        [::std::mem::offset_of!(_GDBusObjectManagerClientClass, padding) - 152usize];
};
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_new(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_get_connection(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_get_flags(
        manager: *mut GDBusObjectManagerClient,
    ) -> GDBusObjectManagerClientFlags;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_get_name(
        manager: *mut GDBusObjectManagerClient,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_get_name_owner(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut gchar;
}
#[doc = " GDBusObjectManagerServerClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectManagerServer.\n\n Since: 2.30"]
pub type GDBusObjectManagerServerClass = _GDBusObjectManagerServerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServer {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerServerPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectManagerServer"]
        [::std::mem::size_of::<_GDBusObjectManagerServer>() - 32usize];
    ["Alignment of _GDBusObjectManagerServer"]
        [::std::mem::align_of::<_GDBusObjectManagerServer>() - 8usize];
    ["Offset of field: _GDBusObjectManagerServer::parent_instance"]
        [::std::mem::offset_of!(_GDBusObjectManagerServer, parent_instance) - 0usize];
    ["Offset of field: _GDBusObjectManagerServer::priv_"]
        [::std::mem::offset_of!(_GDBusObjectManagerServer, priv_) - 24usize];
};
#[doc = " GDBusObjectManagerServerClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectManagerServer.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectManagerServerClass"]
        [::std::mem::size_of::<_GDBusObjectManagerServerClass>() - 200usize];
    ["Alignment of _GDBusObjectManagerServerClass"]
        [::std::mem::align_of::<_GDBusObjectManagerServerClass>() - 8usize];
    ["Offset of field: _GDBusObjectManagerServerClass::parent_class"]
        [::std::mem::offset_of!(_GDBusObjectManagerServerClass, parent_class) - 0usize];
    ["Offset of field: _GDBusObjectManagerServerClass::padding"]
        [::std::mem::offset_of!(_GDBusObjectManagerServerClass, padding) - 136usize];
};
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_new(
        object_path: *const gchar,
    ) -> *mut GDBusObjectManagerServer;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_get_connection(
        manager: *mut GDBusObjectManagerServer,
    ) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_set_connection(
        manager: *mut GDBusObjectManagerServer,
        connection: *mut GDBusConnection,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_export(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_export_uniquely(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_is_exported(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_server_unexport(
        manager: *mut GDBusObjectManagerServer,
        object_path: *const gchar,
    ) -> gboolean;
}
#[doc = " GDBusObjectProxyClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectProxy.\n\n Since: 2.30"]
pub type GDBusObjectProxyClass = _GDBusObjectProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectProxyPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectProxy"][::std::mem::size_of::<_GDBusObjectProxy>() - 32usize];
    ["Alignment of _GDBusObjectProxy"][::std::mem::align_of::<_GDBusObjectProxy>() - 8usize];
    ["Offset of field: _GDBusObjectProxy::parent_instance"]
        [::std::mem::offset_of!(_GDBusObjectProxy, parent_instance) - 0usize];
    ["Offset of field: _GDBusObjectProxy::priv_"]
        [::std::mem::offset_of!(_GDBusObjectProxy, priv_) - 24usize];
};
#[doc = " GDBusObjectProxyClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectProxy.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectProxyClass"][::std::mem::size_of::<_GDBusObjectProxyClass>() - 200usize];
    ["Alignment of _GDBusObjectProxyClass"]
        [::std::mem::align_of::<_GDBusObjectProxyClass>() - 8usize];
    ["Offset of field: _GDBusObjectProxyClass::parent_class"]
        [::std::mem::offset_of!(_GDBusObjectProxyClass, parent_class) - 0usize];
    ["Offset of field: _GDBusObjectProxyClass::padding"]
        [::std::mem::offset_of!(_GDBusObjectProxyClass, padding) - 136usize];
};
unsafe extern "C" {
    pub fn g_dbus_object_proxy_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_proxy_new(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
    ) -> *mut GDBusObjectProxy;
}
unsafe extern "C" {
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy)
        -> *mut GDBusConnection;
}
#[doc = " GDBusObjectSkeletonClass:\n @parent_class: The parent class.\n @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.\n\n Class structure for #GDBusObjectSkeleton.\n\n Since: 2.30"]
pub type GDBusObjectSkeletonClass = _GDBusObjectSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectSkeletonPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectSkeleton"][::std::mem::size_of::<_GDBusObjectSkeleton>() - 32usize];
    ["Alignment of _GDBusObjectSkeleton"][::std::mem::align_of::<_GDBusObjectSkeleton>() - 8usize];
    ["Offset of field: _GDBusObjectSkeleton::parent_instance"]
        [::std::mem::offset_of!(_GDBusObjectSkeleton, parent_instance) - 0usize];
    ["Offset of field: _GDBusObjectSkeleton::priv_"]
        [::std::mem::offset_of!(_GDBusObjectSkeleton, priv_) - 24usize];
};
#[doc = " GDBusObjectSkeletonClass:\n @parent_class: The parent class.\n @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.\n\n Class structure for #GDBusObjectSkeleton.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonClass {
    pub parent_class: GObjectClass,
    pub authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObjectSkeleton,
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusObjectSkeletonClass"]
        [::std::mem::size_of::<_GDBusObjectSkeletonClass>() - 208usize];
    ["Alignment of _GDBusObjectSkeletonClass"]
        [::std::mem::align_of::<_GDBusObjectSkeletonClass>() - 8usize];
    ["Offset of field: _GDBusObjectSkeletonClass::parent_class"]
        [::std::mem::offset_of!(_GDBusObjectSkeletonClass, parent_class) - 0usize];
    ["Offset of field: _GDBusObjectSkeletonClass::authorize_method"]
        [::std::mem::offset_of!(_GDBusObjectSkeletonClass, authorize_method) - 136usize];
    ["Offset of field: _GDBusObjectSkeletonClass::padding"]
        [::std::mem::offset_of!(_GDBusObjectSkeletonClass, padding) - 144usize];
};
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_new(object_path: *const gchar) -> *mut GDBusObjectSkeleton;
}
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
}
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_add_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_remove_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_remove_interface_by_name(
        object: *mut GDBusObjectSkeleton,
        interface_name: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_dbus_object_skeleton_set_object_path(
        object: *mut GDBusObjectSkeleton,
        object_path: *const gchar,
    );
}
#[doc = " GDBusProxyClass:\n @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.\n @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.\n\n Class structure for #GDBusProxy.\n\n Since: 2.26"]
pub type GDBusProxyClass = _GDBusProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusProxyPrivate = _GDBusProxyPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusProxyPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusProxy"][::std::mem::size_of::<_GDBusProxy>() - 32usize];
    ["Alignment of _GDBusProxy"][::std::mem::align_of::<_GDBusProxy>() - 8usize];
    ["Offset of field: _GDBusProxy::parent_instance"]
        [::std::mem::offset_of!(_GDBusProxy, parent_instance) - 0usize];
    ["Offset of field: _GDBusProxy::priv_"][::std::mem::offset_of!(_GDBusProxy, priv_) - 24usize];
};
#[doc = " GDBusProxyClass:\n @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.\n @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.\n\n Class structure for #GDBusProxy.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyClass {
    pub parent_class: GObjectClass,
    pub g_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub g_signal: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub padding: [gpointer; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDBusProxyClass"][::std::mem::size_of::<_GDBusProxyClass>() - 408usize];
    ["Alignment of _GDBusProxyClass"][::std::mem::align_of::<_GDBusProxyClass>() - 8usize];
    ["Offset of field: _GDBusProxyClass::parent_class"]
        [::std::mem::offset_of!(_GDBusProxyClass, parent_class) - 0usize];
    ["Offset of field: _GDBusProxyClass::g_properties_changed"]
        [::std::mem::offset_of!(_GDBusProxyClass, g_properties_changed) - 136usize];
    ["Offset of field: _GDBusProxyClass::g_signal"]
        [::std::mem::offset_of!(_GDBusProxyClass, g_signal) - 144usize];
    ["Offset of field: _GDBusProxyClass::padding"]
        [::std::mem::offset_of!(_GDBusProxyClass, padding) - 152usize];
};
unsafe extern "C" {
    pub fn g_dbus_proxy_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_new(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_proxy_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_new_for_bus(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_proxy_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy) -> *mut GDBusConnection;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> gint;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy, timeout_msec: gint);
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy) -> *mut GDBusInterfaceInfo;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy, info: *mut GDBusInterfaceInfo);
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_set_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_call(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_proxy_call_finish(
        proxy: *mut GDBusProxy,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_call_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(
        proxy: *mut GDBusProxy,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_server_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_server_new_sync(
        address: *const gchar,
        flags: GDBusServerFlags,
        guid: *const gchar,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusServer;
}
unsafe extern "C" {
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer) -> GDBusServerFlags;
}
unsafe extern "C" {
    pub fn g_dbus_server_start(server: *mut GDBusServer);
}
unsafe extern "C" {
    pub fn g_dbus_server_stop(server: *mut GDBusServer);
}
unsafe extern "C" {
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_is_guid(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_generate_guid() -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_is_name(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_is_unique_name(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_is_member_name(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_is_interface_name(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_is_error_name(string: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dbus_gvariant_to_gvalue(value: *mut GVariant, out_gvalue: *mut GValue);
}
unsafe extern "C" {
    pub fn g_dbus_gvalue_to_gvariant(
        gvalue: *const GValue,
        type_: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_dbus_escape_object_path_bytestring(bytes: *const guint8) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_escape_object_path(s: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_dbus_unescape_object_path(s: *const gchar) -> *mut guint8;
}
unsafe extern "C" {
    pub fn g_debug_controller_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugController {
    _unused: [u8; 0],
}
pub type GDebugController = _GDebugController;
#[doc = " GDebugControllerInterface:\n @g_iface: The parent interface.\n\n The virtual function table for #GDebugController.\n\n Since: 2.72"]
pub type GDebugControllerInterface = _GDebugControllerInterface;
pub type GDebugController_autoptr = *mut GDebugController;
pub type GDebugController_listautoptr = *mut GList;
pub type GDebugController_slistautoptr = *mut GSList;
pub type GDebugController_queueautoptr = *mut GQueue;
#[doc = " GDebugControllerInterface:\n @g_iface: The parent interface.\n\n The virtual function table for #GDebugController.\n\n Since: 2.72"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugControllerInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDebugControllerInterface"]
        [::std::mem::size_of::<_GDebugControllerInterface>() - 16usize];
    ["Alignment of _GDebugControllerInterface"]
        [::std::mem::align_of::<_GDebugControllerInterface>() - 8usize];
    ["Offset of field: _GDebugControllerInterface::g_iface"]
        [::std::mem::offset_of!(_GDebugControllerInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn g_debug_controller_get_debug_enabled(self_: *mut GDebugController) -> gboolean;
}
unsafe extern "C" {
    pub fn g_debug_controller_set_debug_enabled(
        self_: *mut GDebugController,
        debug_enabled: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_debug_controller_dbus_get_type() -> GType;
}
pub type GDebugControllerDBus = _GDebugControllerDBus;
#[doc = " GDebugControllerDBusClass:\n @parent_class: The parent class.\n @authorize: Default handler for the #GDebugControllerDBus::authorize signal.\n\n The virtual function table for #GDebugControllerDBus.\n\n Since: 2.72"]
pub type GDebugControllerDBusClass = _GDebugControllerDBusClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugControllerDBus {
    pub parent_instance: GObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDebugControllerDBus"][::std::mem::size_of::<_GDebugControllerDBus>() - 24usize];
    ["Alignment of _GDebugControllerDBus"]
        [::std::mem::align_of::<_GDebugControllerDBus>() - 8usize];
    ["Offset of field: _GDebugControllerDBus::parent_instance"]
        [::std::mem::offset_of!(_GDebugControllerDBus, parent_instance) - 0usize];
};
pub type GDebugControllerDBus_autoptr = *mut GDebugControllerDBus;
pub type GDebugControllerDBus_listautoptr = *mut GList;
pub type GDebugControllerDBus_slistautoptr = *mut GSList;
pub type GDebugControllerDBus_queueautoptr = *mut GQueue;
pub type GDebugControllerDBusClass_autoptr = *mut GDebugControllerDBusClass;
pub type GDebugControllerDBusClass_listautoptr = *mut GList;
pub type GDebugControllerDBusClass_slistautoptr = *mut GSList;
pub type GDebugControllerDBusClass_queueautoptr = *mut GQueue;
#[doc = " GDebugControllerDBusClass:\n @parent_class: The parent class.\n @authorize: Default handler for the #GDebugControllerDBus::authorize signal.\n\n The virtual function table for #GDebugControllerDBus.\n\n Since: 2.72"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugControllerDBusClass {
    pub parent_class: GObjectClass,
    pub authorize: ::std::option::Option<
        unsafe extern "C" fn(
            controller: *mut GDebugControllerDBus,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDebugControllerDBusClass"]
        [::std::mem::size_of::<_GDebugControllerDBusClass>() - 240usize];
    ["Alignment of _GDebugControllerDBusClass"]
        [::std::mem::align_of::<_GDebugControllerDBusClass>() - 8usize];
    ["Offset of field: _GDebugControllerDBusClass::parent_class"]
        [::std::mem::offset_of!(_GDebugControllerDBusClass, parent_class) - 0usize];
    ["Offset of field: _GDebugControllerDBusClass::authorize"]
        [::std::mem::offset_of!(_GDebugControllerDBusClass, authorize) - 136usize];
    ["Offset of field: _GDebugControllerDBusClass::padding"]
        [::std::mem::offset_of!(_GDebugControllerDBusClass, padding) - 144usize];
};
unsafe extern "C" {
    pub fn g_debug_controller_dbus_new(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDebugControllerDBus;
}
unsafe extern "C" {
    pub fn g_debug_controller_dbus_stop(self_: *mut GDebugControllerDBus);
}
#[doc = " GDriveIface:\n @g_iface: The parent interface.\n @changed: Signal emitted when the drive is changed.\n @disconnected: The removed signal that is emitted when the #GDrive have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.\n @eject_button: Signal emitted when the physical eject button (if any) of a drive have been pressed.\n @get_name: Returns the name for the given #GDrive.\n @get_icon: Returns a #GIcon for the given #GDrive.\n @has_volumes: Returns %TRUE if the #GDrive has mountable volumes.\n @get_volumes: Returns a list #GList of #GVolume for the #GDrive.\n @is_removable: Returns %TRUE if the #GDrive and/or its media is considered removable by the user. Since 2.50.\n @is_media_removable: Returns %TRUE if the #GDrive supports removal and insertion of media.\n @has_media: Returns %TRUE if the #GDrive has media inserted.\n @is_media_check_automatic: Returns %TRUE if the #GDrive is capable of automatically detecting media changes.\n @can_poll_for_media: Returns %TRUE if the #GDrive is capable of manually polling for media change.\n @can_eject: Returns %TRUE if the #GDrive can eject media.\n @eject: Ejects a #GDrive.\n @eject_finish: Finishes an eject operation.\n @poll_for_media: Poll for media insertion/removal on a #GDrive.\n @poll_for_media_finish: Finishes a media poll operation.\n @get_identifier: Returns the identifier of the given kind, or %NULL if\n    the #GDrive doesn't have one.\n @enumerate_identifiers: Returns an array strings listing the kinds\n    of identifiers which the #GDrive has.\n @get_start_stop_type: Gets a #GDriveStartStopType with details about starting/stopping the drive. Since 2.22.\n @can_stop: Returns %TRUE if a #GDrive can be stopped. Since 2.22.\n @stop: Stops a #GDrive. Since 2.22.\n @stop_finish: Finishes a stop operation. Since 2.22.\n @can_start: Returns %TRUE if a #GDrive can be started. Since 2.22.\n @can_start_degraded: Returns %TRUE if a #GDrive can be started degraded. Since 2.22.\n @start: Starts a #GDrive. Since 2.22.\n @start_finish: Finishes a start operation. Since 2.22.\n @stop_button: Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.\n @eject_with_operation: Starts ejecting a #GDrive using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_sort_key: Gets a key used for sorting #GDrive instances or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Returns a symbolic #GIcon for the given #GDrive. Since 2.34.\n\n Interface for creating #GDrive implementations."]
pub type GDriveIface = _GDriveIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDriveIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub disconnected: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub has_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub get_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GList>,
    pub is_media_removable:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub has_media: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub is_media_check_automatic:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_poll_for_media:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_for_media: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_for_media_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            kind: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub get_start_stop_type:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> GDriveStartStopType>,
    pub can_start: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_start_degraded:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GDriveStartFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_stop: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub is_removable: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDriveIface"][::std::mem::size_of::<_GDriveIface>() - 272usize];
    ["Alignment of _GDriveIface"][::std::mem::align_of::<_GDriveIface>() - 8usize];
    ["Offset of field: _GDriveIface::g_iface"]
        [::std::mem::offset_of!(_GDriveIface, g_iface) - 0usize];
    ["Offset of field: _GDriveIface::changed"]
        [::std::mem::offset_of!(_GDriveIface, changed) - 16usize];
    ["Offset of field: _GDriveIface::disconnected"]
        [::std::mem::offset_of!(_GDriveIface, disconnected) - 24usize];
    ["Offset of field: _GDriveIface::eject_button"]
        [::std::mem::offset_of!(_GDriveIface, eject_button) - 32usize];
    ["Offset of field: _GDriveIface::get_name"]
        [::std::mem::offset_of!(_GDriveIface, get_name) - 40usize];
    ["Offset of field: _GDriveIface::get_icon"]
        [::std::mem::offset_of!(_GDriveIface, get_icon) - 48usize];
    ["Offset of field: _GDriveIface::has_volumes"]
        [::std::mem::offset_of!(_GDriveIface, has_volumes) - 56usize];
    ["Offset of field: _GDriveIface::get_volumes"]
        [::std::mem::offset_of!(_GDriveIface, get_volumes) - 64usize];
    ["Offset of field: _GDriveIface::is_media_removable"]
        [::std::mem::offset_of!(_GDriveIface, is_media_removable) - 72usize];
    ["Offset of field: _GDriveIface::has_media"]
        [::std::mem::offset_of!(_GDriveIface, has_media) - 80usize];
    ["Offset of field: _GDriveIface::is_media_check_automatic"]
        [::std::mem::offset_of!(_GDriveIface, is_media_check_automatic) - 88usize];
    ["Offset of field: _GDriveIface::can_eject"]
        [::std::mem::offset_of!(_GDriveIface, can_eject) - 96usize];
    ["Offset of field: _GDriveIface::can_poll_for_media"]
        [::std::mem::offset_of!(_GDriveIface, can_poll_for_media) - 104usize];
    ["Offset of field: _GDriveIface::eject"]
        [::std::mem::offset_of!(_GDriveIface, eject) - 112usize];
    ["Offset of field: _GDriveIface::eject_finish"]
        [::std::mem::offset_of!(_GDriveIface, eject_finish) - 120usize];
    ["Offset of field: _GDriveIface::poll_for_media"]
        [::std::mem::offset_of!(_GDriveIface, poll_for_media) - 128usize];
    ["Offset of field: _GDriveIface::poll_for_media_finish"]
        [::std::mem::offset_of!(_GDriveIface, poll_for_media_finish) - 136usize];
    ["Offset of field: _GDriveIface::get_identifier"]
        [::std::mem::offset_of!(_GDriveIface, get_identifier) - 144usize];
    ["Offset of field: _GDriveIface::enumerate_identifiers"]
        [::std::mem::offset_of!(_GDriveIface, enumerate_identifiers) - 152usize];
    ["Offset of field: _GDriveIface::get_start_stop_type"]
        [::std::mem::offset_of!(_GDriveIface, get_start_stop_type) - 160usize];
    ["Offset of field: _GDriveIface::can_start"]
        [::std::mem::offset_of!(_GDriveIface, can_start) - 168usize];
    ["Offset of field: _GDriveIface::can_start_degraded"]
        [::std::mem::offset_of!(_GDriveIface, can_start_degraded) - 176usize];
    ["Offset of field: _GDriveIface::start"]
        [::std::mem::offset_of!(_GDriveIface, start) - 184usize];
    ["Offset of field: _GDriveIface::start_finish"]
        [::std::mem::offset_of!(_GDriveIface, start_finish) - 192usize];
    ["Offset of field: _GDriveIface::can_stop"]
        [::std::mem::offset_of!(_GDriveIface, can_stop) - 200usize];
    ["Offset of field: _GDriveIface::stop"][::std::mem::offset_of!(_GDriveIface, stop) - 208usize];
    ["Offset of field: _GDriveIface::stop_finish"]
        [::std::mem::offset_of!(_GDriveIface, stop_finish) - 216usize];
    ["Offset of field: _GDriveIface::stop_button"]
        [::std::mem::offset_of!(_GDriveIface, stop_button) - 224usize];
    ["Offset of field: _GDriveIface::eject_with_operation"]
        [::std::mem::offset_of!(_GDriveIface, eject_with_operation) - 232usize];
    ["Offset of field: _GDriveIface::eject_with_operation_finish"]
        [::std::mem::offset_of!(_GDriveIface, eject_with_operation_finish) - 240usize];
    ["Offset of field: _GDriveIface::get_sort_key"]
        [::std::mem::offset_of!(_GDriveIface, get_sort_key) - 248usize];
    ["Offset of field: _GDriveIface::get_symbolic_icon"]
        [::std::mem::offset_of!(_GDriveIface, get_symbolic_icon) - 256usize];
    ["Offset of field: _GDriveIface::is_removable"]
        [::std::mem::offset_of!(_GDriveIface, is_removable) - 264usize];
};
unsafe extern "C" {
    pub fn g_drive_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_drive_get_name(drive: *mut GDrive) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_drive_is_removable(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_eject(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_drive_eject_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_poll_for_media(
        drive: *mut GDrive,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_drive_poll_for_media_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_get_identifier(
        drive: *mut GDrive,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive) -> GDriveStartStopType;
}
unsafe extern "C" {
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_start(
        drive: *mut GDrive,
        flags: GDriveStartFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_drive_start_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_stop(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_drive_stop_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_eject_with_operation(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_drive_eject_with_operation_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const gchar;
}
#[doc = " GDtlsConnectionInterface:\n @g_iface: The parent interface.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @shutdown: Shut down one or both directions of the connection.\n @shutdown_async: Start an asynchronous shutdown operation.\n @shutdown_finish: Finish an asynchronous shutdown operation.\n @set_advertised_protocols: Set APLN protocol list (Since: 2.60)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n\n Virtual method table for a #GDtlsConnection implementation.\n\n Since: 2.48"]
pub type GDtlsConnectionInterface = _GDtlsConnectionInterface;
#[doc = " GDtlsConnectionInterface:\n @g_iface: The parent interface.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @shutdown: Shut down one or both directions of the connection.\n @shutdown_async: Start an asynchronous shutdown operation.\n @shutdown_finish: Finish an asynchronous shutdown operation.\n @set_advertised_protocols: Set APLN protocol list (Since: 2.60)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n\n Virtual method table for a #GDtlsConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnectionInterface {
    pub g_iface: GTypeInterface,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GDtlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub shutdown_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_advertised_protocols: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GDtlsConnection, protocols: *const *const gchar),
    >,
    pub get_negotiated_protocol:
        ::std::option::Option<unsafe extern "C" fn(conn: *mut GDtlsConnection) -> *const gchar>,
    pub get_binding_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            type_: GTlsChannelBindingType,
            data: *mut GByteArray,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDtlsConnectionInterface"]
        [::std::mem::size_of::<_GDtlsConnectionInterface>() - 96usize];
    ["Alignment of _GDtlsConnectionInterface"]
        [::std::mem::align_of::<_GDtlsConnectionInterface>() - 8usize];
    ["Offset of field: _GDtlsConnectionInterface::g_iface"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, g_iface) - 0usize];
    ["Offset of field: _GDtlsConnectionInterface::accept_certificate"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, accept_certificate) - 16usize];
    ["Offset of field: _GDtlsConnectionInterface::handshake"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, handshake) - 24usize];
    ["Offset of field: _GDtlsConnectionInterface::handshake_async"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, handshake_async) - 32usize];
    ["Offset of field: _GDtlsConnectionInterface::handshake_finish"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, handshake_finish) - 40usize];
    ["Offset of field: _GDtlsConnectionInterface::shutdown"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, shutdown) - 48usize];
    ["Offset of field: _GDtlsConnectionInterface::shutdown_async"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, shutdown_async) - 56usize];
    ["Offset of field: _GDtlsConnectionInterface::shutdown_finish"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, shutdown_finish) - 64usize];
    ["Offset of field: _GDtlsConnectionInterface::set_advertised_protocols"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, set_advertised_protocols) - 72usize];
    ["Offset of field: _GDtlsConnectionInterface::get_negotiated_protocol"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, get_negotiated_protocol) - 80usize];
    ["Offset of field: _GDtlsConnectionInterface::get_binding_data"]
        [::std::mem::offset_of!(_GDtlsConnectionInterface, get_binding_data) - 88usize];
};
unsafe extern "C" {
    pub fn g_dtls_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dtls_connection_set_database(conn: *mut GDtlsConnection, database: *mut GTlsDatabase);
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_database(conn: *mut GDtlsConnection) -> *mut GTlsDatabase;
}
unsafe extern "C" {
    pub fn g_dtls_connection_set_certificate(
        conn: *mut GDtlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_certificate(conn: *mut GDtlsConnection) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_dtls_connection_set_interaction(
        conn: *mut GDtlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_interaction(conn: *mut GDtlsConnection) -> *mut GTlsInteraction;
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_peer_certificate(
        conn: *mut GDtlsConnection,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_peer_certificate_errors(
        conn: *mut GDtlsConnection,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_dtls_connection_set_require_close_notify(
        conn: *mut GDtlsConnection,
        require_close_notify: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_require_close_notify(conn: *mut GDtlsConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_set_rehandshake_mode(
        conn: *mut GDtlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_rehandshake_mode(
        conn: *mut GDtlsConnection,
    ) -> GTlsRehandshakeMode;
}
unsafe extern "C" {
    pub fn g_dtls_connection_handshake(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_handshake_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_handshake_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_shutdown(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_shutdown_async(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_shutdown_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_close(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_close_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_close_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_emit_accept_certificate(
        conn: *mut GDtlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_set_advertised_protocols(
        conn: *mut GDtlsConnection,
        protocols: *const *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_negotiated_protocol(conn: *mut GDtlsConnection) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_channel_binding_data(
        conn: *mut GDtlsConnection,
        type_: GTlsChannelBindingType,
        data: *mut GByteArray,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_protocol_version(
        conn: *mut GDtlsConnection,
    ) -> GTlsProtocolVersion;
}
unsafe extern "C" {
    pub fn g_dtls_connection_get_ciphersuite_name(conn: *mut GDtlsConnection) -> *mut gchar;
}
#[doc = " GDtlsClientConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsClientConnection implementation.\n\n Since: 2.48"]
pub type GDtlsClientConnectionInterface = _GDtlsClientConnectionInterface;
#[doc = " GDtlsClientConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsClientConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDtlsClientConnectionInterface"]
        [::std::mem::size_of::<_GDtlsClientConnectionInterface>() - 16usize];
    ["Alignment of _GDtlsClientConnectionInterface"]
        [::std::mem::align_of::<_GDtlsClientConnectionInterface>() - 8usize];
    ["Offset of field: _GDtlsClientConnectionInterface::g_iface"]
        [::std::mem::offset_of!(_GDtlsClientConnectionInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn g_dtls_client_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dtls_client_connection_new(
        base_socket: *mut GDatagramBased,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
unsafe extern "C" {
    pub fn g_dtls_client_connection_get_validation_flags(
        conn: *mut GDtlsClientConnection,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_dtls_client_connection_set_validation_flags(
        conn: *mut GDtlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
unsafe extern "C" {
    pub fn g_dtls_client_connection_get_server_identity(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_dtls_client_connection_set_server_identity(
        conn: *mut GDtlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
unsafe extern "C" {
    pub fn g_dtls_client_connection_get_accepted_cas(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GList;
}
#[doc = " GDtlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsServerConnection implementation.\n\n Since: 2.48"]
pub type GDtlsServerConnectionInterface = _GDtlsServerConnectionInterface;
#[doc = " GDtlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsServerConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GDtlsServerConnectionInterface"]
        [::std::mem::size_of::<_GDtlsServerConnectionInterface>() - 16usize];
    ["Alignment of _GDtlsServerConnectionInterface"]
        [::std::mem::align_of::<_GDtlsServerConnectionInterface>() - 8usize];
    ["Offset of field: _GDtlsServerConnectionInterface::g_iface"]
        [::std::mem::offset_of!(_GDtlsServerConnectionInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn g_dtls_server_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dtls_server_connection_new(
        base_socket: *mut GDatagramBased,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
#[doc = " GIconIface:\n @g_iface: The parent interface.\n @hash: A hash for a given #GIcon.\n @equal: Checks if two #GIcons are equal.\n @to_tokens: Serializes a #GIcon into tokens. The tokens must not\n contain any whitespace. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @from_tokens: Constructs a #GIcon from tokens. Set the #GError if\n the tokens are malformed. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @serialize: Serializes a #GIcon into a #GVariant. Since: 2.38\n\n GIconIface is used to implement GIcon types for various\n different systems. See #GThemedIcon and #GLoadableIcon for\n examples of how to implement this interface."]
pub type GIconIface = _GIconIface;
#[doc = " GIconIface:\n @g_iface: The parent interface.\n @hash: A hash for a given #GIcon.\n @equal: Checks if two #GIcons are equal.\n @to_tokens: Serializes a #GIcon into tokens. The tokens must not\n contain any whitespace. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @from_tokens: Constructs a #GIcon from tokens. Set the #GError if\n the tokens are malformed. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @serialize: Serializes a #GIcon into a #GVariant. Since: 2.38\n\n GIconIface is used to implement GIcon types for various\n different systems. See #GThemedIcon and #GLoadableIcon for\n examples of how to implement this interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIconIface {
    pub g_iface: GTypeInterface,
    pub hash: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean,
    >,
    #[doc = " GIconIface::to_tokens:\n @icon: The #GIcon\n @tokens: (element-type utf8) (out caller-allocates):\n   The array to fill with tokens\n @out_version: (out): version of serialized tokens\n\n Serializes the @icon into string tokens.\n This is can be invoked when g_icon_new_for_string() is called.\n\n Returns: %TRUE if serialization took place, %FALSE otherwise\n\n Since: 2.20"]
    pub to_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GIcon,
            tokens: *mut GPtrArray,
            out_version: *mut gint,
        ) -> gboolean,
    >,
    #[doc = " GIconIface::from_tokens:\n @tokens: (array length=num_tokens): An array of tokens\n @num_tokens: The number of tokens in @tokens\n @version: Version of the serialized tokens\n @error: Return location for errors, or %NULL to ignore\n\n Constructs a #GIcon from a list of @tokens.\n\n Returns: (nullable) (transfer full): the #GIcon or %NULL on error\n\n Since: 2.20"]
    pub from_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            tokens: *mut *mut gchar,
            num_tokens: gint,
            version: gint,
            error: *mut *mut GError,
        ) -> *mut GIcon,
    >,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> *mut GVariant>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIconIface"][::std::mem::size_of::<_GIconIface>() - 56usize];
    ["Alignment of _GIconIface"][::std::mem::align_of::<_GIconIface>() - 8usize];
    ["Offset of field: _GIconIface::g_iface"]
        [::std::mem::offset_of!(_GIconIface, g_iface) - 0usize];
    ["Offset of field: _GIconIface::hash"][::std::mem::offset_of!(_GIconIface, hash) - 16usize];
    ["Offset of field: _GIconIface::equal"][::std::mem::offset_of!(_GIconIface, equal) - 24usize];
    ["Offset of field: _GIconIface::to_tokens"]
        [::std::mem::offset_of!(_GIconIface, to_tokens) - 32usize];
    ["Offset of field: _GIconIface::from_tokens"]
        [::std::mem::offset_of!(_GIconIface, from_tokens) - 40usize];
    ["Offset of field: _GIconIface::serialize"]
        [::std::mem::offset_of!(_GIconIface, serialize) - 48usize];
};
unsafe extern "C" {
    pub fn g_icon_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_icon_hash(icon: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
}
unsafe extern "C" {
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_icon_new_for_string(str_: *const gchar, error: *mut *mut GError) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_icon_deserialize(value: *mut GVariant) -> *mut GIcon;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblem {
    _unused: [u8; 0],
}
pub type GEmblem = _GEmblem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemClass {
    _unused: [u8; 0],
}
pub type GEmblemClass = _GEmblemClass;
unsafe extern "C" {
    pub fn g_emblem_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
}
unsafe extern "C" {
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin) -> *mut GEmblem;
}
unsafe extern "C" {
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;
}
pub type GEmblemedIcon = _GEmblemedIcon;
pub type GEmblemedIconClass = _GEmblemedIconClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconPrivate {
    _unused: [u8; 0],
}
pub type GEmblemedIconPrivate = _GEmblemedIconPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIcon {
    pub parent_instance: GObject,
    pub priv_: *mut GEmblemedIconPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GEmblemedIcon"][::std::mem::size_of::<_GEmblemedIcon>() - 32usize];
    ["Alignment of _GEmblemedIcon"][::std::mem::align_of::<_GEmblemedIcon>() - 8usize];
    ["Offset of field: _GEmblemedIcon::parent_instance"]
        [::std::mem::offset_of!(_GEmblemedIcon, parent_instance) - 0usize];
    ["Offset of field: _GEmblemedIcon::priv_"]
        [::std::mem::offset_of!(_GEmblemedIcon, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GEmblemedIconClass"][::std::mem::size_of::<_GEmblemedIconClass>() - 136usize];
    ["Alignment of _GEmblemedIconClass"][::std::mem::align_of::<_GEmblemedIconClass>() - 8usize];
    ["Offset of field: _GEmblemedIconClass::parent_class"]
        [::std::mem::offset_of!(_GEmblemedIconClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_emblemed_icon_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon, emblem: *mut GEmblem);
}
unsafe extern "C" {
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
}
#[doc = " GFileIface:\n @g_iface: The parent interface.\n @dup: Duplicates a #GFile.\n @hash: Creates a hash of a #GFile.\n @equal: Checks equality of two given #GFiles.\n @is_native: Checks to see if a file is native to the system.\n @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.\n @get_uri_scheme: Gets the URI scheme for a #GFile.\n @get_basename: Gets the basename for a given #GFile.\n @get_path: Gets the current path within a #GFile.\n @get_uri: Gets a URI for the path within a #GFile.\n @get_parse_name: Gets the parsed name for the #GFile.\n @get_parent: Gets the parent directory for the #GFile.\n @prefix_matches: Checks whether a #GFile contains a specified file.\n @get_relative_path: Gets the path for a #GFile relative to a given path.\n @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.\n @get_child_for_display_name: Gets the child #GFile for a given display name.\n @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_finish: Finishes asynchronously enumerating the children.\n @query_info: Gets the #GFileInfo for a #GFile.\n @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.\n @query_info_finish: Finishes an asynchronous query info operation.\n @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_finish: Finishes asynchronously getting the file system info.\n @find_enclosing_mount: Gets a #GMount for the #GFile.\n @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.\n @find_enclosing_mount_finish: Finishes asynchronously getting the volume.\n @set_display_name: Sets the display name for a #GFile.\n @set_display_name_async: Asynchronously sets a #GFile's display name.\n @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.\n @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.\n @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.\n @set_attribute: Sets a #GFileAttributeInfo.\n @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.\n @set_attributes_async: Asynchronously sets a file's attributes.\n @set_attributes_finish: Finishes setting a file's attributes asynchronously.\n @read_fn: Reads a file asynchronously.\n @read_async: Asynchronously reads a file.\n @read_finish: Finishes asynchronously reading a file.\n @append_to: Writes to the end of a file.\n @append_to_async: Asynchronously writes to the end of a file.\n @append_to_finish: Finishes an asynchronous file append operation.\n @create: Creates a new file.\n @create_async: Asynchronously creates a file.\n @create_finish: Finishes asynchronously creating a file.\n @replace: Replaces the contents of a file.\n @replace_async: Asynchronously replaces the contents of a file.\n @replace_finish: Finishes asynchronously replacing a file.\n @delete_file: Deletes a file.\n @delete_file_async: Asynchronously deletes a file.\n @delete_file_finish: Finishes an asynchronous delete.\n @trash: Sends a #GFile to the Trash location.\n @trash_async: Asynchronously sends a #GFile to the Trash location.\n @trash_finish: Finishes an asynchronous file trashing operation.\n @make_directory: Makes a directory.\n @make_directory_async: Asynchronously makes a directory.\n @make_directory_finish: Finishes making a directory asynchronously.\n @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic\n    links are unsupported.\n @make_symbolic_link_async: Asynchronously makes a symbolic link\n @make_symbolic_link_finish: Finishes making a symbolic link asynchronously.\n @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will\n     cause `GFile` to use a fallback copy method where it reads from the\n     source and writes to the destination.\n @copy_async: Asynchronously copies a file.\n @copy_finish: Finishes an asynchronous copy operation.\n @move: Moves a file.\n @move_async: Asynchronously moves a file. Since: 2.72\n @move_finish: Finishes an asynchronous move operation. Since: 2.72\n @mount_mountable: Mounts a mountable object.\n @mount_mountable_finish: Finishes a mounting operation.\n @unmount_mountable: Unmounts a mountable object.\n @unmount_mountable_finish: Finishes an unmount operation.\n @eject_mountable: Ejects a mountable.\n @eject_mountable_finish: Finishes an eject operation.\n @mount_enclosing_volume: Mounts a specified location.\n @mount_enclosing_volume_finish: Finishes mounting a specified location.\n @monitor_dir: Creates a #GFileMonitor for the location.\n @monitor_file: Creates a #GFileMonitor for the location.\n @open_readwrite: Open file read/write. Since 2.22.\n @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.\n @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.\n @create_readwrite: Creates file read/write. Since 2.22.\n @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.\n @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.\n @replace_readwrite: Replaces file read/write. Since 2.22.\n @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.\n @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.\n @start_mountable: Starts a mountable object. Since 2.22.\n @start_mountable_finish: Finishes a start operation. Since 2.22.\n @stop_mountable: Stops a mountable. Since 2.22.\n @stop_mountable_finish: Finishes a stop operation. Since 2.22.\n @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.\n @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.\n @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @poll_mountable: Polls a mountable object for media changes. Since 2.22.\n @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.\n @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38\n\n An interface for writing VFS file handles."]
pub type GFileIface = _GFileIface;
#[doc = " GFileIface:\n @g_iface: The parent interface.\n @dup: Duplicates a #GFile.\n @hash: Creates a hash of a #GFile.\n @equal: Checks equality of two given #GFiles.\n @is_native: Checks to see if a file is native to the system.\n @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.\n @get_uri_scheme: Gets the URI scheme for a #GFile.\n @get_basename: Gets the basename for a given #GFile.\n @get_path: Gets the current path within a #GFile.\n @get_uri: Gets a URI for the path within a #GFile.\n @get_parse_name: Gets the parsed name for the #GFile.\n @get_parent: Gets the parent directory for the #GFile.\n @prefix_matches: Checks whether a #GFile contains a specified file.\n @get_relative_path: Gets the path for a #GFile relative to a given path.\n @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.\n @get_child_for_display_name: Gets the child #GFile for a given display name.\n @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_finish: Finishes asynchronously enumerating the children.\n @query_info: Gets the #GFileInfo for a #GFile.\n @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.\n @query_info_finish: Finishes an asynchronous query info operation.\n @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_finish: Finishes asynchronously getting the file system info.\n @find_enclosing_mount: Gets a #GMount for the #GFile.\n @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.\n @find_enclosing_mount_finish: Finishes asynchronously getting the volume.\n @set_display_name: Sets the display name for a #GFile.\n @set_display_name_async: Asynchronously sets a #GFile's display name.\n @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.\n @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.\n @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.\n @set_attribute: Sets a #GFileAttributeInfo.\n @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.\n @set_attributes_async: Asynchronously sets a file's attributes.\n @set_attributes_finish: Finishes setting a file's attributes asynchronously.\n @read_fn: Reads a file asynchronously.\n @read_async: Asynchronously reads a file.\n @read_finish: Finishes asynchronously reading a file.\n @append_to: Writes to the end of a file.\n @append_to_async: Asynchronously writes to the end of a file.\n @append_to_finish: Finishes an asynchronous file append operation.\n @create: Creates a new file.\n @create_async: Asynchronously creates a file.\n @create_finish: Finishes asynchronously creating a file.\n @replace: Replaces the contents of a file.\n @replace_async: Asynchronously replaces the contents of a file.\n @replace_finish: Finishes asynchronously replacing a file.\n @delete_file: Deletes a file.\n @delete_file_async: Asynchronously deletes a file.\n @delete_file_finish: Finishes an asynchronous delete.\n @trash: Sends a #GFile to the Trash location.\n @trash_async: Asynchronously sends a #GFile to the Trash location.\n @trash_finish: Finishes an asynchronous file trashing operation.\n @make_directory: Makes a directory.\n @make_directory_async: Asynchronously makes a directory.\n @make_directory_finish: Finishes making a directory asynchronously.\n @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic\n    links are unsupported.\n @make_symbolic_link_async: Asynchronously makes a symbolic link\n @make_symbolic_link_finish: Finishes making a symbolic link asynchronously.\n @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will\n     cause `GFile` to use a fallback copy method where it reads from the\n     source and writes to the destination.\n @copy_async: Asynchronously copies a file.\n @copy_finish: Finishes an asynchronous copy operation.\n @move: Moves a file.\n @move_async: Asynchronously moves a file. Since: 2.72\n @move_finish: Finishes an asynchronous move operation. Since: 2.72\n @mount_mountable: Mounts a mountable object.\n @mount_mountable_finish: Finishes a mounting operation.\n @unmount_mountable: Unmounts a mountable object.\n @unmount_mountable_finish: Finishes an unmount operation.\n @eject_mountable: Ejects a mountable.\n @eject_mountable_finish: Finishes an eject operation.\n @mount_enclosing_volume: Mounts a specified location.\n @mount_enclosing_volume_finish: Finishes mounting a specified location.\n @monitor_dir: Creates a #GFileMonitor for the location.\n @monitor_file: Creates a #GFileMonitor for the location.\n @open_readwrite: Open file read/write. Since 2.22.\n @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.\n @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.\n @create_readwrite: Creates file read/write. Since 2.22.\n @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.\n @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.\n @replace_readwrite: Replaces file read/write. Since 2.22.\n @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.\n @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.\n @start_mountable: Starts a mountable object. Since 2.22.\n @start_mountable_finish: Finishes a start operation. Since 2.22.\n @stop_mountable: Stops a mountable. Since 2.22.\n @stop_mountable_finish: Finishes a stop operation. Since 2.22.\n @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.\n @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.\n @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @poll_mountable: Polls a mountable object for media changes. Since 2.22.\n @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.\n @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38\n\n An interface for writing VFS file handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub hash: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(file1: *mut GFile, file2: *mut GFile) -> gboolean,
    >,
    pub is_native: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> gboolean>,
    pub has_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            uri_scheme: *const ::std::os::raw::c_char,
        ) -> gboolean,
    >,
    pub get_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_basename: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_path: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_uri: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parse_name: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parent: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub prefix_matches: ::std::option::Option<
        unsafe extern "C" fn(prefix: *mut GFile, file: *mut GFile) -> gboolean,
    >,
    pub get_relative_path: ::std::option::Option<
        unsafe extern "C" fn(
            parent: *mut GFile,
            descendant: *mut GFile,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub resolve_relative_path: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            relative_path: *const ::std::os::raw::c_char,
        ) -> *mut GFile,
    >,
    pub get_child_for_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub enumerate_children: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub enumerate_children_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub enumerate_children_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_filesystem_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub find_enclosing_mount: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub find_enclosing_mount_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub find_enclosing_mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub set_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub set_display_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_display_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub query_settable_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_settable_attributes_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_settable_attributes_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub query_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_writable_namespaces_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_writable_namespaces_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub set_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attribute: *const ::std::os::raw::c_char,
            type_: GFileAttributeType,
            value_p: gpointer,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_from_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_attributes_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            info: *mut *mut GFileInfo,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub append_to: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub append_to_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub append_to_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub delete_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub delete_file_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub delete_file_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub trash_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_directory_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_symbolic_link: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_symbolic_link_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_symbolic_link_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub copy_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub move_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub move_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub mount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub unmount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub mount_enclosing_volume: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_enclosing_volume_finish: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub monitor_dir: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub monitor_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub open_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub open_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub open_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub start_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GDriveStartFlags,
            start_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            io_priority: gint,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub measure_disk_usage_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileIface"][::std::mem::size_of::<_GFileIface>() - 840usize];
    ["Alignment of _GFileIface"][::std::mem::align_of::<_GFileIface>() - 8usize];
    ["Offset of field: _GFileIface::g_iface"]
        [::std::mem::offset_of!(_GFileIface, g_iface) - 0usize];
    ["Offset of field: _GFileIface::dup"][::std::mem::offset_of!(_GFileIface, dup) - 16usize];
    ["Offset of field: _GFileIface::hash"][::std::mem::offset_of!(_GFileIface, hash) - 24usize];
    ["Offset of field: _GFileIface::equal"][::std::mem::offset_of!(_GFileIface, equal) - 32usize];
    ["Offset of field: _GFileIface::is_native"]
        [::std::mem::offset_of!(_GFileIface, is_native) - 40usize];
    ["Offset of field: _GFileIface::has_uri_scheme"]
        [::std::mem::offset_of!(_GFileIface, has_uri_scheme) - 48usize];
    ["Offset of field: _GFileIface::get_uri_scheme"]
        [::std::mem::offset_of!(_GFileIface, get_uri_scheme) - 56usize];
    ["Offset of field: _GFileIface::get_basename"]
        [::std::mem::offset_of!(_GFileIface, get_basename) - 64usize];
    ["Offset of field: _GFileIface::get_path"]
        [::std::mem::offset_of!(_GFileIface, get_path) - 72usize];
    ["Offset of field: _GFileIface::get_uri"]
        [::std::mem::offset_of!(_GFileIface, get_uri) - 80usize];
    ["Offset of field: _GFileIface::get_parse_name"]
        [::std::mem::offset_of!(_GFileIface, get_parse_name) - 88usize];
    ["Offset of field: _GFileIface::get_parent"]
        [::std::mem::offset_of!(_GFileIface, get_parent) - 96usize];
    ["Offset of field: _GFileIface::prefix_matches"]
        [::std::mem::offset_of!(_GFileIface, prefix_matches) - 104usize];
    ["Offset of field: _GFileIface::get_relative_path"]
        [::std::mem::offset_of!(_GFileIface, get_relative_path) - 112usize];
    ["Offset of field: _GFileIface::resolve_relative_path"]
        [::std::mem::offset_of!(_GFileIface, resolve_relative_path) - 120usize];
    ["Offset of field: _GFileIface::get_child_for_display_name"]
        [::std::mem::offset_of!(_GFileIface, get_child_for_display_name) - 128usize];
    ["Offset of field: _GFileIface::enumerate_children"]
        [::std::mem::offset_of!(_GFileIface, enumerate_children) - 136usize];
    ["Offset of field: _GFileIface::enumerate_children_async"]
        [::std::mem::offset_of!(_GFileIface, enumerate_children_async) - 144usize];
    ["Offset of field: _GFileIface::enumerate_children_finish"]
        [::std::mem::offset_of!(_GFileIface, enumerate_children_finish) - 152usize];
    ["Offset of field: _GFileIface::query_info"]
        [::std::mem::offset_of!(_GFileIface, query_info) - 160usize];
    ["Offset of field: _GFileIface::query_info_async"]
        [::std::mem::offset_of!(_GFileIface, query_info_async) - 168usize];
    ["Offset of field: _GFileIface::query_info_finish"]
        [::std::mem::offset_of!(_GFileIface, query_info_finish) - 176usize];
    ["Offset of field: _GFileIface::query_filesystem_info"]
        [::std::mem::offset_of!(_GFileIface, query_filesystem_info) - 184usize];
    ["Offset of field: _GFileIface::query_filesystem_info_async"]
        [::std::mem::offset_of!(_GFileIface, query_filesystem_info_async) - 192usize];
    ["Offset of field: _GFileIface::query_filesystem_info_finish"]
        [::std::mem::offset_of!(_GFileIface, query_filesystem_info_finish) - 200usize];
    ["Offset of field: _GFileIface::find_enclosing_mount"]
        [::std::mem::offset_of!(_GFileIface, find_enclosing_mount) - 208usize];
    ["Offset of field: _GFileIface::find_enclosing_mount_async"]
        [::std::mem::offset_of!(_GFileIface, find_enclosing_mount_async) - 216usize];
    ["Offset of field: _GFileIface::find_enclosing_mount_finish"]
        [::std::mem::offset_of!(_GFileIface, find_enclosing_mount_finish) - 224usize];
    ["Offset of field: _GFileIface::set_display_name"]
        [::std::mem::offset_of!(_GFileIface, set_display_name) - 232usize];
    ["Offset of field: _GFileIface::set_display_name_async"]
        [::std::mem::offset_of!(_GFileIface, set_display_name_async) - 240usize];
    ["Offset of field: _GFileIface::set_display_name_finish"]
        [::std::mem::offset_of!(_GFileIface, set_display_name_finish) - 248usize];
    ["Offset of field: _GFileIface::query_settable_attributes"]
        [::std::mem::offset_of!(_GFileIface, query_settable_attributes) - 256usize];
    ["Offset of field: _GFileIface::_query_settable_attributes_async"]
        [::std::mem::offset_of!(_GFileIface, _query_settable_attributes_async) - 264usize];
    ["Offset of field: _GFileIface::_query_settable_attributes_finish"]
        [::std::mem::offset_of!(_GFileIface, _query_settable_attributes_finish) - 272usize];
    ["Offset of field: _GFileIface::query_writable_namespaces"]
        [::std::mem::offset_of!(_GFileIface, query_writable_namespaces) - 280usize];
    ["Offset of field: _GFileIface::_query_writable_namespaces_async"]
        [::std::mem::offset_of!(_GFileIface, _query_writable_namespaces_async) - 288usize];
    ["Offset of field: _GFileIface::_query_writable_namespaces_finish"]
        [::std::mem::offset_of!(_GFileIface, _query_writable_namespaces_finish) - 296usize];
    ["Offset of field: _GFileIface::set_attribute"]
        [::std::mem::offset_of!(_GFileIface, set_attribute) - 304usize];
    ["Offset of field: _GFileIface::set_attributes_from_info"]
        [::std::mem::offset_of!(_GFileIface, set_attributes_from_info) - 312usize];
    ["Offset of field: _GFileIface::set_attributes_async"]
        [::std::mem::offset_of!(_GFileIface, set_attributes_async) - 320usize];
    ["Offset of field: _GFileIface::set_attributes_finish"]
        [::std::mem::offset_of!(_GFileIface, set_attributes_finish) - 328usize];
    ["Offset of field: _GFileIface::read_fn"]
        [::std::mem::offset_of!(_GFileIface, read_fn) - 336usize];
    ["Offset of field: _GFileIface::read_async"]
        [::std::mem::offset_of!(_GFileIface, read_async) - 344usize];
    ["Offset of field: _GFileIface::read_finish"]
        [::std::mem::offset_of!(_GFileIface, read_finish) - 352usize];
    ["Offset of field: _GFileIface::append_to"]
        [::std::mem::offset_of!(_GFileIface, append_to) - 360usize];
    ["Offset of field: _GFileIface::append_to_async"]
        [::std::mem::offset_of!(_GFileIface, append_to_async) - 368usize];
    ["Offset of field: _GFileIface::append_to_finish"]
        [::std::mem::offset_of!(_GFileIface, append_to_finish) - 376usize];
    ["Offset of field: _GFileIface::create"]
        [::std::mem::offset_of!(_GFileIface, create) - 384usize];
    ["Offset of field: _GFileIface::create_async"]
        [::std::mem::offset_of!(_GFileIface, create_async) - 392usize];
    ["Offset of field: _GFileIface::create_finish"]
        [::std::mem::offset_of!(_GFileIface, create_finish) - 400usize];
    ["Offset of field: _GFileIface::replace"]
        [::std::mem::offset_of!(_GFileIface, replace) - 408usize];
    ["Offset of field: _GFileIface::replace_async"]
        [::std::mem::offset_of!(_GFileIface, replace_async) - 416usize];
    ["Offset of field: _GFileIface::replace_finish"]
        [::std::mem::offset_of!(_GFileIface, replace_finish) - 424usize];
    ["Offset of field: _GFileIface::delete_file"]
        [::std::mem::offset_of!(_GFileIface, delete_file) - 432usize];
    ["Offset of field: _GFileIface::delete_file_async"]
        [::std::mem::offset_of!(_GFileIface, delete_file_async) - 440usize];
    ["Offset of field: _GFileIface::delete_file_finish"]
        [::std::mem::offset_of!(_GFileIface, delete_file_finish) - 448usize];
    ["Offset of field: _GFileIface::trash"][::std::mem::offset_of!(_GFileIface, trash) - 456usize];
    ["Offset of field: _GFileIface::trash_async"]
        [::std::mem::offset_of!(_GFileIface, trash_async) - 464usize];
    ["Offset of field: _GFileIface::trash_finish"]
        [::std::mem::offset_of!(_GFileIface, trash_finish) - 472usize];
    ["Offset of field: _GFileIface::make_directory"]
        [::std::mem::offset_of!(_GFileIface, make_directory) - 480usize];
    ["Offset of field: _GFileIface::make_directory_async"]
        [::std::mem::offset_of!(_GFileIface, make_directory_async) - 488usize];
    ["Offset of field: _GFileIface::make_directory_finish"]
        [::std::mem::offset_of!(_GFileIface, make_directory_finish) - 496usize];
    ["Offset of field: _GFileIface::make_symbolic_link"]
        [::std::mem::offset_of!(_GFileIface, make_symbolic_link) - 504usize];
    ["Offset of field: _GFileIface::make_symbolic_link_async"]
        [::std::mem::offset_of!(_GFileIface, make_symbolic_link_async) - 512usize];
    ["Offset of field: _GFileIface::make_symbolic_link_finish"]
        [::std::mem::offset_of!(_GFileIface, make_symbolic_link_finish) - 520usize];
    ["Offset of field: _GFileIface::copy"][::std::mem::offset_of!(_GFileIface, copy) - 528usize];
    ["Offset of field: _GFileIface::copy_async"]
        [::std::mem::offset_of!(_GFileIface, copy_async) - 536usize];
    ["Offset of field: _GFileIface::copy_finish"]
        [::std::mem::offset_of!(_GFileIface, copy_finish) - 544usize];
    ["Offset of field: _GFileIface::move_"][::std::mem::offset_of!(_GFileIface, move_) - 552usize];
    ["Offset of field: _GFileIface::move_async"]
        [::std::mem::offset_of!(_GFileIface, move_async) - 560usize];
    ["Offset of field: _GFileIface::move_finish"]
        [::std::mem::offset_of!(_GFileIface, move_finish) - 568usize];
    ["Offset of field: _GFileIface::mount_mountable"]
        [::std::mem::offset_of!(_GFileIface, mount_mountable) - 576usize];
    ["Offset of field: _GFileIface::mount_mountable_finish"]
        [::std::mem::offset_of!(_GFileIface, mount_mountable_finish) - 584usize];
    ["Offset of field: _GFileIface::unmount_mountable"]
        [::std::mem::offset_of!(_GFileIface, unmount_mountable) - 592usize];
    ["Offset of field: _GFileIface::unmount_mountable_finish"]
        [::std::mem::offset_of!(_GFileIface, unmount_mountable_finish) - 600usize];
    ["Offset of field: _GFileIface::eject_mountable"]
        [::std::mem::offset_of!(_GFileIface, eject_mountable) - 608usize];
    ["Offset of field: _GFileIface::eject_mountable_finish"]
        [::std::mem::offset_of!(_GFileIface, eject_mountable_finish) - 616usize];
    ["Offset of field: _GFileIface::mount_enclosing_volume"]
        [::std::mem::offset_of!(_GFileIface, mount_enclosing_volume) - 624usize];
    ["Offset of field: _GFileIface::mount_enclosing_volume_finish"]
        [::std::mem::offset_of!(_GFileIface, mount_enclosing_volume_finish) - 632usize];
    ["Offset of field: _GFileIface::monitor_dir"]
        [::std::mem::offset_of!(_GFileIface, monitor_dir) - 640usize];
    ["Offset of field: _GFileIface::monitor_file"]
        [::std::mem::offset_of!(_GFileIface, monitor_file) - 648usize];
    ["Offset of field: _GFileIface::open_readwrite"]
        [::std::mem::offset_of!(_GFileIface, open_readwrite) - 656usize];
    ["Offset of field: _GFileIface::open_readwrite_async"]
        [::std::mem::offset_of!(_GFileIface, open_readwrite_async) - 664usize];
    ["Offset of field: _GFileIface::open_readwrite_finish"]
        [::std::mem::offset_of!(_GFileIface, open_readwrite_finish) - 672usize];
    ["Offset of field: _GFileIface::create_readwrite"]
        [::std::mem::offset_of!(_GFileIface, create_readwrite) - 680usize];
    ["Offset of field: _GFileIface::create_readwrite_async"]
        [::std::mem::offset_of!(_GFileIface, create_readwrite_async) - 688usize];
    ["Offset of field: _GFileIface::create_readwrite_finish"]
        [::std::mem::offset_of!(_GFileIface, create_readwrite_finish) - 696usize];
    ["Offset of field: _GFileIface::replace_readwrite"]
        [::std::mem::offset_of!(_GFileIface, replace_readwrite) - 704usize];
    ["Offset of field: _GFileIface::replace_readwrite_async"]
        [::std::mem::offset_of!(_GFileIface, replace_readwrite_async) - 712usize];
    ["Offset of field: _GFileIface::replace_readwrite_finish"]
        [::std::mem::offset_of!(_GFileIface, replace_readwrite_finish) - 720usize];
    ["Offset of field: _GFileIface::start_mountable"]
        [::std::mem::offset_of!(_GFileIface, start_mountable) - 728usize];
    ["Offset of field: _GFileIface::start_mountable_finish"]
        [::std::mem::offset_of!(_GFileIface, start_mountable_finish) - 736usize];
    ["Offset of field: _GFileIface::stop_mountable"]
        [::std::mem::offset_of!(_GFileIface, stop_mountable) - 744usize];
    ["Offset of field: _GFileIface::stop_mountable_finish"]
        [::std::mem::offset_of!(_GFileIface, stop_mountable_finish) - 752usize];
    ["Offset of field: _GFileIface::supports_thread_contexts"]
        [::std::mem::offset_of!(_GFileIface, supports_thread_contexts) - 760usize];
    ["Offset of field: _GFileIface::unmount_mountable_with_operation"]
        [::std::mem::offset_of!(_GFileIface, unmount_mountable_with_operation) - 768usize];
    ["Offset of field: _GFileIface::unmount_mountable_with_operation_finish"]
        [::std::mem::offset_of!(_GFileIface, unmount_mountable_with_operation_finish) - 776usize];
    ["Offset of field: _GFileIface::eject_mountable_with_operation"]
        [::std::mem::offset_of!(_GFileIface, eject_mountable_with_operation) - 784usize];
    ["Offset of field: _GFileIface::eject_mountable_with_operation_finish"]
        [::std::mem::offset_of!(_GFileIface, eject_mountable_with_operation_finish) - 792usize];
    ["Offset of field: _GFileIface::poll_mountable"]
        [::std::mem::offset_of!(_GFileIface, poll_mountable) - 800usize];
    ["Offset of field: _GFileIface::poll_mountable_finish"]
        [::std::mem::offset_of!(_GFileIface, poll_mountable_finish) - 808usize];
    ["Offset of field: _GFileIface::measure_disk_usage"]
        [::std::mem::offset_of!(_GFileIface, measure_disk_usage) - 816usize];
    ["Offset of field: _GFileIface::measure_disk_usage_async"]
        [::std::mem::offset_of!(_GFileIface, measure_disk_usage_async) - 824usize];
    ["Offset of field: _GFileIface::measure_disk_usage_finish"]
        [::std::mem::offset_of!(_GFileIface, measure_disk_usage_finish) - 832usize];
};
unsafe extern "C" {
    pub fn g_file_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_new_for_path(path: *const ::std::os::raw::c_char) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_for_uri(uri: *const ::std::os::raw::c_char) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_for_commandline_arg(arg: *const ::std::os::raw::c_char) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_for_commandline_arg_and_cwd(
        arg: *const gchar,
        cwd: *const gchar,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_tmp(
        tmpl: *const ::std::os::raw::c_char,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_tmp_async(
        tmpl: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_new_tmp_finish(
        result: *mut GAsyncResult,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_tmp_dir_async(
        tmpl: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_new_tmp_dir_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_parse_name(parse_name: *const ::std::os::raw::c_char) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_build_filename(first_element: *const gchar, ...) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_new_build_filenamev(args: *const *const gchar) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_hash(file: gconstpointer) -> guint;
}
unsafe extern "C" {
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_basename(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_get_path(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_peek_path(file: *mut GFile) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_get_uri(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_get_parse_name(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_child(file: *mut GFile, name: *const ::std::os::raw::c_char) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_get_child_for_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_relative_path(
        parent: *mut GFile,
        descendant: *mut GFile,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_resolve_relative_path(
        file: *mut GFile,
        relative_path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_has_uri_scheme(
        file: *mut GFile,
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_get_uri_scheme(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_read(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
unsafe extern "C" {
    pub fn g_file_read_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_read_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
unsafe extern "C" {
    pub fn g_file_append_to(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
unsafe extern "C" {
    pub fn g_file_create(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
unsafe extern "C" {
    pub fn g_file_replace(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
unsafe extern "C" {
    pub fn g_file_append_to_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_append_to_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
unsafe extern "C" {
    pub fn g_file_create_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_create_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
unsafe extern "C" {
    pub fn g_file_replace_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_replace_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
unsafe extern "C" {
    pub fn g_file_open_readwrite(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
unsafe extern "C" {
    pub fn g_file_open_readwrite_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_open_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
unsafe extern "C" {
    pub fn g_file_create_readwrite(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
unsafe extern "C" {
    pub fn g_file_create_readwrite_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_create_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
unsafe extern "C" {
    pub fn g_file_replace_readwrite(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
unsafe extern "C" {
    pub fn g_file_replace_readwrite_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_replace_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
unsafe extern "C" {
    pub fn g_file_query_exists(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_query_file_type(
        file: *mut GFile,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
    ) -> GFileType;
}
unsafe extern "C" {
    pub fn g_file_query_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_query_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_query_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_query_filesystem_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_query_filesystem_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_query_filesystem_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_find_enclosing_mount(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
unsafe extern "C" {
    pub fn g_file_find_enclosing_mount_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_find_enclosing_mount_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
unsafe extern "C" {
    pub fn g_file_enumerate_children(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
unsafe extern "C" {
    pub fn g_file_enumerate_children_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_enumerate_children_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
unsafe extern "C" {
    pub fn g_file_set_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_set_display_name_async(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_set_display_name_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_delete(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_delete_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_delete_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_trash(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_trash_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_trash_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_copy(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_copy_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_copy_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_move(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_move_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_move_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_make_directory(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_make_directory_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_make_directory_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_make_directory_with_parents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_make_symbolic_link(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_make_symbolic_link_async(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_make_symbolic_link_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_query_settable_attributes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
unsafe extern "C" {
    pub fn g_file_query_writable_namespaces(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
unsafe extern "C" {
    pub fn g_file_set_attribute(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attributes_from_info(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attributes_async(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_set_attributes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        info: *mut *mut GFileInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attribute_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attribute_byte_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attribute_uint32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attribute_int32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attribute_uint64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_set_attribute_int64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_mount_enclosing_volume(
        location: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_mount_enclosing_volume_finish(
        location: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_mount_mountable(
        file: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_mount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_unmount_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_unmount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_unmount_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_unmount_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_eject_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_eject_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_eject_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_eject_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_build_attribute_list_for_copy(
        file: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_copy_attributes(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_monitor_directory(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
unsafe extern "C" {
    pub fn g_file_monitor_file(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
unsafe extern "C" {
    pub fn g_file_monitor(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
unsafe extern "C" {
    pub fn g_file_measure_disk_usage(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_measure_disk_usage_async(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        io_priority: gint,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_measure_disk_usage_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_start_mountable(
        file: *mut GFile,
        flags: GDriveStartFlags,
        start_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_start_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_stop_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_stop_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_poll_mountable(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_poll_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_query_default_handler(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_file_query_default_handler_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_query_default_handler_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
unsafe extern "C" {
    pub fn g_file_load_contents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_load_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_load_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_load_partial_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        read_more_callback: GFileReadMoreCallback,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_load_partial_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_replace_contents(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        new_etag: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_replace_contents_async(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_replace_contents_bytes_async(
        file: *mut GFile,
        contents: *mut GBytes,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_replace_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        new_etag: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_load_bytes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        etag_out: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_file_load_bytes_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_load_bytes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        etag_out: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
#[doc = " GFileAttributeInfo:\n @name: the name of the attribute.\n @type: the #GFileAttributeType type of the attribute.\n @flags: a set of #GFileAttributeInfoFlags.\n\n Information about a specific attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeInfo {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileAttributeInfo"][::std::mem::size_of::<_GFileAttributeInfo>() - 16usize];
    ["Alignment of _GFileAttributeInfo"][::std::mem::align_of::<_GFileAttributeInfo>() - 8usize];
    ["Offset of field: _GFileAttributeInfo::name"]
        [::std::mem::offset_of!(_GFileAttributeInfo, name) - 0usize];
    ["Offset of field: _GFileAttributeInfo::type_"]
        [::std::mem::offset_of!(_GFileAttributeInfo, type_) - 8usize];
    ["Offset of field: _GFileAttributeInfo::flags"]
        [::std::mem::offset_of!(_GFileAttributeInfo, flags) - 12usize];
};
#[doc = " GFileAttributeInfoList:\n @infos: an array of #GFileAttributeInfos.\n @n_infos: the number of values in the array.\n\n Acts as a lightweight registry for possible valid file attributes.\n The registry stores Key-Value pair formats as #GFileAttributeInfos."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileAttributeInfoList"][::std::mem::size_of::<_GFileAttributeInfoList>() - 16usize];
    ["Alignment of _GFileAttributeInfoList"]
        [::std::mem::align_of::<_GFileAttributeInfoList>() - 8usize];
    ["Offset of field: _GFileAttributeInfoList::infos"]
        [::std::mem::offset_of!(_GFileAttributeInfoList, infos) - 0usize];
    ["Offset of field: _GFileAttributeInfoList::n_infos"]
        [::std::mem::offset_of!(_GFileAttributeInfoList, n_infos) - 8usize];
};
unsafe extern "C" {
    pub fn g_file_attribute_info_list_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
}
unsafe extern "C" {
    pub fn g_file_attribute_info_list_ref(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
unsafe extern "C" {
    pub fn g_file_attribute_info_list_unref(list: *mut GFileAttributeInfoList);
}
unsafe extern "C" {
    pub fn g_file_attribute_info_list_dup(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
unsafe extern "C" {
    pub fn g_file_attribute_info_list_lookup(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
    ) -> *const GFileAttributeInfo;
}
unsafe extern "C" {
    pub fn g_file_attribute_info_list_add(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        flags: GFileAttributeInfoFlags,
    );
}
pub type GFileEnumeratorClass = _GFileEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GFileEnumeratorPrivate = _GFileEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumerator {
    pub parent_instance: GObject,
    pub priv_: *mut GFileEnumeratorPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileEnumerator"][::std::mem::size_of::<_GFileEnumerator>() - 32usize];
    ["Alignment of _GFileEnumerator"][::std::mem::align_of::<_GFileEnumerator>() - 8usize];
    ["Offset of field: _GFileEnumerator::parent_instance"]
        [::std::mem::offset_of!(_GFileEnumerator, parent_instance) - 0usize];
    ["Offset of field: _GFileEnumerator::priv_"]
        [::std::mem::offset_of!(_GFileEnumerator, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next_file: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub next_files_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            num_files: ::std::os::raw::c_int,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_files_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileEnumeratorClass"][::std::mem::size_of::<_GFileEnumeratorClass>() - 240usize];
    ["Alignment of _GFileEnumeratorClass"]
        [::std::mem::align_of::<_GFileEnumeratorClass>() - 8usize];
    ["Offset of field: _GFileEnumeratorClass::parent_class"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, parent_class) - 0usize];
    ["Offset of field: _GFileEnumeratorClass::next_file"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, next_file) - 136usize];
    ["Offset of field: _GFileEnumeratorClass::close_fn"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, close_fn) - 144usize];
    ["Offset of field: _GFileEnumeratorClass::next_files_async"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, next_files_async) - 152usize];
    ["Offset of field: _GFileEnumeratorClass::next_files_finish"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, next_files_finish) - 160usize];
    ["Offset of field: _GFileEnumeratorClass::close_async"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, close_async) - 168usize];
    ["Offset of field: _GFileEnumeratorClass::close_finish"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, close_finish) - 176usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved1) - 184usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved2) - 192usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved3) - 200usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved4"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved4) - 208usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved5"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved5) - 216usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved6"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved6) - 224usize];
    ["Offset of field: _GFileEnumeratorClass::_g_reserved7"]
        [::std::mem::offset_of!(_GFileEnumeratorClass, _g_reserved7) - 232usize];
};
unsafe extern "C" {
    pub fn g_file_enumerator_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_enumerator_next_file(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_enumerator_close(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_enumerator_next_files_async(
        enumerator: *mut GFileEnumerator,
        num_files: ::std::os::raw::c_int,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_enumerator_next_files_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_file_enumerator_close_async(
        enumerator: *mut GFileEnumerator,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_enumerator_close_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator, pending: gboolean);
}
unsafe extern "C" {
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_enumerator_get_child(
        enumerator: *mut GFileEnumerator,
        info: *mut GFileInfo,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_file_enumerator_iterate(
        direnum: *mut GFileEnumerator,
        out_info: *mut *mut GFileInfo,
        out_child: *mut *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIconClass {
    _unused: [u8; 0],
}
pub type GFileIconClass = _GFileIconClass;
unsafe extern "C" {
    pub fn g_file_icon_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfoClass {
    _unused: [u8; 0],
}
pub type GFileInfoClass = _GFileInfoClass;
unsafe extern "C" {
    pub fn g_file_info_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_info_new() -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo, dest_info: *mut GFileInfo);
}
unsafe extern "C" {
    pub fn g_file_info_has_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_has_namespace(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_list_attributes(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_data(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: *mut GFileAttributeType,
        value_pp: *mut gpointer,
        status: *mut GFileAttributeStatus,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_type(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeType;
}
unsafe extern "C" {
    pub fn g_file_info_remove_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeStatus;
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        status: GFileAttributeStatus,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_as_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint32;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint32;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint64;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_attribute_file_path(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint32,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint32,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint64,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint64,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut GObject,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_file_path(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
}
unsafe extern "C" {
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
}
unsafe extern "C" {
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_info_get_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_display_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_file_info_get_content_type(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> goffset;
}
unsafe extern "C" {
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo, result: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_file_info_get_modification_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_file_info_get_access_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_file_info_get_creation_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_etag(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> gint32;
}
unsafe extern "C" {
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo, mask: *mut GFileAttributeMatcher);
}
unsafe extern "C" {
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);
}
unsafe extern "C" {
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, type_: GFileType);
}
unsafe extern "C" {
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo, is_hidden: gboolean);
}
unsafe extern "C" {
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo, is_symlink: gboolean);
}
unsafe extern "C" {
    pub fn g_file_info_set_name(info: *mut GFileInfo, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_file_info_set_display_name(
        info: *mut GFileInfo,
        display_name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_edit_name(
        info: *mut GFileInfo,
        edit_name: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
unsafe extern "C" {
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
unsafe extern "C" {
    pub fn g_file_info_set_content_type(
        info: *mut GFileInfo,
        content_type: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: goffset);
}
unsafe extern "C" {
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo, mtime: *mut GTimeVal);
}
unsafe extern "C" {
    pub fn g_file_info_set_modification_date_time(info: *mut GFileInfo, mtime: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_file_info_set_access_date_time(info: *mut GFileInfo, atime: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_file_info_set_creation_date_time(info: *mut GFileInfo, creation_time: *mut GDateTime);
}
unsafe extern "C" {
    pub fn g_file_info_set_symlink_target(
        info: *mut GFileInfo,
        symlink_target: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo, sort_order: gint32);
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_new(
        attributes: *const ::std::os::raw::c_char,
    ) -> *mut GFileAttributeMatcher;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_ref(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_unref(matcher: *mut GFileAttributeMatcher);
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_subtract(
        matcher: *mut GFileAttributeMatcher,
        subtract: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_matches(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_matches_only(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_enumerate_namespace(
        matcher: *mut GFileAttributeMatcher,
        ns: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_enumerate_next(
        matcher: *mut GFileAttributeMatcher,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_file_attribute_matcher_to_string(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut ::std::os::raw::c_char;
}
pub type GFileInputStreamClass = _GFileInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileInputStreamPrivate = _GFileInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GFileInputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileInputStream"][::std::mem::size_of::<_GFileInputStream>() - 40usize];
    ["Alignment of _GFileInputStream"][::std::mem::align_of::<_GFileInputStream>() - 8usize];
    ["Offset of field: _GFileInputStream::parent_instance"]
        [::std::mem::offset_of!(_GFileInputStream, parent_instance) - 0usize];
    ["Offset of field: _GFileInputStream::priv_"]
        [::std::mem::offset_of!(_GFileInputStream, priv_) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileInputStreamClass"][::std::mem::size_of::<_GFileInputStreamClass>() - 336usize];
    ["Alignment of _GFileInputStreamClass"]
        [::std::mem::align_of::<_GFileInputStreamClass>() - 8usize];
    ["Offset of field: _GFileInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GFileInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GFileInputStreamClass::tell"]
        [::std::mem::offset_of!(_GFileInputStreamClass, tell) - 248usize];
    ["Offset of field: _GFileInputStreamClass::can_seek"]
        [::std::mem::offset_of!(_GFileInputStreamClass, can_seek) - 256usize];
    ["Offset of field: _GFileInputStreamClass::seek"]
        [::std::mem::offset_of!(_GFileInputStreamClass, seek) - 264usize];
    ["Offset of field: _GFileInputStreamClass::query_info"]
        [::std::mem::offset_of!(_GFileInputStreamClass, query_info) - 272usize];
    ["Offset of field: _GFileInputStreamClass::query_info_async"]
        [::std::mem::offset_of!(_GFileInputStreamClass, query_info_async) - 280usize];
    ["Offset of field: _GFileInputStreamClass::query_info_finish"]
        [::std::mem::offset_of!(_GFileInputStreamClass, query_info_finish) - 288usize];
    ["Offset of field: _GFileInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFileInputStreamClass, _g_reserved1) - 296usize];
    ["Offset of field: _GFileInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFileInputStreamClass, _g_reserved2) - 304usize];
    ["Offset of field: _GFileInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFileInputStreamClass, _g_reserved3) - 312usize];
    ["Offset of field: _GFileInputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GFileInputStreamClass, _g_reserved4) - 320usize];
    ["Offset of field: _GFileInputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GFileInputStreamClass, _g_reserved5) - 328usize];
};
unsafe extern "C" {
    pub fn g_file_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_input_stream_query_info(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_input_stream_query_info_async(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_input_stream_query_info_finish(
        stream: *mut GFileInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_io_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_io_error_from_errno(err_no: gint) -> GIOErrorEnum;
}
unsafe extern "C" {
    pub fn g_io_error_from_file_error(file_error: GFileError) -> GIOErrorEnum;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GIOStreamPrivate = _GIOStreamPrivate;
pub type GIOStreamClass = _GIOStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStream {
    pub parent_instance: GObject,
    pub priv_: *mut GIOStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOStream"][::std::mem::size_of::<_GIOStream>() - 32usize];
    ["Alignment of _GIOStream"][::std::mem::align_of::<_GIOStream>() - 8usize];
    ["Offset of field: _GIOStream::parent_instance"]
        [::std::mem::offset_of!(_GIOStream, parent_instance) - 0usize];
    ["Offset of field: _GIOStream::priv_"][::std::mem::offset_of!(_GIOStream, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamClass {
    pub parent_class: GObjectClass,
    pub get_input_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GInputStream>,
    pub get_output_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GOutputStream>,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GIOStreamClass"][::std::mem::size_of::<_GIOStreamClass>() - 256usize];
    ["Alignment of _GIOStreamClass"][::std::mem::align_of::<_GIOStreamClass>() - 8usize];
    ["Offset of field: _GIOStreamClass::parent_class"]
        [::std::mem::offset_of!(_GIOStreamClass, parent_class) - 0usize];
    ["Offset of field: _GIOStreamClass::get_input_stream"]
        [::std::mem::offset_of!(_GIOStreamClass, get_input_stream) - 136usize];
    ["Offset of field: _GIOStreamClass::get_output_stream"]
        [::std::mem::offset_of!(_GIOStreamClass, get_output_stream) - 144usize];
    ["Offset of field: _GIOStreamClass::close_fn"]
        [::std::mem::offset_of!(_GIOStreamClass, close_fn) - 152usize];
    ["Offset of field: _GIOStreamClass::close_async"]
        [::std::mem::offset_of!(_GIOStreamClass, close_async) - 160usize];
    ["Offset of field: _GIOStreamClass::close_finish"]
        [::std::mem::offset_of!(_GIOStreamClass, close_finish) - 168usize];
    ["Offset of field: _GIOStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved1) - 176usize];
    ["Offset of field: _GIOStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved2) - 184usize];
    ["Offset of field: _GIOStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved3) - 192usize];
    ["Offset of field: _GIOStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved4) - 200usize];
    ["Offset of field: _GIOStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved5) - 208usize];
    ["Offset of field: _GIOStreamClass::_g_reserved6"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved6) - 216usize];
    ["Offset of field: _GIOStreamClass::_g_reserved7"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved7) - 224usize];
    ["Offset of field: _GIOStreamClass::_g_reserved8"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved8) - 232usize];
    ["Offset of field: _GIOStreamClass::_g_reserved9"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved9) - 240usize];
    ["Offset of field: _GIOStreamClass::_g_reserved10"]
        [::std::mem::offset_of!(_GIOStreamClass, _g_reserved10) - 248usize];
};
unsafe extern "C" {
    pub fn g_io_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_io_stream_splice_async(
        stream1: *mut GIOStream,
        stream2: *mut GIOStream,
        flags: GIOStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_io_stream_splice_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_stream_close(
        stream: *mut GIOStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_stream_close_async(
        stream: *mut GIOStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_io_stream_close_finish(
        stream: *mut GIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_stream_set_pending(stream: *mut GIOStream, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
}
pub type GFileIOStreamClass = _GFileIOStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileIOStreamPrivate = _GFileIOStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStream {
    pub parent_instance: GIOStream,
    pub priv_: *mut GFileIOStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileIOStream"][::std::mem::size_of::<_GFileIOStream>() - 40usize];
    ["Alignment of _GFileIOStream"][::std::mem::align_of::<_GFileIOStream>() - 8usize];
    ["Offset of field: _GFileIOStream::parent_instance"]
        [::std::mem::offset_of!(_GFileIOStream, parent_instance) - 0usize];
    ["Offset of field: _GFileIOStream::priv_"]
        [::std::mem::offset_of!(_GFileIOStream, priv_) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileIOStreamClass"][::std::mem::size_of::<_GFileIOStreamClass>() - 368usize];
    ["Alignment of _GFileIOStreamClass"][::std::mem::align_of::<_GFileIOStreamClass>() - 8usize];
    ["Offset of field: _GFileIOStreamClass::parent_class"]
        [::std::mem::offset_of!(_GFileIOStreamClass, parent_class) - 0usize];
    ["Offset of field: _GFileIOStreamClass::tell"]
        [::std::mem::offset_of!(_GFileIOStreamClass, tell) - 256usize];
    ["Offset of field: _GFileIOStreamClass::can_seek"]
        [::std::mem::offset_of!(_GFileIOStreamClass, can_seek) - 264usize];
    ["Offset of field: _GFileIOStreamClass::seek"]
        [::std::mem::offset_of!(_GFileIOStreamClass, seek) - 272usize];
    ["Offset of field: _GFileIOStreamClass::can_truncate"]
        [::std::mem::offset_of!(_GFileIOStreamClass, can_truncate) - 280usize];
    ["Offset of field: _GFileIOStreamClass::truncate_fn"]
        [::std::mem::offset_of!(_GFileIOStreamClass, truncate_fn) - 288usize];
    ["Offset of field: _GFileIOStreamClass::query_info"]
        [::std::mem::offset_of!(_GFileIOStreamClass, query_info) - 296usize];
    ["Offset of field: _GFileIOStreamClass::query_info_async"]
        [::std::mem::offset_of!(_GFileIOStreamClass, query_info_async) - 304usize];
    ["Offset of field: _GFileIOStreamClass::query_info_finish"]
        [::std::mem::offset_of!(_GFileIOStreamClass, query_info_finish) - 312usize];
    ["Offset of field: _GFileIOStreamClass::get_etag"]
        [::std::mem::offset_of!(_GFileIOStreamClass, get_etag) - 320usize];
    ["Offset of field: _GFileIOStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFileIOStreamClass, _g_reserved1) - 328usize];
    ["Offset of field: _GFileIOStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFileIOStreamClass, _g_reserved2) - 336usize];
    ["Offset of field: _GFileIOStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFileIOStreamClass, _g_reserved3) - 344usize];
    ["Offset of field: _GFileIOStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GFileIOStreamClass, _g_reserved4) - 352usize];
    ["Offset of field: _GFileIOStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GFileIOStreamClass, _g_reserved5) - 360usize];
};
unsafe extern "C" {
    pub fn g_file_io_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_io_stream_query_info(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_io_stream_query_info_async(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_io_stream_query_info_finish(
        stream: *mut GFileIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char;
}
pub type GFileMonitorClass = _GFileMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorPrivate {
    _unused: [u8; 0],
}
pub type GFileMonitorPrivate = _GFileMonitorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitor {
    pub parent_instance: GObject,
    pub priv_: *mut GFileMonitorPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileMonitor"][::std::mem::size_of::<_GFileMonitor>() - 32usize];
    ["Alignment of _GFileMonitor"][::std::mem::align_of::<_GFileMonitor>() - 8usize];
    ["Offset of field: _GFileMonitor::parent_instance"]
        [::std::mem::offset_of!(_GFileMonitor, parent_instance) - 0usize];
    ["Offset of field: _GFileMonitor::priv_"]
        [::std::mem::offset_of!(_GFileMonitor, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GFileMonitor,
            file: *mut GFile,
            other_file: *mut GFile,
            event_type: GFileMonitorEvent,
        ),
    >,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(monitor: *mut GFileMonitor) -> gboolean>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileMonitorClass"][::std::mem::size_of::<_GFileMonitorClass>() - 192usize];
    ["Alignment of _GFileMonitorClass"][::std::mem::align_of::<_GFileMonitorClass>() - 8usize];
    ["Offset of field: _GFileMonitorClass::parent_class"]
        [::std::mem::offset_of!(_GFileMonitorClass, parent_class) - 0usize];
    ["Offset of field: _GFileMonitorClass::changed"]
        [::std::mem::offset_of!(_GFileMonitorClass, changed) - 136usize];
    ["Offset of field: _GFileMonitorClass::cancel"]
        [::std::mem::offset_of!(_GFileMonitorClass, cancel) - 144usize];
    ["Offset of field: _GFileMonitorClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFileMonitorClass, _g_reserved1) - 152usize];
    ["Offset of field: _GFileMonitorClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFileMonitorClass, _g_reserved2) - 160usize];
    ["Offset of field: _GFileMonitorClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFileMonitorClass, _g_reserved3) - 168usize];
    ["Offset of field: _GFileMonitorClass::_g_reserved4"]
        [::std::mem::offset_of!(_GFileMonitorClass, _g_reserved4) - 176usize];
    ["Offset of field: _GFileMonitorClass::_g_reserved5"]
        [::std::mem::offset_of!(_GFileMonitorClass, _g_reserved5) - 184usize];
};
unsafe extern "C" {
    pub fn g_file_monitor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor) -> gboolean;
}
unsafe extern "C" {
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor, limit_msecs: gint);
}
unsafe extern "C" {
    pub fn g_file_monitor_emit_event(
        monitor: *mut GFileMonitor,
        child: *mut GFile,
        other_file: *mut GFile,
        event_type: GFileMonitorEvent,
    );
}
pub type GFilenameCompleterClass = _GFilenameCompleterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleterClass {
    pub parent_class: GObjectClass,
    pub got_completion_data:
        ::std::option::Option<unsafe extern "C" fn(filename_completer: *mut GFilenameCompleter)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFilenameCompleterClass"]
        [::std::mem::size_of::<_GFilenameCompleterClass>() - 168usize];
    ["Alignment of _GFilenameCompleterClass"]
        [::std::mem::align_of::<_GFilenameCompleterClass>() - 8usize];
    ["Offset of field: _GFilenameCompleterClass::parent_class"]
        [::std::mem::offset_of!(_GFilenameCompleterClass, parent_class) - 0usize];
    ["Offset of field: _GFilenameCompleterClass::got_completion_data"]
        [::std::mem::offset_of!(_GFilenameCompleterClass, got_completion_data) - 136usize];
    ["Offset of field: _GFilenameCompleterClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFilenameCompleterClass, _g_reserved1) - 144usize];
    ["Offset of field: _GFilenameCompleterClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFilenameCompleterClass, _g_reserved2) - 152usize];
    ["Offset of field: _GFilenameCompleterClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFilenameCompleterClass, _g_reserved3) - 160usize];
};
unsafe extern "C" {
    pub fn g_filename_completer_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
}
unsafe extern "C" {
    pub fn g_filename_completer_get_completion_suffix(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_filename_completer_get_completions(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_filename_completer_set_dirs_only(
        completer: *mut GFilenameCompleter,
        dirs_only: gboolean,
    );
}
pub type GFileOutputStreamClass = _GFileOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileOutputStreamPrivate = _GFileOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GFileOutputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileOutputStream"][::std::mem::size_of::<_GFileOutputStream>() - 40usize];
    ["Alignment of _GFileOutputStream"][::std::mem::align_of::<_GFileOutputStream>() - 8usize];
    ["Offset of field: _GFileOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GFileOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GFileOutputStream::priv_"]
        [::std::mem::offset_of!(_GFileOutputStream, priv_) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileOutputStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GFileOutputStreamClass"]
        [::std::mem::size_of::<_GFileOutputStreamClass>() - 408usize];
    ["Alignment of _GFileOutputStreamClass"]
        [::std::mem::align_of::<_GFileOutputStreamClass>() - 8usize];
    ["Offset of field: _GFileOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GFileOutputStreamClass::tell"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, tell) - 296usize];
    ["Offset of field: _GFileOutputStreamClass::can_seek"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, can_seek) - 304usize];
    ["Offset of field: _GFileOutputStreamClass::seek"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, seek) - 312usize];
    ["Offset of field: _GFileOutputStreamClass::can_truncate"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, can_truncate) - 320usize];
    ["Offset of field: _GFileOutputStreamClass::truncate_fn"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, truncate_fn) - 328usize];
    ["Offset of field: _GFileOutputStreamClass::query_info"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, query_info) - 336usize];
    ["Offset of field: _GFileOutputStreamClass::query_info_async"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, query_info_async) - 344usize];
    ["Offset of field: _GFileOutputStreamClass::query_info_finish"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, query_info_finish) - 352usize];
    ["Offset of field: _GFileOutputStreamClass::get_etag"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, get_etag) - 360usize];
    ["Offset of field: _GFileOutputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, _g_reserved1) - 368usize];
    ["Offset of field: _GFileOutputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, _g_reserved2) - 376usize];
    ["Offset of field: _GFileOutputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, _g_reserved3) - 384usize];
    ["Offset of field: _GFileOutputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, _g_reserved4) - 392usize];
    ["Offset of field: _GFileOutputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GFileOutputStreamClass, _g_reserved5) - 400usize];
};
unsafe extern "C" {
    pub fn g_file_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_output_stream_query_info(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_output_stream_query_info_async(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_file_output_stream_query_info_finish(
        stream: *mut GFileOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_file_output_stream_get_etag(
        stream: *mut GFileOutputStream,
    ) -> *mut ::std::os::raw::c_char;
}
pub type GInetAddressClass = _GInetAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressPrivate = _GInetAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInetAddress"][::std::mem::size_of::<_GInetAddress>() - 32usize];
    ["Alignment of _GInetAddress"][::std::mem::align_of::<_GInetAddress>() - 8usize];
    ["Offset of field: _GInetAddress::parent_instance"]
        [::std::mem::offset_of!(_GInetAddress, parent_instance) - 0usize];
    ["Offset of field: _GInetAddress::priv_"]
        [::std::mem::offset_of!(_GInetAddress, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressClass {
    pub parent_class: GObjectClass,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *mut gchar>,
    pub to_bytes:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *const guint8>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInetAddressClass"][::std::mem::size_of::<_GInetAddressClass>() - 152usize];
    ["Alignment of _GInetAddressClass"][::std::mem::align_of::<_GInetAddressClass>() - 8usize];
    ["Offset of field: _GInetAddressClass::parent_class"]
        [::std::mem::offset_of!(_GInetAddressClass, parent_class) - 0usize];
    ["Offset of field: _GInetAddressClass::to_string"]
        [::std::mem::offset_of!(_GInetAddressClass, to_string) - 136usize];
    ["Offset of field: _GInetAddressClass::to_bytes"]
        [::std::mem::offset_of!(_GInetAddressClass, to_bytes) - 144usize];
};
unsafe extern "C" {
    pub fn g_inet_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_inet_address_new_from_string(string: *const gchar) -> *mut GInetAddress;
}
unsafe extern "C" {
    pub fn g_inet_address_new_from_bytes(
        bytes: *const guint8,
        family: GSocketFamily,
    ) -> *mut GInetAddress;
}
unsafe extern "C" {
    pub fn g_inet_address_new_loopback(family: GSocketFamily) -> *mut GInetAddress;
}
unsafe extern "C" {
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
}
unsafe extern "C" {
    pub fn g_inet_address_equal(
        address: *mut GInetAddress,
        other_address: *mut GInetAddress,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress) -> *const guint8;
}
unsafe extern "C" {
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress) -> gsize;
}
unsafe extern "C" {
    pub fn g_inet_address_get_family(address: *mut GInetAddress) -> GSocketFamily;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress) -> gboolean;
}
pub type GInetAddressMaskClass = _GInetAddressMaskClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressMaskPrivate = _GInetAddressMaskPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMask {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressMaskPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInetAddressMask"][::std::mem::size_of::<_GInetAddressMask>() - 32usize];
    ["Alignment of _GInetAddressMask"][::std::mem::align_of::<_GInetAddressMask>() - 8usize];
    ["Offset of field: _GInetAddressMask::parent_instance"]
        [::std::mem::offset_of!(_GInetAddressMask, parent_instance) - 0usize];
    ["Offset of field: _GInetAddressMask::priv_"]
        [::std::mem::offset_of!(_GInetAddressMask, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInetAddressMaskClass"][::std::mem::size_of::<_GInetAddressMaskClass>() - 136usize];
    ["Alignment of _GInetAddressMaskClass"]
        [::std::mem::align_of::<_GInetAddressMaskClass>() - 8usize];
    ["Offset of field: _GInetAddressMaskClass::parent_class"]
        [::std::mem::offset_of!(_GInetAddressMaskClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_inet_address_mask_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_new(
        addr: *mut GInetAddress,
        length: guint,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_new_from_string(
        mask_string: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask) -> GSocketFamily;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask) -> *mut GInetAddress;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask) -> guint;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_matches(
        mask: *mut GInetAddressMask,
        address: *mut GInetAddress,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_inet_address_mask_equal(
        mask: *mut GInetAddressMask,
        mask2: *mut GInetAddressMask,
    ) -> gboolean;
}
pub type GSocketAddressClass = _GSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddress {
    pub parent_instance: GObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketAddress"][::std::mem::size_of::<_GSocketAddress>() - 24usize];
    ["Alignment of _GSocketAddress"][::std::mem::align_of::<_GSocketAddress>() - 8usize];
    ["Offset of field: _GSocketAddress::parent_instance"]
        [::std::mem::offset_of!(_GSocketAddress, parent_instance) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressClass {
    pub parent_class: GObjectClass,
    pub get_family:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> GSocketFamily>,
    pub get_native_size:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> gssize>,
    pub to_native: ::std::option::Option<
        unsafe extern "C" fn(
            address: *mut GSocketAddress,
            dest: gpointer,
            destlen: gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketAddressClass"][::std::mem::size_of::<_GSocketAddressClass>() - 160usize];
    ["Alignment of _GSocketAddressClass"][::std::mem::align_of::<_GSocketAddressClass>() - 8usize];
    ["Offset of field: _GSocketAddressClass::parent_class"]
        [::std::mem::offset_of!(_GSocketAddressClass, parent_class) - 0usize];
    ["Offset of field: _GSocketAddressClass::get_family"]
        [::std::mem::offset_of!(_GSocketAddressClass, get_family) - 136usize];
    ["Offset of field: _GSocketAddressClass::get_native_size"]
        [::std::mem::offset_of!(_GSocketAddressClass, get_native_size) - 144usize];
    ["Offset of field: _GSocketAddressClass::to_native"]
        [::std::mem::offset_of!(_GSocketAddressClass, to_native) - 152usize];
};
unsafe extern "C" {
    pub fn g_socket_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_address_get_family(address: *mut GSocketAddress) -> GSocketFamily;
}
unsafe extern "C" {
    pub fn g_socket_address_new_from_native(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_address_to_native(
        address: *mut GSocketAddress,
        dest: gpointer,
        destlen: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress) -> gssize;
}
pub type GInetSocketAddressClass = _GInetSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetSocketAddressPrivate = _GInetSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GInetSocketAddressPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInetSocketAddress"][::std::mem::size_of::<_GInetSocketAddress>() - 32usize];
    ["Alignment of _GInetSocketAddress"][::std::mem::align_of::<_GInetSocketAddress>() - 8usize];
    ["Offset of field: _GInetSocketAddress::parent_instance"]
        [::std::mem::offset_of!(_GInetSocketAddress, parent_instance) - 0usize];
    ["Offset of field: _GInetSocketAddress::priv_"]
        [::std::mem::offset_of!(_GInetSocketAddress, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GInetSocketAddressClass"]
        [::std::mem::size_of::<_GInetSocketAddressClass>() - 160usize];
    ["Alignment of _GInetSocketAddressClass"]
        [::std::mem::align_of::<_GInetSocketAddressClass>() - 8usize];
    ["Offset of field: _GInetSocketAddressClass::parent_class"]
        [::std::mem::offset_of!(_GInetSocketAddressClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_inet_socket_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_inet_socket_address_new(
        address: *mut GInetAddress,
        port: guint16,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_inet_socket_address_new_from_string(
        address: *const ::std::os::raw::c_char,
        port: guint,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress)
        -> *mut GInetAddress;
}
unsafe extern "C" {
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress) -> guint16;
}
unsafe extern "C" {
    pub fn g_inet_socket_address_get_flowinfo(address: *mut GInetSocketAddress) -> guint32;
}
unsafe extern "C" {
    pub fn g_inet_socket_address_get_scope_id(address: *mut GInetSocketAddress) -> guint32;
}
unsafe extern "C" {
    pub fn g_app_info_create_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_converter_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_converter_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_data_stream_byte_order_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_data_stream_newline_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_attribute_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_attribute_info_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_attribute_status_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_query_info_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_create_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_measure_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mount_mount_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mount_unmount_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_drive_start_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_drive_start_stop_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_copy_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_monitor_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_filesystem_preview_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_file_monitor_event_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_error_enum_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_ask_password_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_password_save_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mount_operation_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_output_stream_splice_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_stream_splice_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_emblem_origin_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resolver_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resolver_record_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resource_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resource_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resource_lookup_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_family_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_msg_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_protocol_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_zlib_compressor_format_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bus_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bus_name_owner_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_bus_name_watcher_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_proxy_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_connection_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_capability_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_call_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_message_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_message_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_message_header_field_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_property_info_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_subtree_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_server_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_signal_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_send_message_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_credentials_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_message_byte_order_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_application_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_certificate_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_authentication_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_channel_binding_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_channel_binding_error_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_rehandshake_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_password_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_interaction_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_interface_skeleton_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_dbus_object_manager_client_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_database_verify_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_certificate_request_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_protocol_version_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_module_scope_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_client_event_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_listener_event_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_test_dbus_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_subprocess_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_notification_priority_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_network_connectivity_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pollable_return_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_memory_monitor_warning_level_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resolver_name_lookup_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_settings_bind_flags_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleScope {
    _unused: [u8; 0],
}
pub type GIOModuleScope = _GIOModuleScope;
unsafe extern "C" {
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags) -> *mut GIOModuleScope;
}
unsafe extern "C" {
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
}
unsafe extern "C" {
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope, basename: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleClass {
    _unused: [u8; 0],
}
pub type GIOModuleClass = _GIOModuleClass;
unsafe extern "C" {
    pub fn g_io_module_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_io_module_new(filename: *const gchar) -> *mut GIOModule;
}
unsafe extern "C" {
    pub fn g_io_modules_scan_all_in_directory(dirname: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn g_io_modules_load_all_in_directory(dirname: *const gchar) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_io_modules_scan_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    );
}
unsafe extern "C" {
    pub fn g_io_modules_load_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_io_extension_point_register(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
unsafe extern "C" {
    pub fn g_io_extension_point_lookup(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
unsafe extern "C" {
    pub fn g_io_extension_point_set_required_type(
        extension_point: *mut GIOExtensionPoint,
        type_: GType,
    );
}
unsafe extern "C" {
    pub fn g_io_extension_point_get_required_type(extension_point: *mut GIOExtensionPoint)
        -> GType;
}
unsafe extern "C" {
    pub fn g_io_extension_point_get_extensions(
        extension_point: *mut GIOExtensionPoint,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_io_extension_point_get_extension_by_name(
        extension_point: *mut GIOExtensionPoint,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtension;
}
unsafe extern "C" {
    pub fn g_io_extension_point_implement(
        extension_point_name: *const ::std::os::raw::c_char,
        type_: GType,
        extension_name: *const ::std::os::raw::c_char,
        priority: gint,
    ) -> *mut GIOExtension;
}
unsafe extern "C" {
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
}
unsafe extern "C" {
    pub fn g_io_extension_get_name(extension: *mut GIOExtension) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> gint;
}
unsafe extern "C" {
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension) -> *mut GTypeClass;
}
unsafe extern "C" {
    #[doc = " g_io_module_load: (skip)\n @module: a #GIOModule.\n\n Required API for GIO modules to implement.\n\n This function is run after the module has been loaded into GIO,\n to initialize the module. Typically, this function will call\n g_io_extension_point_implement().\n\n Since 2.56, this function should be named `g_io_<modulename>_load`, where\n `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds."]
    pub fn g_io_module_load(module: *mut GIOModule);
}
unsafe extern "C" {
    #[doc = " g_io_module_unload: (skip)\n @module: a #GIOModule.\n\n Required API for GIO modules to implement.\n\n This function is run when the module is being unloaded from GIO,\n to finalize the module.\n\n Since 2.56, this function should be named `g_io_<modulename>_unload`, where\n `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds."]
    pub fn g_io_module_unload(module: *mut GIOModule);
}
unsafe extern "C" {
    #[doc = " g_io_module_query:\n\n Optional API for GIO modules to implement.\n\n Should return a list of all the extension points that may be\n implemented in this module.\n\n This method will not be called in normal use, however it may be\n called when probing existing modules and recording which extension\n points that this model is used for. This means we won't have to\n load and initialize this module unless its needed.\n\n If this function is not implemented by the module the module will\n always be loaded, initialized and then unloaded on application\n startup so that it can register its extension points during init.\n\n Note that a module need not actually implement all the extension\n points that g_io_module_query() returns, since the exact list of\n extension may depend on runtime issues. However all extension\n points actually implemented must be returned by g_io_module_query()\n (if defined).\n\n When installing a module that implements g_io_module_query() you must\n run gio-querymodules in order to build the cache files required for\n lazy loading.\n\n Since 2.56, this function should be named `g_io_<modulename>_query`, where\n `modulename` is the plugin’s filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds.\n\n Returns: (transfer full): A %NULL-terminated array of strings,\n     listing the supported extension points of the module. The array\n     must be suitable for freeing with g_strfreev().\n\n Since: 2.24"]
    pub fn g_io_module_query() -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_io_scheduler_push_job(
        job_func: GIOSchedulerJobFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
        io_priority: gint,
        cancellable: *mut GCancellable,
    );
}
unsafe extern "C" {
    pub fn g_io_scheduler_cancel_all_jobs();
}
unsafe extern "C" {
    pub fn g_io_scheduler_job_send_to_mainloop(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_io_scheduler_job_send_to_mainloop_async(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_list_model_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModel {
    _unused: [u8; 0],
}
pub type GListModel = _GListModel;
pub type GListModelInterface = _GListModelInterface;
pub type GListModel_autoptr = *mut GListModel;
pub type GListModel_listautoptr = *mut GList;
pub type GListModel_slistautoptr = *mut GSList;
pub type GListModel_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModelInterface {
    pub g_iface: GTypeInterface,
    pub get_item_type: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> GType>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> guint>,
    pub get_item: ::std::option::Option<
        unsafe extern "C" fn(list: *mut GListModel, position: guint) -> gpointer,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GListModelInterface"][::std::mem::size_of::<_GListModelInterface>() - 40usize];
    ["Alignment of _GListModelInterface"][::std::mem::align_of::<_GListModelInterface>() - 8usize];
    ["Offset of field: _GListModelInterface::g_iface"]
        [::std::mem::offset_of!(_GListModelInterface, g_iface) - 0usize];
    ["Offset of field: _GListModelInterface::get_item_type"]
        [::std::mem::offset_of!(_GListModelInterface, get_item_type) - 16usize];
    ["Offset of field: _GListModelInterface::get_n_items"]
        [::std::mem::offset_of!(_GListModelInterface, get_n_items) - 24usize];
    ["Offset of field: _GListModelInterface::get_item"]
        [::std::mem::offset_of!(_GListModelInterface, get_item) - 32usize];
};
unsafe extern "C" {
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
}
unsafe extern "C" {
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> guint;
}
unsafe extern "C" {
    pub fn g_list_model_get_item(list: *mut GListModel, position: guint) -> gpointer;
}
unsafe extern "C" {
    pub fn g_list_model_get_object(list: *mut GListModel, position: guint) -> *mut GObject;
}
unsafe extern "C" {
    pub fn g_list_model_items_changed(
        list: *mut GListModel,
        position: guint,
        removed: guint,
        added: guint,
    );
}
unsafe extern "C" {
    pub fn g_list_store_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListStore {
    _unused: [u8; 0],
}
pub type GListStore = _GListStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GListStoreClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GListStoreClass"][::std::mem::size_of::<GListStoreClass>() - 136usize];
    ["Alignment of GListStoreClass"][::std::mem::align_of::<GListStoreClass>() - 8usize];
    ["Offset of field: GListStoreClass::parent_class"]
        [::std::mem::offset_of!(GListStoreClass, parent_class) - 0usize];
};
pub type GListStore_autoptr = *mut GListStore;
pub type GListStore_listautoptr = *mut GList;
pub type GListStore_slistautoptr = *mut GSList;
pub type GListStore_queueautoptr = *mut GQueue;
pub type GListStoreClass_autoptr = *mut GListStoreClass;
pub type GListStoreClass_listautoptr = *mut GList;
pub type GListStoreClass_slistautoptr = *mut GSList;
pub type GListStoreClass_queueautoptr = *mut GQueue;
unsafe extern "C" {
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
}
unsafe extern "C" {
    pub fn g_list_store_insert(store: *mut GListStore, position: guint, item: gpointer);
}
unsafe extern "C" {
    pub fn g_list_store_insert_sorted(
        store: *mut GListStore,
        item: gpointer,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_list_store_sort(
        store: *mut GListStore,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_list_store_append(store: *mut GListStore, item: gpointer);
}
unsafe extern "C" {
    pub fn g_list_store_remove(store: *mut GListStore, position: guint);
}
unsafe extern "C" {
    pub fn g_list_store_remove_all(store: *mut GListStore);
}
unsafe extern "C" {
    pub fn g_list_store_splice(
        store: *mut GListStore,
        position: guint,
        n_removals: guint,
        additions: *mut gpointer,
        n_additions: guint,
    );
}
unsafe extern "C" {
    pub fn g_list_store_find(
        store: *mut GListStore,
        item: gpointer,
        position: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_list_store_find_with_equal_func(
        store: *mut GListStore,
        item: gpointer,
        equal_func: GEqualFunc,
        position: *mut guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_list_store_find_with_equal_func_full(
        store: *mut GListStore,
        item: gpointer,
        equal_func: GEqualFuncFull,
        user_data: gpointer,
        position: *mut guint,
    ) -> gboolean;
}
#[doc = " GLoadableIconIface:\n @g_iface: The parent interface.\n @load: Loads an icon.\n @load_async: Loads an icon asynchronously.\n @load_finish: Finishes an asynchronous icon load.\n\n Interface for icons that can be loaded as a stream."]
pub type GLoadableIconIface = _GLoadableIconIface;
#[doc = " GLoadableIconIface:\n @g_iface: The parent interface.\n @load: Loads an icon.\n @load_async: Loads an icon asynchronously.\n @load_finish: Finishes an asynchronous icon load.\n\n Interface for icons that can be loaded as a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIconIface {
    pub g_iface: GTypeInterface,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            type_: *mut *mut ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
    pub load_async: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub load_finish: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            res: *mut GAsyncResult,
            type_: *mut *mut ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GLoadableIconIface"][::std::mem::size_of::<_GLoadableIconIface>() - 40usize];
    ["Alignment of _GLoadableIconIface"][::std::mem::align_of::<_GLoadableIconIface>() - 8usize];
    ["Offset of field: _GLoadableIconIface::g_iface"]
        [::std::mem::offset_of!(_GLoadableIconIface, g_iface) - 0usize];
    ["Offset of field: _GLoadableIconIface::load"]
        [::std::mem::offset_of!(_GLoadableIconIface, load) - 16usize];
    ["Offset of field: _GLoadableIconIface::load_async"]
        [::std::mem::offset_of!(_GLoadableIconIface, load_async) - 24usize];
    ["Offset of field: _GLoadableIconIface::load_finish"]
        [::std::mem::offset_of!(_GLoadableIconIface, load_finish) - 32usize];
};
unsafe extern "C" {
    pub fn g_loadable_icon_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_loadable_icon_load(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        type_: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_loadable_icon_load_async(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_loadable_icon_load_finish(
        icon: *mut GLoadableIcon,
        res: *mut GAsyncResult,
        type_: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
pub type GMemoryInputStreamClass = _GMemoryInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GMemoryInputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemoryInputStream"][::std::mem::size_of::<_GMemoryInputStream>() - 40usize];
    ["Alignment of _GMemoryInputStream"][::std::mem::align_of::<_GMemoryInputStream>() - 8usize];
    ["Offset of field: _GMemoryInputStream::parent_instance"]
        [::std::mem::offset_of!(_GMemoryInputStream, parent_instance) - 0usize];
    ["Offset of field: _GMemoryInputStream::priv_"]
        [::std::mem::offset_of!(_GMemoryInputStream, priv_) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemoryInputStreamClass"]
        [::std::mem::size_of::<_GMemoryInputStreamClass>() - 288usize];
    ["Alignment of _GMemoryInputStreamClass"]
        [::std::mem::align_of::<_GMemoryInputStreamClass>() - 8usize];
    ["Offset of field: _GMemoryInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GMemoryInputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GMemoryInputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GMemoryInputStreamClass, _g_reserved1) - 248usize];
    ["Offset of field: _GMemoryInputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GMemoryInputStreamClass, _g_reserved2) - 256usize];
    ["Offset of field: _GMemoryInputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GMemoryInputStreamClass, _g_reserved3) - 264usize];
    ["Offset of field: _GMemoryInputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GMemoryInputStreamClass, _g_reserved4) - 272usize];
    ["Offset of field: _GMemoryInputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GMemoryInputStreamClass, _g_reserved5) - 280usize];
};
unsafe extern "C" {
    pub fn g_memory_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_memory_input_stream_new_from_data(
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut GBytes) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_memory_input_stream_add_data(
        stream: *mut GMemoryInputStream,
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream, bytes: *mut GBytes);
}
unsafe extern "C" {
    pub fn g_memory_monitor_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryMonitor {
    _unused: [u8; 0],
}
pub type GMemoryMonitor = _GMemoryMonitor;
pub type GMemoryMonitorInterface = _GMemoryMonitorInterface;
pub type GMemoryMonitor_autoptr = *mut GMemoryMonitor;
pub type GMemoryMonitor_listautoptr = *mut GList;
pub type GMemoryMonitor_slistautoptr = *mut GSList;
pub type GMemoryMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryMonitorInterface {
    pub g_iface: GTypeInterface,
    pub low_memory_warning: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GMemoryMonitor, level: GMemoryMonitorWarningLevel),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemoryMonitorInterface"]
        [::std::mem::size_of::<_GMemoryMonitorInterface>() - 24usize];
    ["Alignment of _GMemoryMonitorInterface"]
        [::std::mem::align_of::<_GMemoryMonitorInterface>() - 8usize];
    ["Offset of field: _GMemoryMonitorInterface::g_iface"]
        [::std::mem::offset_of!(_GMemoryMonitorInterface, g_iface) - 0usize];
    ["Offset of field: _GMemoryMonitorInterface::low_memory_warning"]
        [::std::mem::offset_of!(_GMemoryMonitorInterface, low_memory_warning) - 16usize];
};
unsafe extern "C" {
    pub fn g_memory_monitor_dup_default() -> *mut GMemoryMonitor;
}
pub type GMemoryOutputStreamClass = _GMemoryOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GMemoryOutputStreamPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemoryOutputStream"][::std::mem::size_of::<_GMemoryOutputStream>() - 40usize];
    ["Alignment of _GMemoryOutputStream"][::std::mem::align_of::<_GMemoryOutputStream>() - 8usize];
    ["Offset of field: _GMemoryOutputStream::parent_instance"]
        [::std::mem::offset_of!(_GMemoryOutputStream, parent_instance) - 0usize];
    ["Offset of field: _GMemoryOutputStream::priv_"]
        [::std::mem::offset_of!(_GMemoryOutputStream, priv_) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMemoryOutputStreamClass"]
        [::std::mem::size_of::<_GMemoryOutputStreamClass>() - 336usize];
    ["Alignment of _GMemoryOutputStreamClass"]
        [::std::mem::align_of::<_GMemoryOutputStreamClass>() - 8usize];
    ["Offset of field: _GMemoryOutputStreamClass::parent_class"]
        [::std::mem::offset_of!(_GMemoryOutputStreamClass, parent_class) - 0usize];
    ["Offset of field: _GMemoryOutputStreamClass::_g_reserved1"]
        [::std::mem::offset_of!(_GMemoryOutputStreamClass, _g_reserved1) - 296usize];
    ["Offset of field: _GMemoryOutputStreamClass::_g_reserved2"]
        [::std::mem::offset_of!(_GMemoryOutputStreamClass, _g_reserved2) - 304usize];
    ["Offset of field: _GMemoryOutputStreamClass::_g_reserved3"]
        [::std::mem::offset_of!(_GMemoryOutputStreamClass, _g_reserved3) - 312usize];
    ["Offset of field: _GMemoryOutputStreamClass::_g_reserved4"]
        [::std::mem::offset_of!(_GMemoryOutputStreamClass, _g_reserved4) - 320usize];
    ["Offset of field: _GMemoryOutputStreamClass::_g_reserved5"]
        [::std::mem::offset_of!(_GMemoryOutputStreamClass, _g_reserved5) - 328usize];
};
#[doc = " GReallocFunc:\n @data: memory block to reallocate\n @size: size to reallocate @data to\n\n Changes the size of the memory block pointed to by @data to\n @size bytes.\n\n The function should have the same semantics as realloc().\n\n Returns: a pointer to the reallocated memory"]
pub type GReallocFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, size: gsize) -> gpointer>;
unsafe extern "C" {
    pub fn g_memory_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_new(
        data: gpointer,
        size: gsize,
        realloc_function: GReallocFunc,
        destroy_function: GDestroyNotify,
    ) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_get_data_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_steal_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
unsafe extern "C" {
    pub fn g_memory_output_stream_steal_as_bytes(ostream: *mut GMemoryOutputStream) -> *mut GBytes;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelPrivate {
    _unused: [u8; 0],
}
pub type GMenuModelPrivate = _GMenuModelPrivate;
#[doc = " GMenuModelClass::get_item_attributes:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item\n\n Gets all the attributes associated with the item in the menu model.\n/\n/**\n GMenuModelClass::get_item_links:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @links: (out) (element-type utf8 Gio.MenuModel): Links from the item\n\n Gets all the links associated with the item in the menu model."]
pub type GMenuModelClass = _GMenuModelClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate;
pub type GMenuAttributeIterClass = _GMenuAttributeIterClass;
pub type GMenuAttributeIter = _GMenuAttributeIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuLinkIterPrivate = _GMenuLinkIterPrivate;
pub type GMenuLinkIterClass = _GMenuLinkIterClass;
pub type GMenuLinkIter = _GMenuLinkIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModel {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuModelPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMenuModel"][::std::mem::size_of::<_GMenuModel>() - 32usize];
    ["Alignment of _GMenuModel"][::std::mem::align_of::<_GMenuModel>() - 8usize];
    ["Offset of field: _GMenuModel::parent_instance"]
        [::std::mem::offset_of!(_GMenuModel, parent_instance) - 0usize];
    ["Offset of field: _GMenuModel::priv_"][::std::mem::offset_of!(_GMenuModel, priv_) - 24usize];
};
#[doc = " GMenuModelClass::get_item_attributes:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item\n\n Gets all the attributes associated with the item in the menu model.\n/\n/**\n GMenuModelClass::get_item_links:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @links: (out) (element-type utf8 Gio.MenuModel): Links from the item\n\n Gets all the links associated with the item in the menu model."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelClass {
    pub parent_class: GObjectClass,
    pub is_mutable: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gboolean>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gint>,
    pub get_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attributes: *mut *mut GHashTable,
        ),
    >,
    pub iterate_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuAttributeIter,
    >,
    pub get_item_attribute_value: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attribute: *const gchar,
            expected_type: *const GVariantType,
        ) -> *mut GVariant,
    >,
    pub get_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint, links: *mut *mut GHashTable),
    >,
    pub iterate_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuLinkIter,
    >,
    pub get_item_link: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            link: *const gchar,
        ) -> *mut GMenuModel,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMenuModelClass"][::std::mem::size_of::<_GMenuModelClass>() - 200usize];
    ["Alignment of _GMenuModelClass"][::std::mem::align_of::<_GMenuModelClass>() - 8usize];
    ["Offset of field: _GMenuModelClass::parent_class"]
        [::std::mem::offset_of!(_GMenuModelClass, parent_class) - 0usize];
    ["Offset of field: _GMenuModelClass::is_mutable"]
        [::std::mem::offset_of!(_GMenuModelClass, is_mutable) - 136usize];
    ["Offset of field: _GMenuModelClass::get_n_items"]
        [::std::mem::offset_of!(_GMenuModelClass, get_n_items) - 144usize];
    ["Offset of field: _GMenuModelClass::get_item_attributes"]
        [::std::mem::offset_of!(_GMenuModelClass, get_item_attributes) - 152usize];
    ["Offset of field: _GMenuModelClass::iterate_item_attributes"]
        [::std::mem::offset_of!(_GMenuModelClass, iterate_item_attributes) - 160usize];
    ["Offset of field: _GMenuModelClass::get_item_attribute_value"]
        [::std::mem::offset_of!(_GMenuModelClass, get_item_attribute_value) - 168usize];
    ["Offset of field: _GMenuModelClass::get_item_links"]
        [::std::mem::offset_of!(_GMenuModelClass, get_item_links) - 176usize];
    ["Offset of field: _GMenuModelClass::iterate_item_links"]
        [::std::mem::offset_of!(_GMenuModelClass, iterate_item_links) - 184usize];
    ["Offset of field: _GMenuModelClass::get_item_link"]
        [::std::mem::offset_of!(_GMenuModelClass, get_item_link) - 192usize];
};
unsafe extern "C" {
    pub fn g_menu_model_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> gint;
}
unsafe extern "C" {
    pub fn g_menu_model_iterate_item_attributes(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuAttributeIter;
}
unsafe extern "C" {
    pub fn g_menu_model_get_item_attribute_value(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_menu_model_get_item_attribute(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_model_iterate_item_links(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuLinkIter;
}
unsafe extern "C" {
    pub fn g_menu_model_get_item_link(
        model: *mut GMenuModel,
        item_index: gint,
        link: *const gchar,
    ) -> *mut GMenuModel;
}
unsafe extern "C" {
    pub fn g_menu_model_items_changed(
        model: *mut GMenuModel,
        position: gint,
        removed: gint,
        added: gint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuAttributeIterPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMenuAttributeIter"][::std::mem::size_of::<_GMenuAttributeIter>() - 32usize];
    ["Alignment of _GMenuAttributeIter"][::std::mem::align_of::<_GMenuAttributeIter>() - 8usize];
    ["Offset of field: _GMenuAttributeIter::parent_instance"]
        [::std::mem::offset_of!(_GMenuAttributeIter, parent_instance) - 0usize];
    ["Offset of field: _GMenuAttributeIter::priv_"]
        [::std::mem::offset_of!(_GMenuAttributeIter, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuAttributeIter,
            out_name: *mut *const gchar,
            value: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMenuAttributeIterClass"]
        [::std::mem::size_of::<_GMenuAttributeIterClass>() - 144usize];
    ["Alignment of _GMenuAttributeIterClass"]
        [::std::mem::align_of::<_GMenuAttributeIterClass>() - 8usize];
    ["Offset of field: _GMenuAttributeIterClass::parent_class"]
        [::std::mem::offset_of!(_GMenuAttributeIterClass, parent_class) - 0usize];
    ["Offset of field: _GMenuAttributeIterClass::get_next"]
        [::std::mem::offset_of!(_GMenuAttributeIterClass, get_next) - 136usize];
};
unsafe extern "C" {
    pub fn g_menu_attribute_iter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_menu_attribute_iter_get_next(
        iter: *mut GMenuAttributeIter,
        out_name: *mut *const gchar,
        value: *mut *mut GVariant,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter) -> *mut GVariant;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuLinkIterPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMenuLinkIter"][::std::mem::size_of::<_GMenuLinkIter>() - 32usize];
    ["Alignment of _GMenuLinkIter"][::std::mem::align_of::<_GMenuLinkIter>() - 8usize];
    ["Offset of field: _GMenuLinkIter::parent_instance"]
        [::std::mem::offset_of!(_GMenuLinkIter, parent_instance) - 0usize];
    ["Offset of field: _GMenuLinkIter::priv_"]
        [::std::mem::offset_of!(_GMenuLinkIter, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuLinkIter,
            out_link: *mut *const gchar,
            value: *mut *mut GMenuModel,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMenuLinkIterClass"][::std::mem::size_of::<_GMenuLinkIterClass>() - 144usize];
    ["Alignment of _GMenuLinkIterClass"][::std::mem::align_of::<_GMenuLinkIterClass>() - 8usize];
    ["Offset of field: _GMenuLinkIterClass::parent_class"]
        [::std::mem::offset_of!(_GMenuLinkIterClass, parent_class) - 0usize];
    ["Offset of field: _GMenuLinkIterClass::get_next"]
        [::std::mem::offset_of!(_GMenuLinkIterClass, get_next) - 136usize];
};
unsafe extern "C" {
    pub fn g_menu_link_iter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_menu_link_iter_get_next(
        iter: *mut GMenuLinkIter,
        out_link: *mut *const gchar,
        value: *mut *mut GMenuModel,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter) -> *mut GMenuModel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuItem {
    _unused: [u8; 0],
}
pub type GMenuItem = _GMenuItem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenu {
    _unused: [u8; 0],
}
pub type GMenu = _GMenu;
unsafe extern "C" {
    pub fn g_menu_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_menu_new() -> *mut GMenu;
}
unsafe extern "C" {
    pub fn g_menu_freeze(menu: *mut GMenu);
}
unsafe extern "C" {
    pub fn g_menu_insert_item(menu: *mut GMenu, position: gint, item: *mut GMenuItem);
}
unsafe extern "C" {
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
}
unsafe extern "C" {
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
}
unsafe extern "C" {
    pub fn g_menu_remove(menu: *mut GMenu, position: gint);
}
unsafe extern "C" {
    pub fn g_menu_remove_all(menu: *mut GMenu);
}
unsafe extern "C" {
    pub fn g_menu_insert(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
unsafe extern "C" {
    pub fn g_menu_append(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
unsafe extern "C" {
    pub fn g_menu_insert_section(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        section: *mut GMenuModel,
    );
}
unsafe extern "C" {
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
unsafe extern "C" {
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
unsafe extern "C" {
    pub fn g_menu_insert_submenu(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        submenu: *mut GMenuModel,
    );
}
unsafe extern "C" {
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
unsafe extern "C" {
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
unsafe extern "C" {
    pub fn g_menu_item_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_menu_item_new(label: *const gchar, detailed_action: *const gchar) -> *mut GMenuItem;
}
unsafe extern "C" {
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel, item_index: gint) -> *mut GMenuItem;
}
unsafe extern "C" {
    pub fn g_menu_item_new_submenu(label: *const gchar, submenu: *mut GMenuModel)
        -> *mut GMenuItem;
}
unsafe extern "C" {
    pub fn g_menu_item_new_section(label: *const gchar, section: *mut GMenuModel)
        -> *mut GMenuItem;
}
unsafe extern "C" {
    pub fn g_menu_item_get_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_menu_item_get_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const gchar) -> *mut GMenuModel;
}
unsafe extern "C" {
    pub fn g_menu_item_set_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_menu_item_set_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_menu_item_set_link(
        menu_item: *mut GMenuItem,
        link: *const gchar,
        model: *mut GMenuModel,
    );
}
unsafe extern "C" {
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem, label: *const gchar);
}
unsafe extern "C" {
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem, submenu: *mut GMenuModel);
}
unsafe extern "C" {
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem, section: *mut GMenuModel);
}
unsafe extern "C" {
    pub fn g_menu_item_set_action_and_target_value(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        target_value: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_menu_item_set_action_and_target(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        format_string: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_menu_item_set_detailed_action(
        menu_item: *mut GMenuItem,
        detailed_action: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
}
unsafe extern "C" {
    pub fn g_dbus_connection_export_menu_model(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        menu: *mut GMenuModel,
        error: *mut *mut GError,
    ) -> guint;
}
unsafe extern "C" {
    pub fn g_dbus_connection_unexport_menu_model(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
#[doc = " GMountIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the mount's state has changed.\n @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.\n @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.\n @get_root: Gets a #GFile to the root directory of the #GMount.\n @get_name: Gets a string containing the name of the #GMount.\n @get_icon: Gets a #GIcon for the #GMount.\n @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.\n @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.\n @can_unmount: Checks if a #GMount can be unmounted.\n @can_eject: Checks if a #GMount can be ejected.\n @unmount: Starts unmounting a #GMount.\n @unmount_finish: Finishes an unmounting operation.\n @eject: Starts ejecting a #GMount.\n @eject_finish: Finishes an eject operation.\n @remount: Starts remounting a #GMount.\n @remount_finish: Finishes a remounting operation.\n @guess_content_type: Starts guessing the type of the content of a #GMount.\n     See g_mount_guess_content_type() for more information on content\n     type guessing. This operation was added in 2.18.\n @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.\n @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18\n @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.\n @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.\n @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.\n @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.\n\n Interface for implementing operations for mounts."]
pub type GMountIface = _GMountIface;
#[doc = " GMountIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the mount's state has changed.\n @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.\n @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.\n @get_root: Gets a #GFile to the root directory of the #GMount.\n @get_name: Gets a string containing the name of the #GMount.\n @get_icon: Gets a #GIcon for the #GMount.\n @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.\n @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.\n @can_unmount: Checks if a #GMount can be unmounted.\n @can_eject: Checks if a #GMount can be ejected.\n @unmount: Starts unmounting a #GMount.\n @unmount_finish: Finishes an unmounting operation.\n @eject: Starts ejecting a #GMount.\n @eject_finish: Finishes an eject operation.\n @remount: Starts remounting a #GMount.\n @remount_finish: Finishes a remounting operation.\n @guess_content_type: Starts guessing the type of the content of a #GMount.\n     See g_mount_guess_content_type() for more information on content\n     type guessing. This operation was added in 2.18.\n @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.\n @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18\n @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.\n @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.\n @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.\n @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.\n\n Interface for implementing operations for mounts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmounted: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub get_root: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_volume: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GVolume>,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GDrive>,
    pub can_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub unmount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub remount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub remount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub guess_content_type: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub guess_content_type_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub guess_content_type_sync: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub pre_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmount_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_default_location:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMountIface"][::std::mem::size_of::<_GMountIface>() - 232usize];
    ["Alignment of _GMountIface"][::std::mem::align_of::<_GMountIface>() - 8usize];
    ["Offset of field: _GMountIface::g_iface"]
        [::std::mem::offset_of!(_GMountIface, g_iface) - 0usize];
    ["Offset of field: _GMountIface::changed"]
        [::std::mem::offset_of!(_GMountIface, changed) - 16usize];
    ["Offset of field: _GMountIface::unmounted"]
        [::std::mem::offset_of!(_GMountIface, unmounted) - 24usize];
    ["Offset of field: _GMountIface::get_root"]
        [::std::mem::offset_of!(_GMountIface, get_root) - 32usize];
    ["Offset of field: _GMountIface::get_name"]
        [::std::mem::offset_of!(_GMountIface, get_name) - 40usize];
    ["Offset of field: _GMountIface::get_icon"]
        [::std::mem::offset_of!(_GMountIface, get_icon) - 48usize];
    ["Offset of field: _GMountIface::get_uuid"]
        [::std::mem::offset_of!(_GMountIface, get_uuid) - 56usize];
    ["Offset of field: _GMountIface::get_volume"]
        [::std::mem::offset_of!(_GMountIface, get_volume) - 64usize];
    ["Offset of field: _GMountIface::get_drive"]
        [::std::mem::offset_of!(_GMountIface, get_drive) - 72usize];
    ["Offset of field: _GMountIface::can_unmount"]
        [::std::mem::offset_of!(_GMountIface, can_unmount) - 80usize];
    ["Offset of field: _GMountIface::can_eject"]
        [::std::mem::offset_of!(_GMountIface, can_eject) - 88usize];
    ["Offset of field: _GMountIface::unmount"]
        [::std::mem::offset_of!(_GMountIface, unmount) - 96usize];
    ["Offset of field: _GMountIface::unmount_finish"]
        [::std::mem::offset_of!(_GMountIface, unmount_finish) - 104usize];
    ["Offset of field: _GMountIface::eject"]
        [::std::mem::offset_of!(_GMountIface, eject) - 112usize];
    ["Offset of field: _GMountIface::eject_finish"]
        [::std::mem::offset_of!(_GMountIface, eject_finish) - 120usize];
    ["Offset of field: _GMountIface::remount"]
        [::std::mem::offset_of!(_GMountIface, remount) - 128usize];
    ["Offset of field: _GMountIface::remount_finish"]
        [::std::mem::offset_of!(_GMountIface, remount_finish) - 136usize];
    ["Offset of field: _GMountIface::guess_content_type"]
        [::std::mem::offset_of!(_GMountIface, guess_content_type) - 144usize];
    ["Offset of field: _GMountIface::guess_content_type_finish"]
        [::std::mem::offset_of!(_GMountIface, guess_content_type_finish) - 152usize];
    ["Offset of field: _GMountIface::guess_content_type_sync"]
        [::std::mem::offset_of!(_GMountIface, guess_content_type_sync) - 160usize];
    ["Offset of field: _GMountIface::pre_unmount"]
        [::std::mem::offset_of!(_GMountIface, pre_unmount) - 168usize];
    ["Offset of field: _GMountIface::unmount_with_operation"]
        [::std::mem::offset_of!(_GMountIface, unmount_with_operation) - 176usize];
    ["Offset of field: _GMountIface::unmount_with_operation_finish"]
        [::std::mem::offset_of!(_GMountIface, unmount_with_operation_finish) - 184usize];
    ["Offset of field: _GMountIface::eject_with_operation"]
        [::std::mem::offset_of!(_GMountIface, eject_with_operation) - 192usize];
    ["Offset of field: _GMountIface::eject_with_operation_finish"]
        [::std::mem::offset_of!(_GMountIface, eject_with_operation_finish) - 200usize];
    ["Offset of field: _GMountIface::get_default_location"]
        [::std::mem::offset_of!(_GMountIface, get_default_location) - 208usize];
    ["Offset of field: _GMountIface::get_sort_key"]
        [::std::mem::offset_of!(_GMountIface, get_sort_key) - 216usize];
    ["Offset of field: _GMountIface::get_symbolic_icon"]
        [::std::mem::offset_of!(_GMountIface, get_symbolic_icon) - 224usize];
};
unsafe extern "C" {
    pub fn g_mount_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_mount_get_name(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_mount_get_uuid(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
}
unsafe extern "C" {
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
}
unsafe extern "C" {
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_unmount(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_mount_unmount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_eject(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_mount_eject_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_remount(
        mount: *mut GMount,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_mount_remount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_guess_content_type(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_mount_guess_content_type_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_mount_guess_content_type_sync(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_shadow(mount: *mut GMount);
}
unsafe extern "C" {
    pub fn g_mount_unshadow(mount: *mut GMount);
}
unsafe extern "C" {
    pub fn g_mount_unmount_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_mount_unmount_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_eject_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_mount_eject_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const gchar;
}
pub type GMountOperationClass = _GMountOperationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationPrivate {
    _unused: [u8; 0],
}
pub type GMountOperationPrivate = _GMountOperationPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperation {
    pub parent_instance: GObject,
    pub priv_: *mut GMountOperationPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMountOperation"][::std::mem::size_of::<_GMountOperation>() - 32usize];
    ["Alignment of _GMountOperation"][::std::mem::align_of::<_GMountOperation>() - 8usize];
    ["Offset of field: _GMountOperation::parent_instance"]
        [::std::mem::offset_of!(_GMountOperation, parent_instance) - 0usize];
    ["Offset of field: _GMountOperation::priv_"]
        [::std::mem::offset_of!(_GMountOperation, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            default_user: *const ::std::os::raw::c_char,
            default_domain: *const ::std::os::raw::c_char,
            flags: GAskPasswordFlags,
        ),
    >,
    #[doc = " GMountOperationClass::ask_question:\n @op: a #GMountOperation\n @message: string containing a message to display to the user\n @choices: (array zero-terminated=1) (element-type utf8): an array of\n    strings for each possible choice\n\n Virtual implementation of #GMountOperation::ask-question."]
    pub ask_question: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            choices: *mut *const ::std::os::raw::c_char,
        ),
    >,
    pub reply: ::std::option::Option<
        unsafe extern "C" fn(op: *mut GMountOperation, result: GMountOperationResult),
    >,
    pub aborted: ::std::option::Option<unsafe extern "C" fn(op: *mut GMountOperation)>,
    #[doc = " GMountOperationClass::show_processes:\n @op: a #GMountOperation\n @message: string containing a message to display to the user\n @processes: (element-type GPid): an array of #GPid for processes blocking\n    the operation\n @choices: (array zero-terminated=1) (element-type utf8): an array of\n    strings for each possible choice\n\n Virtual implementation of #GMountOperation::show-processes.\n\n Since: 2.22"]
    pub show_processes: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            processes: *mut GArray,
            choices: *mut *const gchar,
        ),
    >,
    pub show_unmount_progress: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            time_left: gint64,
            bytes_left: gint64,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GMountOperationClass"][::std::mem::size_of::<_GMountOperationClass>() - 256usize];
    ["Alignment of _GMountOperationClass"]
        [::std::mem::align_of::<_GMountOperationClass>() - 8usize];
    ["Offset of field: _GMountOperationClass::parent_class"]
        [::std::mem::offset_of!(_GMountOperationClass, parent_class) - 0usize];
    ["Offset of field: _GMountOperationClass::ask_password"]
        [::std::mem::offset_of!(_GMountOperationClass, ask_password) - 136usize];
    ["Offset of field: _GMountOperationClass::ask_question"]
        [::std::mem::offset_of!(_GMountOperationClass, ask_question) - 144usize];
    ["Offset of field: _GMountOperationClass::reply"]
        [::std::mem::offset_of!(_GMountOperationClass, reply) - 152usize];
    ["Offset of field: _GMountOperationClass::aborted"]
        [::std::mem::offset_of!(_GMountOperationClass, aborted) - 160usize];
    ["Offset of field: _GMountOperationClass::show_processes"]
        [::std::mem::offset_of!(_GMountOperationClass, show_processes) - 168usize];
    ["Offset of field: _GMountOperationClass::show_unmount_progress"]
        [::std::mem::offset_of!(_GMountOperationClass, show_unmount_progress) - 176usize];
    ["Offset of field: _GMountOperationClass::_g_reserved1"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved1) - 184usize];
    ["Offset of field: _GMountOperationClass::_g_reserved2"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved2) - 192usize];
    ["Offset of field: _GMountOperationClass::_g_reserved3"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved3) - 200usize];
    ["Offset of field: _GMountOperationClass::_g_reserved4"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved4) - 208usize];
    ["Offset of field: _GMountOperationClass::_g_reserved5"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved5) - 216usize];
    ["Offset of field: _GMountOperationClass::_g_reserved6"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved6) - 224usize];
    ["Offset of field: _GMountOperationClass::_g_reserved7"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved7) - 232usize];
    ["Offset of field: _GMountOperationClass::_g_reserved8"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved8) - 240usize];
    ["Offset of field: _GMountOperationClass::_g_reserved9"]
        [::std::mem::offset_of!(_GMountOperationClass, _g_reserved9) - 248usize];
};
unsafe extern "C" {
    pub fn g_mount_operation_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_mount_operation_new() -> *mut GMountOperation;
}
unsafe extern "C" {
    pub fn g_mount_operation_get_username(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_username(
        op: *mut GMountOperation,
        username: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_mount_operation_get_password(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_password(
        op: *mut GMountOperation,
        password: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation, anonymous: gboolean);
}
unsafe extern "C" {
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_domain(
        op: *mut GMountOperation,
        domain: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation) -> GPasswordSave;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation, save: GPasswordSave);
}
unsafe extern "C" {
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation, choice: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn g_mount_operation_reply(op: *mut GMountOperation, result: GMountOperationResult);
}
unsafe extern "C" {
    pub fn g_mount_operation_get_is_tcrypt_hidden_volume(op: *mut GMountOperation) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_is_tcrypt_hidden_volume(
        op: *mut GMountOperation,
        hidden_volume: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_mount_operation_get_is_tcrypt_system_volume(op: *mut GMountOperation) -> gboolean;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_is_tcrypt_system_volume(
        op: *mut GMountOperation,
        system_volume: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_mount_operation_get_pim(op: *mut GMountOperation) -> guint;
}
unsafe extern "C" {
    pub fn g_mount_operation_set_pim(op: *mut GMountOperation, pim: guint);
}
pub type GNativeSocketAddressClass = _GNativeSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GNativeSocketAddressPrivate = _GNativeSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GNativeSocketAddressPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNativeSocketAddress"][::std::mem::size_of::<_GNativeSocketAddress>() - 32usize];
    ["Alignment of _GNativeSocketAddress"]
        [::std::mem::align_of::<_GNativeSocketAddress>() - 8usize];
    ["Offset of field: _GNativeSocketAddress::parent_instance"]
        [::std::mem::offset_of!(_GNativeSocketAddress, parent_instance) - 0usize];
    ["Offset of field: _GNativeSocketAddress::priv_"]
        [::std::mem::offset_of!(_GNativeSocketAddress, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNativeSocketAddressClass"]
        [::std::mem::size_of::<_GNativeSocketAddressClass>() - 160usize];
    ["Alignment of _GNativeSocketAddressClass"]
        [::std::mem::align_of::<_GNativeSocketAddressClass>() - 8usize];
    ["Offset of field: _GNativeSocketAddressClass::parent_class"]
        [::std::mem::offset_of!(_GNativeSocketAddressClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_native_socket_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_native_socket_address_new(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
pub type GVolumeMonitorClass = _GVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeMonitor {
    pub parent_instance: GObject,
    pub priv_: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVolumeMonitor"][::std::mem::size_of::<_GVolumeMonitor>() - 32usize];
    ["Alignment of _GVolumeMonitor"][::std::mem::align_of::<_GVolumeMonitor>() - 8usize];
    ["Offset of field: _GVolumeMonitor::parent_instance"]
        [::std::mem::offset_of!(_GVolumeMonitor, parent_instance) - 0usize];
    ["Offset of field: _GVolumeMonitor::priv_"]
        [::std::mem::offset_of!(_GVolumeMonitor, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeMonitorClass {
    pub parent_class: GObjectClass,
    pub volume_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub mount_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_pre_unmount: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub drive_connected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_disconnected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub is_supported: ::std::option::Option<unsafe extern "C" fn() -> gboolean>,
    pub get_connected_drives: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volumes: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_mounts: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volume_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GVolume,
    >,
    pub get_mount_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GMount,
    >,
    pub adopt_orphan_mount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            volume_monitor: *mut GVolumeMonitor,
        ) -> *mut GVolume,
    >,
    pub drive_eject_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_stop_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVolumeMonitorClass"][::std::mem::size_of::<_GVolumeMonitorClass>() - 336usize];
    ["Alignment of _GVolumeMonitorClass"][::std::mem::align_of::<_GVolumeMonitorClass>() - 8usize];
    ["Offset of field: _GVolumeMonitorClass::parent_class"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, parent_class) - 0usize];
    ["Offset of field: _GVolumeMonitorClass::volume_added"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, volume_added) - 136usize];
    ["Offset of field: _GVolumeMonitorClass::volume_removed"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, volume_removed) - 144usize];
    ["Offset of field: _GVolumeMonitorClass::volume_changed"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, volume_changed) - 152usize];
    ["Offset of field: _GVolumeMonitorClass::mount_added"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, mount_added) - 160usize];
    ["Offset of field: _GVolumeMonitorClass::mount_removed"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, mount_removed) - 168usize];
    ["Offset of field: _GVolumeMonitorClass::mount_pre_unmount"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, mount_pre_unmount) - 176usize];
    ["Offset of field: _GVolumeMonitorClass::mount_changed"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, mount_changed) - 184usize];
    ["Offset of field: _GVolumeMonitorClass::drive_connected"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, drive_connected) - 192usize];
    ["Offset of field: _GVolumeMonitorClass::drive_disconnected"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, drive_disconnected) - 200usize];
    ["Offset of field: _GVolumeMonitorClass::drive_changed"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, drive_changed) - 208usize];
    ["Offset of field: _GVolumeMonitorClass::is_supported"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, is_supported) - 216usize];
    ["Offset of field: _GVolumeMonitorClass::get_connected_drives"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, get_connected_drives) - 224usize];
    ["Offset of field: _GVolumeMonitorClass::get_volumes"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, get_volumes) - 232usize];
    ["Offset of field: _GVolumeMonitorClass::get_mounts"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, get_mounts) - 240usize];
    ["Offset of field: _GVolumeMonitorClass::get_volume_for_uuid"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, get_volume_for_uuid) - 248usize];
    ["Offset of field: _GVolumeMonitorClass::get_mount_for_uuid"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, get_mount_for_uuid) - 256usize];
    ["Offset of field: _GVolumeMonitorClass::adopt_orphan_mount"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, adopt_orphan_mount) - 264usize];
    ["Offset of field: _GVolumeMonitorClass::drive_eject_button"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, drive_eject_button) - 272usize];
    ["Offset of field: _GVolumeMonitorClass::drive_stop_button"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, drive_stop_button) - 280usize];
    ["Offset of field: _GVolumeMonitorClass::_g_reserved1"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, _g_reserved1) - 288usize];
    ["Offset of field: _GVolumeMonitorClass::_g_reserved2"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, _g_reserved2) - 296usize];
    ["Offset of field: _GVolumeMonitorClass::_g_reserved3"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, _g_reserved3) - 304usize];
    ["Offset of field: _GVolumeMonitorClass::_g_reserved4"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, _g_reserved4) - 312usize];
    ["Offset of field: _GVolumeMonitorClass::_g_reserved5"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, _g_reserved5) - 320usize];
    ["Offset of field: _GVolumeMonitorClass::_g_reserved6"]
        [::std::mem::offset_of!(_GVolumeMonitorClass, _g_reserved6) - 328usize];
};
unsafe extern "C" {
    pub fn g_volume_monitor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
}
unsafe extern "C" {
    pub fn g_volume_monitor_get_connected_drives(volume_monitor: *mut GVolumeMonitor)
        -> *mut GList;
}
unsafe extern "C" {
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_volume_monitor_get_volume_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GVolume;
}
unsafe extern "C" {
    pub fn g_volume_monitor_get_mount_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GMount;
}
unsafe extern "C" {
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount) -> *mut GVolume;
}
pub type GNativeVolumeMonitor = _GNativeVolumeMonitor;
pub type GNativeVolumeMonitorClass = _GNativeVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNativeVolumeMonitor"][::std::mem::size_of::<_GNativeVolumeMonitor>() - 32usize];
    ["Alignment of _GNativeVolumeMonitor"]
        [::std::mem::align_of::<_GNativeVolumeMonitor>() - 8usize];
    ["Offset of field: _GNativeVolumeMonitor::parent_instance"]
        [::std::mem::offset_of!(_GNativeVolumeMonitor, parent_instance) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: ::std::option::Option<
        unsafe extern "C" fn(
            mount_path: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
        ) -> *mut GMount,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNativeVolumeMonitorClass"]
        [::std::mem::size_of::<_GNativeVolumeMonitorClass>() - 344usize];
    ["Alignment of _GNativeVolumeMonitorClass"]
        [::std::mem::align_of::<_GNativeVolumeMonitorClass>() - 8usize];
    ["Offset of field: _GNativeVolumeMonitorClass::parent_class"]
        [::std::mem::offset_of!(_GNativeVolumeMonitorClass, parent_class) - 0usize];
    ["Offset of field: _GNativeVolumeMonitorClass::get_mount_for_mount_path"]
        [::std::mem::offset_of!(_GNativeVolumeMonitorClass, get_mount_for_mount_path) - 336usize];
};
unsafe extern "C" {
    pub fn g_native_volume_monitor_get_type() -> GType;
}
pub type GNetworkAddressClass = _GNetworkAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressPrivate {
    _unused: [u8; 0],
}
pub type GNetworkAddressPrivate = _GNetworkAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkAddressPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNetworkAddress"][::std::mem::size_of::<_GNetworkAddress>() - 32usize];
    ["Alignment of _GNetworkAddress"][::std::mem::align_of::<_GNetworkAddress>() - 8usize];
    ["Offset of field: _GNetworkAddress::parent_instance"]
        [::std::mem::offset_of!(_GNetworkAddress, parent_instance) - 0usize];
    ["Offset of field: _GNetworkAddress::priv_"]
        [::std::mem::offset_of!(_GNetworkAddress, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNetworkAddressClass"][::std::mem::size_of::<_GNetworkAddressClass>() - 136usize];
    ["Alignment of _GNetworkAddressClass"]
        [::std::mem::align_of::<_GNetworkAddressClass>() - 8usize];
    ["Offset of field: _GNetworkAddressClass::parent_class"]
        [::std::mem::offset_of!(_GNetworkAddressClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_network_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_network_address_new(hostname: *const gchar, port: guint16) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_network_address_new_loopback(port: guint16) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_network_address_parse(
        host_and_port: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_network_address_parse_uri(
        uri: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> guint16;
}
unsafe extern "C" {
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress) -> *const gchar;
}
pub type GNetworkMonitorInterface = _GNetworkMonitorInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitorInterface {
    pub g_iface: GTypeInterface,
    pub network_changed: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GNetworkMonitor, network_available: gboolean),
    >,
    pub can_reach: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_reach_async: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub can_reach_finish: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNetworkMonitorInterface"]
        [::std::mem::size_of::<_GNetworkMonitorInterface>() - 48usize];
    ["Alignment of _GNetworkMonitorInterface"]
        [::std::mem::align_of::<_GNetworkMonitorInterface>() - 8usize];
    ["Offset of field: _GNetworkMonitorInterface::g_iface"]
        [::std::mem::offset_of!(_GNetworkMonitorInterface, g_iface) - 0usize];
    ["Offset of field: _GNetworkMonitorInterface::network_changed"]
        [::std::mem::offset_of!(_GNetworkMonitorInterface, network_changed) - 16usize];
    ["Offset of field: _GNetworkMonitorInterface::can_reach"]
        [::std::mem::offset_of!(_GNetworkMonitorInterface, can_reach) - 24usize];
    ["Offset of field: _GNetworkMonitorInterface::can_reach_async"]
        [::std::mem::offset_of!(_GNetworkMonitorInterface, can_reach_async) - 32usize];
    ["Offset of field: _GNetworkMonitorInterface::can_reach_finish"]
        [::std::mem::offset_of!(_GNetworkMonitorInterface, can_reach_finish) - 40usize];
};
unsafe extern "C" {
    pub fn g_network_monitor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
}
unsafe extern "C" {
    pub fn g_network_monitor_get_network_available(monitor: *mut GNetworkMonitor) -> gboolean;
}
unsafe extern "C" {
    pub fn g_network_monitor_get_network_metered(monitor: *mut GNetworkMonitor) -> gboolean;
}
unsafe extern "C" {
    pub fn g_network_monitor_get_connectivity(
        monitor: *mut GNetworkMonitor,
    ) -> GNetworkConnectivity;
}
unsafe extern "C" {
    pub fn g_network_monitor_can_reach(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_network_monitor_can_reach_async(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_network_monitor_can_reach_finish(
        monitor: *mut GNetworkMonitor,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GNetworkServiceClass = _GNetworkServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServicePrivate {
    _unused: [u8; 0],
}
pub type GNetworkServicePrivate = _GNetworkServicePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkService {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkServicePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNetworkService"][::std::mem::size_of::<_GNetworkService>() - 32usize];
    ["Alignment of _GNetworkService"][::std::mem::align_of::<_GNetworkService>() - 8usize];
    ["Offset of field: _GNetworkService::parent_instance"]
        [::std::mem::offset_of!(_GNetworkService, parent_instance) - 0usize];
    ["Offset of field: _GNetworkService::priv_"]
        [::std::mem::offset_of!(_GNetworkService, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServiceClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GNetworkServiceClass"][::std::mem::size_of::<_GNetworkServiceClass>() - 136usize];
    ["Alignment of _GNetworkServiceClass"]
        [::std::mem::align_of::<_GNetworkServiceClass>() - 8usize];
    ["Offset of field: _GNetworkServiceClass::parent_class"]
        [::std::mem::offset_of!(_GNetworkServiceClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_network_service_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_network_service_new(
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
    ) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_network_service_get_service(srv: *mut GNetworkService) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_network_service_get_domain(srv: *mut GNetworkService) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService, scheme: *const gchar);
}
unsafe extern "C" {
    pub fn g_notification_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_notification_new(title: *const gchar) -> *mut GNotification;
}
unsafe extern "C" {
    pub fn g_notification_set_title(notification: *mut GNotification, title: *const gchar);
}
unsafe extern "C" {
    pub fn g_notification_set_body(notification: *mut GNotification, body: *const gchar);
}
unsafe extern "C" {
    pub fn g_notification_set_icon(notification: *mut GNotification, icon: *mut GIcon);
}
unsafe extern "C" {
    pub fn g_notification_set_urgent(notification: *mut GNotification, urgent: gboolean);
}
unsafe extern "C" {
    pub fn g_notification_set_priority(
        notification: *mut GNotification,
        priority: GNotificationPriority,
    );
}
unsafe extern "C" {
    pub fn g_notification_set_category(notification: *mut GNotification, category: *const gchar);
}
unsafe extern "C" {
    pub fn g_notification_add_button(
        notification: *mut GNotification,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_notification_add_button_with_target(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_notification_add_button_with_target_value(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_notification_set_default_action(
        notification: *mut GNotification,
        detailed_action: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_notification_set_default_action_and_target(
        notification: *mut GNotification,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
unsafe extern "C" {
    pub fn g_notification_set_default_action_and_target_value(
        notification: *mut GNotification,
        action: *const gchar,
        target: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionPrivate {
    _unused: [u8; 0],
}
pub type GPermissionPrivate = _GPermissionPrivate;
pub type GPermissionClass = _GPermissionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermission {
    pub parent_instance: GObject,
    pub priv_: *mut GPermissionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPermission"][::std::mem::size_of::<_GPermission>() - 32usize];
    ["Alignment of _GPermission"][::std::mem::align_of::<_GPermission>() - 8usize];
    ["Offset of field: _GPermission::parent_instance"]
        [::std::mem::offset_of!(_GPermission, parent_instance) - 0usize];
    ["Offset of field: _GPermission::priv_"][::std::mem::offset_of!(_GPermission, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionClass {
    pub parent_class: GObjectClass,
    pub acquire: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub acquire_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub acquire_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub release_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub reserved: [gpointer; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPermissionClass"][::std::mem::size_of::<_GPermissionClass>() - 312usize];
    ["Alignment of _GPermissionClass"][::std::mem::align_of::<_GPermissionClass>() - 8usize];
    ["Offset of field: _GPermissionClass::parent_class"]
        [::std::mem::offset_of!(_GPermissionClass, parent_class) - 0usize];
    ["Offset of field: _GPermissionClass::acquire"]
        [::std::mem::offset_of!(_GPermissionClass, acquire) - 136usize];
    ["Offset of field: _GPermissionClass::acquire_async"]
        [::std::mem::offset_of!(_GPermissionClass, acquire_async) - 144usize];
    ["Offset of field: _GPermissionClass::acquire_finish"]
        [::std::mem::offset_of!(_GPermissionClass, acquire_finish) - 152usize];
    ["Offset of field: _GPermissionClass::release"]
        [::std::mem::offset_of!(_GPermissionClass, release) - 160usize];
    ["Offset of field: _GPermissionClass::release_async"]
        [::std::mem::offset_of!(_GPermissionClass, release_async) - 168usize];
    ["Offset of field: _GPermissionClass::release_finish"]
        [::std::mem::offset_of!(_GPermissionClass, release_finish) - 176usize];
    ["Offset of field: _GPermissionClass::reserved"]
        [::std::mem::offset_of!(_GPermissionClass, reserved) - 184usize];
};
unsafe extern "C" {
    pub fn g_permission_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_permission_acquire(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_acquire_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_permission_acquire_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_release(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_release_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_permission_release_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_get_can_acquire(permission: *mut GPermission) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_get_can_release(permission: *mut GPermission) -> gboolean;
}
unsafe extern "C" {
    pub fn g_permission_impl_update(
        permission: *mut GPermission,
        allowed: gboolean,
        can_acquire: gboolean,
        can_release: gboolean,
    );
}
#[doc = " GPollableInputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableInputStream instance is actually pollable\n @is_readable: Checks if the stream is readable\n @create_source: Creates a #GSource to poll the stream\n @read_nonblocking: Does a non-blocking read or returns\n   %G_IO_ERROR_WOULD_BLOCK\n\n The interface for pollable input streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @read_nonblocking calls\n g_pollable_input_stream_is_readable(), and then calls\n g_input_stream_read() if it returns %TRUE. This means you only need\n to override it if it is possible that your @is_readable\n implementation may return %TRUE when the stream is not actually\n readable.\n\n Since: 2.28"]
pub type GPollableInputStreamInterface = _GPollableInputStreamInterface;
#[doc = " GPollableInputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableInputStream instance is actually pollable\n @is_readable: Checks if the stream is readable\n @create_source: Creates a #GSource to poll the stream\n @read_nonblocking: Does a non-blocking read or returns\n   %G_IO_ERROR_WOULD_BLOCK\n\n The interface for pollable input streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @read_nonblocking calls\n g_pollable_input_stream_is_readable(), and then calls\n g_input_stream_read() if it returns %TRUE. This means you only need\n to override it if it is possible that your @is_readable\n implementation may return %TRUE when the stream is not actually\n readable.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub is_readable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub read_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPollableInputStreamInterface"]
        [::std::mem::size_of::<_GPollableInputStreamInterface>() - 48usize];
    ["Alignment of _GPollableInputStreamInterface"]
        [::std::mem::align_of::<_GPollableInputStreamInterface>() - 8usize];
    ["Offset of field: _GPollableInputStreamInterface::g_iface"]
        [::std::mem::offset_of!(_GPollableInputStreamInterface, g_iface) - 0usize];
    ["Offset of field: _GPollableInputStreamInterface::can_poll"]
        [::std::mem::offset_of!(_GPollableInputStreamInterface, can_poll) - 16usize];
    ["Offset of field: _GPollableInputStreamInterface::is_readable"]
        [::std::mem::offset_of!(_GPollableInputStreamInterface, is_readable) - 24usize];
    ["Offset of field: _GPollableInputStreamInterface::create_source"]
        [::std::mem::offset_of!(_GPollableInputStreamInterface, create_source) - 32usize];
    ["Offset of field: _GPollableInputStreamInterface::read_nonblocking"]
        [::std::mem::offset_of!(_GPollableInputStreamInterface, read_nonblocking) - 40usize];
};
unsafe extern "C" {
    pub fn g_pollable_input_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pollable_input_stream_is_readable(stream: *mut GPollableInputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pollable_input_stream_create_source(
        stream: *mut GPollableInputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_pollable_input_stream_read_nonblocking(
        stream: *mut GPollableInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
#[doc = " GPollableOutputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableOutputStream instance is actually pollable\n @is_writable: Checks if the stream is writable\n @create_source: Creates a #GSource to poll the stream\n @write_nonblocking: Does a non-blocking write or returns\n   %G_IO_ERROR_WOULD_BLOCK\n @writev_nonblocking: Does a vectored non-blocking write, or returns\n   %G_POLLABLE_RETURN_WOULD_BLOCK\n\n The interface for pollable output streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @write_nonblocking calls\n g_pollable_output_stream_is_writable(), and then calls\n g_output_stream_write() if it returns %TRUE. This means you only\n need to override it if it is possible that your @is_writable\n implementation may return %TRUE when the stream is not actually\n writable.\n\n The default implementation of @writev_nonblocking calls\n g_pollable_output_stream_write_nonblocking() for each vector, and converts\n its return value and error (if set) to a #GPollableReturn. You should\n override this where possible to avoid having to allocate a #GError to return\n %G_IO_ERROR_WOULD_BLOCK.\n\n Since: 2.28"]
pub type GPollableOutputStreamInterface = _GPollableOutputStreamInterface;
#[doc = " GPollableOutputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableOutputStream instance is actually pollable\n @is_writable: Checks if the stream is writable\n @create_source: Creates a #GSource to poll the stream\n @write_nonblocking: Does a non-blocking write or returns\n   %G_IO_ERROR_WOULD_BLOCK\n @writev_nonblocking: Does a vectored non-blocking write, or returns\n   %G_POLLABLE_RETURN_WOULD_BLOCK\n\n The interface for pollable output streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @write_nonblocking calls\n g_pollable_output_stream_is_writable(), and then calls\n g_output_stream_write() if it returns %TRUE. This means you only\n need to override it if it is possible that your @is_writable\n implementation may return %TRUE when the stream is not actually\n writable.\n\n The default implementation of @writev_nonblocking calls\n g_pollable_output_stream_write_nonblocking() for each vector, and converts\n its return value and error (if set) to a #GPollableReturn. You should\n override this where possible to avoid having to allocate a #GError to return\n %G_IO_ERROR_WOULD_BLOCK.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub is_writable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub write_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub writev_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GPollableReturn,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPollableOutputStreamInterface"]
        [::std::mem::size_of::<_GPollableOutputStreamInterface>() - 56usize];
    ["Alignment of _GPollableOutputStreamInterface"]
        [::std::mem::align_of::<_GPollableOutputStreamInterface>() - 8usize];
    ["Offset of field: _GPollableOutputStreamInterface::g_iface"]
        [::std::mem::offset_of!(_GPollableOutputStreamInterface, g_iface) - 0usize];
    ["Offset of field: _GPollableOutputStreamInterface::can_poll"]
        [::std::mem::offset_of!(_GPollableOutputStreamInterface, can_poll) - 16usize];
    ["Offset of field: _GPollableOutputStreamInterface::is_writable"]
        [::std::mem::offset_of!(_GPollableOutputStreamInterface, is_writable) - 24usize];
    ["Offset of field: _GPollableOutputStreamInterface::create_source"]
        [::std::mem::offset_of!(_GPollableOutputStreamInterface, create_source) - 32usize];
    ["Offset of field: _GPollableOutputStreamInterface::write_nonblocking"]
        [::std::mem::offset_of!(_GPollableOutputStreamInterface, write_nonblocking) - 40usize];
    ["Offset of field: _GPollableOutputStreamInterface::writev_nonblocking"]
        [::std::mem::offset_of!(_GPollableOutputStreamInterface, writev_nonblocking) - 48usize];
};
unsafe extern "C" {
    pub fn g_pollable_output_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_pollable_output_stream_can_poll(stream: *mut GPollableOutputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pollable_output_stream_is_writable(stream: *mut GPollableOutputStream) -> gboolean;
}
unsafe extern "C" {
    pub fn g_pollable_output_stream_create_source(
        stream: *mut GPollableOutputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_pollable_output_stream_write_nonblocking(
        stream: *mut GPollableOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_pollable_output_stream_writev_nonblocking(
        stream: *mut GPollableOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GPollableReturn;
}
unsafe extern "C" {
    pub fn g_pollable_source_new(pollable_stream: *mut GObject) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_pollable_source_new_full(
        pollable_stream: gpointer,
        child_source: *mut GSource,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_pollable_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_pollable_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_pollable_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_power_profile_monitor_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPowerProfileMonitor {
    _unused: [u8; 0],
}
pub type GPowerProfileMonitor = _GPowerProfileMonitor;
pub type GPowerProfileMonitorInterface = _GPowerProfileMonitorInterface;
pub type GPowerProfileMonitor_autoptr = *mut GPowerProfileMonitor;
pub type GPowerProfileMonitor_listautoptr = *mut GList;
pub type GPowerProfileMonitor_slistautoptr = *mut GSList;
pub type GPowerProfileMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPowerProfileMonitorInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GPowerProfileMonitorInterface"]
        [::std::mem::size_of::<_GPowerProfileMonitorInterface>() - 16usize];
    ["Alignment of _GPowerProfileMonitorInterface"]
        [::std::mem::align_of::<_GPowerProfileMonitorInterface>() - 8usize];
    ["Offset of field: _GPowerProfileMonitorInterface::g_iface"]
        [::std::mem::offset_of!(_GPowerProfileMonitorInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn g_power_profile_monitor_dup_default() -> *mut GPowerProfileMonitor;
}
unsafe extern "C" {
    pub fn g_power_profile_monitor_get_power_saver_enabled(
        monitor: *mut GPowerProfileMonitor,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_property_action_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_property_action_new(
        name: *const gchar,
        object: gpointer,
        property_name: *const gchar,
    ) -> *mut GPropertyAction;
}
#[doc = " GProxyInterface:\n @g_iface: The parent interface.\n @connect: Connect to proxy server and wrap (if required) the #connection\n           to handle payload.\n @connect_async: Same as connect() but asynchronous.\n @connect_finish: Returns the result of connect_async()\n @supports_hostname: Returns whether the proxy supports hostname lookups.\n\n Provides an interface for handling proxy connection and payload.\n\n Since: 2.26"]
pub type GProxyInterface = _GProxyInterface;
#[doc = " GProxyInterface:\n @g_iface: The parent interface.\n @connect: Connect to proxy server and wrap (if required) the #connection\n           to handle payload.\n @connect_async: Same as connect() but asynchronous.\n @connect_finish: Returns the result of connect_async()\n @supports_hostname: Returns whether the proxy supports hostname lookups.\n\n Provides an interface for handling proxy connection and payload.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyInterface {
    pub g_iface: GTypeInterface,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub connect_async: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub connect_finish: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub supports_hostname:
        ::std::option::Option<unsafe extern "C" fn(proxy: *mut GProxy) -> gboolean>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GProxyInterface"][::std::mem::size_of::<_GProxyInterface>() - 48usize];
    ["Alignment of _GProxyInterface"][::std::mem::align_of::<_GProxyInterface>() - 8usize];
    ["Offset of field: _GProxyInterface::g_iface"]
        [::std::mem::offset_of!(_GProxyInterface, g_iface) - 0usize];
    ["Offset of field: _GProxyInterface::connect"]
        [::std::mem::offset_of!(_GProxyInterface, connect) - 16usize];
    ["Offset of field: _GProxyInterface::connect_async"]
        [::std::mem::offset_of!(_GProxyInterface, connect_async) - 24usize];
    ["Offset of field: _GProxyInterface::connect_finish"]
        [::std::mem::offset_of!(_GProxyInterface, connect_finish) - 32usize];
    ["Offset of field: _GProxyInterface::supports_hostname"]
        [::std::mem::offset_of!(_GProxyInterface, supports_hostname) - 40usize];
};
unsafe extern "C" {
    pub fn g_proxy_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_proxy_get_default_for_protocol(protocol: *const gchar) -> *mut GProxy;
}
unsafe extern "C" {
    pub fn g_proxy_connect(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_proxy_connect_async(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_proxy_connect_finish(
        proxy: *mut GProxy,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;
}
pub type GProxyAddressClass = _GProxyAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressPrivate = _GProxyAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    pub priv_: *mut GProxyAddressPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GProxyAddress"][::std::mem::size_of::<_GProxyAddress>() - 40usize];
    ["Alignment of _GProxyAddress"][::std::mem::align_of::<_GProxyAddress>() - 8usize];
    ["Offset of field: _GProxyAddress::parent_instance"]
        [::std::mem::offset_of!(_GProxyAddress, parent_instance) - 0usize];
    ["Offset of field: _GProxyAddress::priv_"]
        [::std::mem::offset_of!(_GProxyAddress, priv_) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GProxyAddressClass"][::std::mem::size_of::<_GProxyAddressClass>() - 160usize];
    ["Alignment of _GProxyAddressClass"][::std::mem::align_of::<_GProxyAddressClass>() - 8usize];
    ["Offset of field: _GProxyAddressClass::parent_class"]
        [::std::mem::offset_of!(_GProxyAddressClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_proxy_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_proxy_address_new(
        inetaddr: *mut GInetAddress,
        port: guint16,
        protocol: *const gchar,
        dest_hostname: *const gchar,
        dest_port: guint16,
        username: *const gchar,
        password: *const gchar,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress) -> guint16;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const gchar;
}
#[doc = " GSocketAddressEnumeratorClass:\n @next: Virtual method for g_socket_address_enumerator_next().\n @next_async: Virtual method for g_socket_address_enumerator_next_async().\n @next_finish: Virtual method for g_socket_address_enumerator_next_finish().\n\n Class structure for #GSocketAddressEnumerator."]
pub type GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressEnumerator {
    pub parent_instance: GObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketAddressEnumerator"]
        [::std::mem::size_of::<_GSocketAddressEnumerator>() - 24usize];
    ["Alignment of _GSocketAddressEnumerator"]
        [::std::mem::align_of::<_GSocketAddressEnumerator>() - 8usize];
    ["Offset of field: _GSocketAddressEnumerator::parent_instance"]
        [::std::mem::offset_of!(_GSocketAddressEnumerator, parent_instance) - 0usize];
};
#[doc = " GSocketAddressEnumeratorClass:\n @next: Virtual method for g_socket_address_enumerator_next().\n @next_async: Virtual method for g_socket_address_enumerator_next_async().\n @next_finish: Virtual method for g_socket_address_enumerator_next_finish().\n\n Class structure for #GSocketAddressEnumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
    pub next_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketAddressEnumeratorClass"]
        [::std::mem::size_of::<_GSocketAddressEnumeratorClass>() - 160usize];
    ["Alignment of _GSocketAddressEnumeratorClass"]
        [::std::mem::align_of::<_GSocketAddressEnumeratorClass>() - 8usize];
    ["Offset of field: _GSocketAddressEnumeratorClass::parent_class"]
        [::std::mem::offset_of!(_GSocketAddressEnumeratorClass, parent_class) - 0usize];
    ["Offset of field: _GSocketAddressEnumeratorClass::next"]
        [::std::mem::offset_of!(_GSocketAddressEnumeratorClass, next) - 136usize];
    ["Offset of field: _GSocketAddressEnumeratorClass::next_async"]
        [::std::mem::offset_of!(_GSocketAddressEnumeratorClass, next_async) - 144usize];
    ["Offset of field: _GSocketAddressEnumeratorClass::next_finish"]
        [::std::mem::offset_of!(_GSocketAddressEnumeratorClass, next_finish) - 152usize];
};
unsafe extern "C" {
    pub fn g_socket_address_enumerator_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_address_enumerator_next(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_address_enumerator_next_async(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_address_enumerator_next_finish(
        enumerator: *mut GSocketAddressEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
#[doc = " GProxyAddressEnumeratorClass:\n\n Class structure for #GProxyAddressEnumerator."]
pub type GProxyAddressEnumeratorClass = _GProxyAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub priv_: *mut GProxyAddressEnumeratorPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GProxyAddressEnumerator"]
        [::std::mem::size_of::<_GProxyAddressEnumerator>() - 32usize];
    ["Alignment of _GProxyAddressEnumerator"]
        [::std::mem::align_of::<_GProxyAddressEnumerator>() - 8usize];
    ["Offset of field: _GProxyAddressEnumerator::parent_instance"]
        [::std::mem::offset_of!(_GProxyAddressEnumerator, parent_instance) - 0usize];
    ["Offset of field: _GProxyAddressEnumerator::priv_"]
        [::std::mem::offset_of!(_GProxyAddressEnumerator, priv_) - 24usize];
};
#[doc = " GProxyAddressEnumeratorClass:\n\n Class structure for #GProxyAddressEnumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GProxyAddressEnumeratorClass"]
        [::std::mem::size_of::<_GProxyAddressEnumeratorClass>() - 216usize];
    ["Alignment of _GProxyAddressEnumeratorClass"]
        [::std::mem::align_of::<_GProxyAddressEnumeratorClass>() - 8usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::parent_class"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, parent_class) - 0usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved1"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved1) - 160usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved2"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved2) - 168usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved3"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved3) - 176usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved4"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved4) - 184usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved5"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved5) - 192usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved6"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved6) - 200usize];
    ["Offset of field: _GProxyAddressEnumeratorClass::_g_reserved7"]
        [::std::mem::offset_of!(_GProxyAddressEnumeratorClass, _g_reserved7) - 208usize];
};
unsafe extern "C" {
    pub fn g_proxy_address_enumerator_get_type() -> GType;
}
pub type GProxyResolverInterface = _GProxyResolverInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolverInterface {
    pub g_iface: GTypeInterface,
    pub is_supported:
        ::std::option::Option<unsafe extern "C" fn(resolver: *mut GProxyResolver) -> gboolean>,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub lookup_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GProxyResolverInterface"]
        [::std::mem::size_of::<_GProxyResolverInterface>() - 48usize];
    ["Alignment of _GProxyResolverInterface"]
        [::std::mem::align_of::<_GProxyResolverInterface>() - 8usize];
    ["Offset of field: _GProxyResolverInterface::g_iface"]
        [::std::mem::offset_of!(_GProxyResolverInterface, g_iface) - 0usize];
    ["Offset of field: _GProxyResolverInterface::is_supported"]
        [::std::mem::offset_of!(_GProxyResolverInterface, is_supported) - 16usize];
    ["Offset of field: _GProxyResolverInterface::lookup"]
        [::std::mem::offset_of!(_GProxyResolverInterface, lookup) - 24usize];
    ["Offset of field: _GProxyResolverInterface::lookup_async"]
        [::std::mem::offset_of!(_GProxyResolverInterface, lookup_async) - 32usize];
    ["Offset of field: _GProxyResolverInterface::lookup_finish"]
        [::std::mem::offset_of!(_GProxyResolverInterface, lookup_finish) - 40usize];
};
unsafe extern "C" {
    pub fn g_proxy_resolver_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
}
unsafe extern "C" {
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver) -> gboolean;
}
unsafe extern "C" {
    pub fn g_proxy_resolver_lookup(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_proxy_resolver_lookup_async(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_proxy_resolver_lookup_finish(
        resolver: *mut GProxyResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
pub type GRemoteActionGroupInterface = _GRemoteActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub activate_action_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
    pub change_action_state_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GRemoteActionGroupInterface"]
        [::std::mem::size_of::<_GRemoteActionGroupInterface>() - 32usize];
    ["Alignment of _GRemoteActionGroupInterface"]
        [::std::mem::align_of::<_GRemoteActionGroupInterface>() - 8usize];
    ["Offset of field: _GRemoteActionGroupInterface::g_iface"]
        [::std::mem::offset_of!(_GRemoteActionGroupInterface, g_iface) - 0usize];
    ["Offset of field: _GRemoteActionGroupInterface::activate_action_full"]
        [::std::mem::offset_of!(_GRemoteActionGroupInterface, activate_action_full) - 16usize];
    ["Offset of field: _GRemoteActionGroupInterface::change_action_state_full"]
        [::std::mem::offset_of!(_GRemoteActionGroupInterface, change_action_state_full) - 24usize];
};
unsafe extern "C" {
    pub fn g_remote_action_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_remote_action_group_activate_action_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
unsafe extern "C" {
    pub fn g_remote_action_group_change_action_state_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverPrivate {
    _unused: [u8; 0],
}
pub type GResolverPrivate = _GResolverPrivate;
pub type GResolverClass = _GResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GResolverPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GResolver"][::std::mem::size_of::<_GResolver>() - 32usize];
    ["Alignment of _GResolver"][::std::mem::align_of::<_GResolver>() - 8usize];
    ["Offset of field: _GResolver::parent_instance"]
        [::std::mem::offset_of!(_GResolver, parent_instance) - 0usize];
    ["Offset of field: _GResolver::priv_"][::std::mem::offset_of!(_GResolver, priv_) - 24usize];
};
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: GResolverNameLookupFlags =
    0;
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY:
    GResolverNameLookupFlags = 1;
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY:
    GResolverNameLookupFlags = 2;
#[doc = " GResolverNameLookupFlags:\n @G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: default behavior (same as g_resolver_lookup_by_name())\n @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY: only resolve ipv4 addresses\n @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY: only resolve ipv6 addresses\n\n Flags to modify lookup behavior.\n\n Since: 2.60"]
pub type GResolverNameLookupFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverClass {
    pub parent_class: GObjectClass,
    pub reload: ::std::option::Option<unsafe extern "C" fn(resolver: *mut GResolver)>,
    pub lookup_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_address: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_by_address_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_address_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_service: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_service_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_service_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_records_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags_async:\n @resolver: a #GResolver\n @hostname: the hostname to resolve\n @flags: extra #GResolverNameLookupFlags to modify the lookup\n @cancellable: (nullable): a #GCancellable\n @callback: (scope async): a #GAsyncReadyCallback to call when completed\n @user_data: data to pass to @callback\n\n Asynchronous version of GResolverClass::lookup_by_name_with_flags\n\n GResolverClass::lookup_by_name_with_flags_finish will be called to get\n the result.\n\n Since: 2.60"]
    pub lookup_by_name_with_flags_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            flags: GResolverNameLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags_finish:\n @resolver: a #GResolver\n @result: a #GAsyncResult\n @error: (nullable): a pointer to a %NULL #GError\n\n Gets the result from GResolverClass::lookup_by_name_with_flags_async\n\n Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.\n Since: 2.60"]
    pub lookup_by_name_with_flags_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags:\n @resolver: a #GResolver\n @hostname: the hostname to resolve\n @flags: extra #GResolverNameLookupFlags to modify the lookup\n @cancellable: (nullable): a #GCancellable\n @error: (nullable): a pointer to a %NULL #GError\n\n This is identical to GResolverClass::lookup_by_name except it takes\n @flags which modifies the behavior of the lookup. See #GResolverNameLookupFlags\n for more details.\n\n Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.\n Since: 2.60"]
    pub lookup_by_name_with_flags: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            flags: GResolverNameLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GResolverClass"][::std::mem::size_of::<_GResolverClass>() - 264usize];
    ["Alignment of _GResolverClass"][::std::mem::align_of::<_GResolverClass>() - 8usize];
    ["Offset of field: _GResolverClass::parent_class"]
        [::std::mem::offset_of!(_GResolverClass, parent_class) - 0usize];
    ["Offset of field: _GResolverClass::reload"]
        [::std::mem::offset_of!(_GResolverClass, reload) - 136usize];
    ["Offset of field: _GResolverClass::lookup_by_name"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_name) - 144usize];
    ["Offset of field: _GResolverClass::lookup_by_name_async"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_name_async) - 152usize];
    ["Offset of field: _GResolverClass::lookup_by_name_finish"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_name_finish) - 160usize];
    ["Offset of field: _GResolverClass::lookup_by_address"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_address) - 168usize];
    ["Offset of field: _GResolverClass::lookup_by_address_async"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_address_async) - 176usize];
    ["Offset of field: _GResolverClass::lookup_by_address_finish"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_address_finish) - 184usize];
    ["Offset of field: _GResolverClass::lookup_service"]
        [::std::mem::offset_of!(_GResolverClass, lookup_service) - 192usize];
    ["Offset of field: _GResolverClass::lookup_service_async"]
        [::std::mem::offset_of!(_GResolverClass, lookup_service_async) - 200usize];
    ["Offset of field: _GResolverClass::lookup_service_finish"]
        [::std::mem::offset_of!(_GResolverClass, lookup_service_finish) - 208usize];
    ["Offset of field: _GResolverClass::lookup_records"]
        [::std::mem::offset_of!(_GResolverClass, lookup_records) - 216usize];
    ["Offset of field: _GResolverClass::lookup_records_async"]
        [::std::mem::offset_of!(_GResolverClass, lookup_records_async) - 224usize];
    ["Offset of field: _GResolverClass::lookup_records_finish"]
        [::std::mem::offset_of!(_GResolverClass, lookup_records_finish) - 232usize];
    ["Offset of field: _GResolverClass::lookup_by_name_with_flags_async"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_name_with_flags_async) - 240usize];
    ["Offset of field: _GResolverClass::lookup_by_name_with_flags_finish"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_name_with_flags_finish) - 248usize];
    ["Offset of field: _GResolverClass::lookup_by_name_with_flags"]
        [::std::mem::offset_of!(_GResolverClass, lookup_by_name_with_flags) - 256usize];
};
unsafe extern "C" {
    pub fn g_resolver_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resolver_get_default() -> *mut GResolver;
}
unsafe extern "C" {
    pub fn g_resolver_set_default(resolver: *mut GResolver);
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_name(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_name_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_name_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        flags: GResolverNameLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags(
        resolver: *mut GResolver,
        hostname: *const gchar,
        flags: GResolverNameLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_free_addresses(addresses: *mut GList);
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_address(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_address_async(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_resolver_lookup_by_address_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_service(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_service_async(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_resolver_lookup_service_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_records(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_lookup_records_async(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_resolver_lookup_records_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_resolver_free_targets(targets: *mut GList);
}
unsafe extern "C" {
    pub fn g_resolver_get_timeout(resolver: *mut GResolver) -> ::std::os::raw::c_uint;
}
unsafe extern "C" {
    pub fn g_resolver_set_timeout(resolver: *mut GResolver, timeout_ms: ::std::os::raw::c_uint);
}
unsafe extern "C" {
    pub fn g_resolver_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_resource_error_quark() -> GQuark;
}
pub type GStaticResource = _GStaticResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticResource {
    pub data: *const guint8,
    pub data_len: gsize,
    pub resource: *mut GResource,
    pub next: *mut GStaticResource,
    pub padding: gpointer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GStaticResource"][::std::mem::size_of::<_GStaticResource>() - 40usize];
    ["Alignment of _GStaticResource"][::std::mem::align_of::<_GStaticResource>() - 8usize];
    ["Offset of field: _GStaticResource::data"]
        [::std::mem::offset_of!(_GStaticResource, data) - 0usize];
    ["Offset of field: _GStaticResource::data_len"]
        [::std::mem::offset_of!(_GStaticResource, data_len) - 8usize];
    ["Offset of field: _GStaticResource::resource"]
        [::std::mem::offset_of!(_GStaticResource, resource) - 16usize];
    ["Offset of field: _GStaticResource::next"]
        [::std::mem::offset_of!(_GStaticResource, next) - 24usize];
    ["Offset of field: _GStaticResource::padding"]
        [::std::mem::offset_of!(_GStaticResource, padding) - 32usize];
};
unsafe extern "C" {
    pub fn g_resource_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_resource_new_from_data(data: *mut GBytes, error: *mut *mut GError) -> *mut GResource;
}
unsafe extern "C" {
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
}
unsafe extern "C" {
    pub fn g_resource_unref(resource: *mut GResource);
}
unsafe extern "C" {
    pub fn g_resource_load(filename: *const gchar, error: *mut *mut GError) -> *mut GResource;
}
unsafe extern "C" {
    pub fn g_resource_open_stream(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_resource_lookup_data(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_resource_enumerate_children(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_resource_get_info(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_resources_register(resource: *mut GResource);
}
unsafe extern "C" {
    pub fn g_resources_unregister(resource: *mut GResource);
}
unsafe extern "C" {
    pub fn g_resources_open_stream(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_resources_lookup_data(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_resources_enumerate_children(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_resources_get_info(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);
}
unsafe extern "C" {
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
}
unsafe extern "C" {
    pub fn g_static_resource_get_resource(static_resource: *mut GStaticResource) -> *mut GResource;
}
#[doc = " GSeekableIface:\n @g_iface: The parent interface.\n @tell: Tells the current location within a stream.\n @can_seek: Checks if seeking is supported by the stream.\n @seek: Seeks to a location within a stream.\n @can_truncate: Checks if truncation is supported by the stream.\n @truncate_fn: Truncates a stream.\n\n Provides an interface for implementing seekable functionality on I/O Streams."]
pub type GSeekableIface = _GSeekableIface;
#[doc = " GSeekableIface:\n @g_iface: The parent interface.\n @tell: Tells the current location within a stream.\n @can_seek: Checks if seeking is supported by the stream.\n @seek: Seeks to a location within a stream.\n @can_truncate: Checks if truncation is supported by the stream.\n @truncate_fn: Truncates a stream.\n\n Provides an interface for implementing seekable functionality on I/O Streams."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekableIface {
    pub g_iface: GTypeInterface,
    pub tell: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSeekableIface"][::std::mem::size_of::<_GSeekableIface>() - 56usize];
    ["Alignment of _GSeekableIface"][::std::mem::align_of::<_GSeekableIface>() - 8usize];
    ["Offset of field: _GSeekableIface::g_iface"]
        [::std::mem::offset_of!(_GSeekableIface, g_iface) - 0usize];
    ["Offset of field: _GSeekableIface::tell"]
        [::std::mem::offset_of!(_GSeekableIface, tell) - 16usize];
    ["Offset of field: _GSeekableIface::can_seek"]
        [::std::mem::offset_of!(_GSeekableIface, can_seek) - 24usize];
    ["Offset of field: _GSeekableIface::seek"]
        [::std::mem::offset_of!(_GSeekableIface, seek) - 32usize];
    ["Offset of field: _GSeekableIface::can_truncate"]
        [::std::mem::offset_of!(_GSeekableIface, can_truncate) - 40usize];
    ["Offset of field: _GSeekableIface::truncate_fn"]
        [::std::mem::offset_of!(_GSeekableIface, truncate_fn) - 48usize];
};
unsafe extern "C" {
    pub fn g_seekable_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> goffset;
}
unsafe extern "C" {
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
}
unsafe extern "C" {
    pub fn g_seekable_seek(
        seekable: *mut GSeekable,
        offset: goffset,
        type_: GSeekType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
}
unsafe extern "C" {
    pub fn g_seekable_truncate(
        seekable: *mut GSeekable,
        offset: goffset,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaSource {
    _unused: [u8; 0],
}
pub type GSettingsSchemaSource = _GSettingsSchemaSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchema {
    _unused: [u8; 0],
}
pub type GSettingsSchema = _GSettingsSchema;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaKey {
    _unused: [u8; 0],
}
pub type GSettingsSchemaKey = _GSettingsSchemaKey;
unsafe extern "C" {
    pub fn g_settings_schema_source_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_settings_schema_source_get_default() -> *mut GSettingsSchemaSource;
}
unsafe extern "C" {
    pub fn g_settings_schema_source_ref(
        source: *mut GSettingsSchemaSource,
    ) -> *mut GSettingsSchemaSource;
}
unsafe extern "C" {
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
}
unsafe extern "C" {
    pub fn g_settings_schema_source_new_from_directory(
        directory: *const gchar,
        parent: *mut GSettingsSchemaSource,
        trusted: gboolean,
        error: *mut *mut GError,
    ) -> *mut GSettingsSchemaSource;
}
unsafe extern "C" {
    pub fn g_settings_schema_source_lookup(
        source: *mut GSettingsSchemaSource,
        schema_id: *const gchar,
        recursive: gboolean,
    ) -> *mut GSettingsSchema;
}
unsafe extern "C" {
    pub fn g_settings_schema_source_list_schemas(
        source: *mut GSettingsSchemaSource,
        recursive: gboolean,
        non_relocatable: *mut *mut *mut gchar,
        relocatable: *mut *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn g_settings_schema_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema) -> *mut GSettingsSchema;
}
unsafe extern "C" {
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);
}
unsafe extern "C" {
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_settings_schema_get_key(
        schema: *mut GSettingsSchema,
        name: *const gchar,
    ) -> *mut GSettingsSchemaKey;
}
unsafe extern "C" {
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey) -> *mut GSettingsSchemaKey;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_value_type(
        key: *mut GSettingsSchemaKey,
    ) -> *const GVariantType;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_default_value(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_range_check(
        key: *mut GSettingsSchemaKey,
        value: *mut GVariant,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsPrivate {
    _unused: [u8; 0],
}
pub type GSettingsPrivate = _GSettingsPrivate;
pub type GSettingsClass = _GSettingsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsClass {
    pub parent_class: GObjectClass,
    pub writable_changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub writable_change_event: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut GSettings, key: GQuark) -> gboolean,
    >,
    pub change_event: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut GSettings,
            keys: *const GQuark,
            n_keys: gint,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSettingsClass"][::std::mem::size_of::<_GSettingsClass>() - 328usize];
    ["Alignment of _GSettingsClass"][::std::mem::align_of::<_GSettingsClass>() - 8usize];
    ["Offset of field: _GSettingsClass::parent_class"]
        [::std::mem::offset_of!(_GSettingsClass, parent_class) - 0usize];
    ["Offset of field: _GSettingsClass::writable_changed"]
        [::std::mem::offset_of!(_GSettingsClass, writable_changed) - 136usize];
    ["Offset of field: _GSettingsClass::changed"]
        [::std::mem::offset_of!(_GSettingsClass, changed) - 144usize];
    ["Offset of field: _GSettingsClass::writable_change_event"]
        [::std::mem::offset_of!(_GSettingsClass, writable_change_event) - 152usize];
    ["Offset of field: _GSettingsClass::change_event"]
        [::std::mem::offset_of!(_GSettingsClass, change_event) - 160usize];
    ["Offset of field: _GSettingsClass::padding"]
        [::std::mem::offset_of!(_GSettingsClass, padding) - 168usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettings {
    pub parent_instance: GObject,
    pub priv_: *mut GSettingsPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSettings"][::std::mem::size_of::<_GSettings>() - 32usize];
    ["Alignment of _GSettings"][::std::mem::align_of::<_GSettings>() - 8usize];
    ["Offset of field: _GSettings::parent_instance"]
        [::std::mem::offset_of!(_GSettings, parent_instance) - 0usize];
    ["Offset of field: _GSettings::priv_"][::std::mem::offset_of!(_GSettings, priv_) - 24usize];
};
unsafe extern "C" {
    pub fn g_settings_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_settings_list_schemas() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_settings_list_relocatable_schemas() -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_settings_new(schema_id: *const gchar) -> *mut GSettings;
}
unsafe extern "C" {
    pub fn g_settings_new_with_path(schema_id: *const gchar, path: *const gchar) -> *mut GSettings;
}
unsafe extern "C" {
    pub fn g_settings_new_with_backend(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
    ) -> *mut GSettings;
}
unsafe extern "C" {
    pub fn g_settings_new_with_backend_and_path(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
unsafe extern "C" {
    pub fn g_settings_new_full(
        schema: *mut GSettingsSchema,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
unsafe extern "C" {
    pub fn g_settings_list_children(settings: *mut GSettings) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_settings_range_check(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_set_value(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_settings_get_user_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_settings_get_default_value(
        settings: *mut GSettings,
        key: *const gchar,
    ) -> *mut GVariant;
}
unsafe extern "C" {
    pub fn g_settings_set(
        settings: *mut GSettings,
        key: *const gchar,
        format: *const gchar,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get(settings: *mut GSettings, key: *const gchar, format: *const gchar, ...);
}
unsafe extern "C" {
    pub fn g_settings_reset(settings: *mut GSettings, key: *const gchar);
}
unsafe extern "C" {
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const gchar, value: gint)
        -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_int64(settings: *mut GSettings, key: *const gchar) -> gint64;
}
unsafe extern "C" {
    pub fn g_settings_set_int64(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const gchar) -> guint;
}
unsafe extern "C" {
    pub fn g_settings_set_uint(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_uint64(settings: *mut GSettings, key: *const gchar) -> guint64;
}
unsafe extern "C" {
    pub fn g_settings_set_uint64(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint64,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const gchar) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_settings_set_string(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_set_boolean(
        settings: *mut GSettings,
        key: *const gchar,
        value: gboolean,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const gchar) -> gdouble;
}
unsafe extern "C" {
    pub fn g_settings_set_double(
        settings: *mut GSettings,
        key: *const gchar,
        value: gdouble,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const gchar) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn g_settings_set_strv(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const *const gchar,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const gchar) -> gint;
}
unsafe extern "C" {
    pub fn g_settings_set_enum(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const gchar) -> guint;
}
unsafe extern "C" {
    pub fn g_settings_set_flags(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const gchar) -> *mut GSettings;
}
unsafe extern "C" {
    pub fn g_settings_is_writable(settings: *mut GSettings, name: *const gchar) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_delay(settings: *mut GSettings);
}
unsafe extern "C" {
    pub fn g_settings_apply(settings: *mut GSettings);
}
unsafe extern "C" {
    pub fn g_settings_revert(settings: *mut GSettings);
}
unsafe extern "C" {
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
}
unsafe extern "C" {
    pub fn g_settings_sync();
}
#[doc = " GSettingsBindSetMapping:\n @value: a #GValue containing the property value to map\n @expected_type: the #GVariantType to create\n @user_data: user data that was specified when the binding was created\n\n The type for the function that is used to convert an object property\n value to a #GVariant for storing it in #GSettings.\n\n Returns: a new #GVariant holding the data from @value,\n     or %NULL in case of an error"]
pub type GSettingsBindSetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const GValue,
        expected_type: *const GVariantType,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
#[doc = " GSettingsBindGetMapping:\n @value: return location for the property value\n @variant: the #GVariant\n @user_data: user data that was specified when the binding was created\n\n The type for the function that is used to convert from #GSettings to\n an object property. The @value is already initialized to hold values\n of the appropriate type.\n\n Returns: %TRUE if the conversion succeeded, %FALSE in case of an error"]
pub type GSettingsBindGetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GValue,
        variant: *mut GVariant,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSettingsGetMapping:\n @value: the #GVariant to map, or %NULL\n @result: (out): the result of the mapping\n @user_data: (closure): the user data that was passed to\n g_settings_get_mapped()\n\n The type of the function that is used to convert from a value stored\n in a #GSettings to a value that is useful to the application.\n\n If the value is successfully mapped, the result should be stored at\n @result and %TRUE returned.  If mapping fails (for example, if @value\n is not in the right format) then %FALSE should be returned.\n\n If @value is %NULL then it means that the mapping function is being\n given a \"last chance\" to successfully return a valid value.  %TRUE\n must be returned in this case.\n\n Returns: %TRUE if the conversion succeeded, %FALSE in case of an error"]
pub type GSettingsGetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GVariant,
        result: *mut gpointer,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GSettingsBindFlags_G_SETTINGS_BIND_DEFAULT: GSettingsBindFlags = 0;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET: GSettingsBindFlags = 1;
pub const GSettingsBindFlags_G_SETTINGS_BIND_SET: GSettingsBindFlags = 2;
pub const GSettingsBindFlags_G_SETTINGS_BIND_NO_SENSITIVITY: GSettingsBindFlags = 4;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET_NO_CHANGES: GSettingsBindFlags = 8;
pub const GSettingsBindFlags_G_SETTINGS_BIND_INVERT_BOOLEAN: GSettingsBindFlags = 16;
#[doc = " GSettingsBindFlags:\n @G_SETTINGS_BIND_DEFAULT: Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`\n @G_SETTINGS_BIND_GET: Update the #GObject property when the setting changes.\n     It is an error to use this flag if the property is not writable.\n @G_SETTINGS_BIND_SET: Update the setting when the #GObject property changes.\n     It is an error to use this flag if the property is not readable.\n @G_SETTINGS_BIND_NO_SENSITIVITY: Do not try to bind a \"sensitivity\" property to the writability of the setting\n @G_SETTINGS_BIND_GET_NO_CHANGES: When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property\n     value initially from the setting, but do not listen for changes of the setting\n @G_SETTINGS_BIND_INVERT_BOOLEAN: When passed to g_settings_bind(), uses a pair of mapping functions that invert\n     the boolean value when mapping between the setting and the property.  The setting and property must both\n     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().\n\n Flags used when creating a binding. These flags determine in which\n direction the binding works. The default is to synchronize in both\n directions."]
pub type GSettingsBindFlags = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn g_settings_bind(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
    );
}
unsafe extern "C" {
    pub fn g_settings_bind_with_mapping(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
        get_mapping: GSettingsBindGetMapping,
        set_mapping: GSettingsBindSetMapping,
        user_data: gpointer,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_settings_bind_writable(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        inverted: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_settings_unbind(object: gpointer, property: *const gchar);
}
unsafe extern "C" {
    pub fn g_settings_create_action(settings: *mut GSettings, key: *const gchar) -> *mut GAction;
}
unsafe extern "C" {
    pub fn g_settings_get_mapped(
        settings: *mut GSettings,
        key: *const gchar,
        mapping: GSettingsGetMapping,
        user_data: gpointer,
    ) -> gpointer;
}
unsafe extern "C" {
    pub fn g_simple_action_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_simple_action_new(
        name: *const gchar,
        parameter_type: *const GVariantType,
    ) -> *mut GSimpleAction;
}
unsafe extern "C" {
    pub fn g_simple_action_new_stateful(
        name: *const gchar,
        parameter_type: *const GVariantType,
        state: *mut GVariant,
    ) -> *mut GSimpleAction;
}
unsafe extern "C" {
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction, enabled: gboolean);
}
unsafe extern "C" {
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction, value: *mut GVariant);
}
unsafe extern "C" {
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction, state_hint: *mut GVariant);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupPrivate {
    _unused: [u8; 0],
}
pub type GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate;
pub type GSimpleActionGroupClass = _GSimpleActionGroupClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroup {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleActionGroupPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSimpleActionGroup"][::std::mem::size_of::<_GSimpleActionGroup>() - 32usize];
    ["Alignment of _GSimpleActionGroup"][::std::mem::align_of::<_GSimpleActionGroup>() - 8usize];
    ["Offset of field: _GSimpleActionGroup::parent_instance"]
        [::std::mem::offset_of!(_GSimpleActionGroup, parent_instance) - 0usize];
    ["Offset of field: _GSimpleActionGroup::priv_"]
        [::std::mem::offset_of!(_GSimpleActionGroup, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 12usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSimpleActionGroupClass"]
        [::std::mem::size_of::<_GSimpleActionGroupClass>() - 232usize];
    ["Alignment of _GSimpleActionGroupClass"]
        [::std::mem::align_of::<_GSimpleActionGroupClass>() - 8usize];
    ["Offset of field: _GSimpleActionGroupClass::parent_class"]
        [::std::mem::offset_of!(_GSimpleActionGroupClass, parent_class) - 0usize];
    ["Offset of field: _GSimpleActionGroupClass::padding"]
        [::std::mem::offset_of!(_GSimpleActionGroupClass, padding) - 136usize];
};
unsafe extern "C" {
    pub fn g_simple_action_group_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
}
unsafe extern "C" {
    pub fn g_simple_action_group_lookup(
        simple: *mut GSimpleActionGroup,
        action_name: *const gchar,
    ) -> *mut GAction;
}
unsafe extern "C" {
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup, action: *mut GAction);
}
unsafe extern "C" {
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup, action_name: *const gchar);
}
unsafe extern "C" {
    pub fn g_simple_action_group_add_entries(
        simple: *mut GSimpleActionGroup,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResultClass {
    _unused: [u8; 0],
}
pub type GSimpleAsyncResultClass = _GSimpleAsyncResultClass;
unsafe extern "C" {
    pub fn g_simple_async_result_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_simple_async_result_new(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        source_tag: gpointer,
    ) -> *mut GSimpleAsyncResult;
}
unsafe extern "C" {
    pub fn g_simple_async_result_new_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GSimpleAsyncResult;
}
unsafe extern "C" {
    pub fn g_simple_async_result_new_from_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    ) -> *mut GSimpleAsyncResult;
}
unsafe extern "C" {
    pub fn g_simple_async_result_new_take_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    ) -> *mut GSimpleAsyncResult;
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_op_res_gpointer(
        simple: *mut GSimpleAsyncResult,
        op_res: gpointer,
        destroy_op_res: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_get_op_res_gpointer(simple: *mut GSimpleAsyncResult) -> gpointer;
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_op_res_gssize(simple: *mut GSimpleAsyncResult, op_res: gssize);
}
unsafe extern "C" {
    pub fn g_simple_async_result_get_op_res_gssize(simple: *mut GSimpleAsyncResult) -> gssize;
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_op_res_gboolean(
        simple: *mut GSimpleAsyncResult,
        op_res: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_get_op_res_gboolean(simple: *mut GSimpleAsyncResult) -> gboolean;
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_check_cancellable(
        simple: *mut GSimpleAsyncResult,
        check_cancellable: *mut GCancellable,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_get_source_tag(simple: *mut GSimpleAsyncResult) -> gpointer;
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_handle_cancellation(
        simple: *mut GSimpleAsyncResult,
        handle_cancellation: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
}
unsafe extern "C" {
    pub fn g_simple_async_result_complete_in_idle(simple: *mut GSimpleAsyncResult);
}
unsafe extern "C" {
    pub fn g_simple_async_result_run_in_thread(
        simple: *mut GSimpleAsyncResult,
        func: GSimpleAsyncThreadFunc,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_from_error(
        simple: *mut GSimpleAsyncResult,
        error: *const GError,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult, error: *mut GError);
}
unsafe extern "C" {
    pub fn g_simple_async_result_propagate_error(
        simple: *mut GSimpleAsyncResult,
        dest: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_error(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_set_error_va(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_result_is_valid(
        result: *mut GAsyncResult,
        source: *mut GObject,
        source_tag: gpointer,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_simple_async_report_error_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_simple_async_report_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    );
}
unsafe extern "C" {
    pub fn g_simple_async_report_take_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    );
}
unsafe extern "C" {
    pub fn g_simple_io_stream_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_simple_io_stream_new(
        input_stream: *mut GInputStream,
        output_stream: *mut GOutputStream,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_simple_permission_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;
}
pub type GSimpleProxyResolver = _GSimpleProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverPrivate {
    _unused: [u8; 0],
}
pub type GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate;
pub type GSimpleProxyResolverClass = _GSimpleProxyResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleProxyResolverPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSimpleProxyResolver"][::std::mem::size_of::<_GSimpleProxyResolver>() - 32usize];
    ["Alignment of _GSimpleProxyResolver"]
        [::std::mem::align_of::<_GSimpleProxyResolver>() - 8usize];
    ["Offset of field: _GSimpleProxyResolver::parent_instance"]
        [::std::mem::offset_of!(_GSimpleProxyResolver, parent_instance) - 0usize];
    ["Offset of field: _GSimpleProxyResolver::priv_"]
        [::std::mem::offset_of!(_GSimpleProxyResolver, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSimpleProxyResolverClass"]
        [::std::mem::size_of::<_GSimpleProxyResolverClass>() - 176usize];
    ["Alignment of _GSimpleProxyResolverClass"]
        [::std::mem::align_of::<_GSimpleProxyResolverClass>() - 8usize];
    ["Offset of field: _GSimpleProxyResolverClass::parent_class"]
        [::std::mem::offset_of!(_GSimpleProxyResolverClass, parent_class) - 0usize];
    ["Offset of field: _GSimpleProxyResolverClass::_g_reserved1"]
        [::std::mem::offset_of!(_GSimpleProxyResolverClass, _g_reserved1) - 136usize];
    ["Offset of field: _GSimpleProxyResolverClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSimpleProxyResolverClass, _g_reserved2) - 144usize];
    ["Offset of field: _GSimpleProxyResolverClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSimpleProxyResolverClass, _g_reserved3) - 152usize];
    ["Offset of field: _GSimpleProxyResolverClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSimpleProxyResolverClass, _g_reserved4) - 160usize];
    ["Offset of field: _GSimpleProxyResolverClass::_g_reserved5"]
        [::std::mem::offset_of!(_GSimpleProxyResolverClass, _g_reserved5) - 168usize];
};
unsafe extern "C" {
    pub fn g_simple_proxy_resolver_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_simple_proxy_resolver_new(
        default_proxy: *const gchar,
        ignore_hosts: *mut *mut gchar,
    ) -> *mut GProxyResolver;
}
unsafe extern "C" {
    pub fn g_simple_proxy_resolver_set_default_proxy(
        resolver: *mut GSimpleProxyResolver,
        default_proxy: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_simple_proxy_resolver_set_ignore_hosts(
        resolver: *mut GSimpleProxyResolver,
        ignore_hosts: *mut *mut gchar,
    );
}
unsafe extern "C" {
    pub fn g_simple_proxy_resolver_set_uri_proxy(
        resolver: *mut GSimpleProxyResolver,
        uri_scheme: *const gchar,
        proxy: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketPrivate {
    _unused: [u8; 0],
}
pub type GSocketPrivate = _GSocketPrivate;
pub type GSocketClass = _GSocketClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketClass"][::std::mem::size_of::<_GSocketClass>() - 216usize];
    ["Alignment of _GSocketClass"][::std::mem::align_of::<_GSocketClass>() - 8usize];
    ["Offset of field: _GSocketClass::parent_class"]
        [::std::mem::offset_of!(_GSocketClass, parent_class) - 0usize];
    ["Offset of field: _GSocketClass::_g_reserved1"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved1) - 136usize];
    ["Offset of field: _GSocketClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved2) - 144usize];
    ["Offset of field: _GSocketClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved3) - 152usize];
    ["Offset of field: _GSocketClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved4) - 160usize];
    ["Offset of field: _GSocketClass::_g_reserved5"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved5) - 168usize];
    ["Offset of field: _GSocketClass::_g_reserved6"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved6) - 176usize];
    ["Offset of field: _GSocketClass::_g_reserved7"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved7) - 184usize];
    ["Offset of field: _GSocketClass::_g_reserved8"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved8) - 192usize];
    ["Offset of field: _GSocketClass::_g_reserved9"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved9) - 200usize];
    ["Offset of field: _GSocketClass::_g_reserved10"]
        [::std::mem::offset_of!(_GSocketClass, _g_reserved10) - 208usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocket {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocket"][::std::mem::size_of::<_GSocket>() - 32usize];
    ["Alignment of _GSocket"][::std::mem::align_of::<_GSocket>() - 8usize];
    ["Offset of field: _GSocket::parent_instance"]
        [::std::mem::offset_of!(_GSocket, parent_instance) - 0usize];
    ["Offset of field: _GSocket::priv_"][::std::mem::offset_of!(_GSocket, priv_) - 24usize];
};
unsafe extern "C" {
    pub fn g_socket_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_new(
        family: GSocketFamily,
        type_: GSocketType,
        protocol: GSocketProtocol,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
unsafe extern "C" {
    pub fn g_socket_new_from_fd(fd: gint, error: *mut *mut GError) -> *mut GSocket;
}
unsafe extern "C" {
    pub fn g_socket_get_fd(socket: *mut GSocket) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
}
unsafe extern "C" {
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
}
unsafe extern "C" {
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
}
unsafe extern "C" {
    pub fn g_socket_get_local_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_get_remote_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
}
unsafe extern "C" {
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
}
unsafe extern "C" {
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> gint;
}
unsafe extern "C" {
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: gint);
}
unsafe extern "C" {
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> guint;
}
unsafe extern "C" {
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: guint);
}
unsafe extern "C" {
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> guint;
}
unsafe extern "C" {
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: guint);
}
unsafe extern "C" {
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
}
unsafe extern "C" {
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket, loopback: gboolean);
}
unsafe extern "C" {
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> guint;
}
unsafe extern "C" {
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: guint);
}
unsafe extern "C" {
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_bind(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        allow_reuse: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_join_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_leave_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_join_multicast_group_ssm(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: *mut GInetAddress,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_leave_multicast_group_ssm(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: *mut GInetAddress,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_connect(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_check_connect_result(socket: *mut GSocket, error: *mut *mut GError)
        -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_condition_check(socket: *mut GSocket, condition: GIOCondition) -> GIOCondition;
}
unsafe extern "C" {
    pub fn g_socket_condition_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_condition_timed_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        timeout_us: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_accept(
        socket: *mut GSocket,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
unsafe extern "C" {
    pub fn g_socket_listen(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_receive(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_receive_bytes(
        socket: *mut GSocket,
        size: gsize,
        timeout_us: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_socket_receive_from(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_receive_bytes_from(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        size: gsize,
        timeout_us: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
unsafe extern "C" {
    pub fn g_socket_send(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_send_to(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_receive_message(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        vectors: *mut GInputVector,
        num_vectors: gint,
        messages: *mut *mut *mut GSocketControlMessage,
        num_messages: *mut gint,
        flags: *mut gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_send_message(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *mut GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_receive_messages(
        socket: *mut GSocket,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_socket_send_messages(
        socket: *mut GSocket,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_socket_close(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_shutdown(
        socket: *mut GSocket,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_create_source(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
unsafe extern "C" {
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_get_credentials(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
unsafe extern "C" {
    pub fn g_socket_receive_with_blocking(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_send_with_blocking(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
unsafe extern "C" {
    pub fn g_socket_send_message_with_timeout(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *const GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        timeout_us: gint64,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GPollableReturn;
}
unsafe extern "C" {
    pub fn g_socket_get_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_set_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientPrivate {
    _unused: [u8; 0],
}
pub type GSocketClientPrivate = _GSocketClientPrivate;
pub type GSocketClientClass = _GSocketClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientClass {
    pub parent_class: GObjectClass,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut GSocketClient,
            event: GSocketClientEvent,
            connectable: *mut GSocketConnectable,
            connection: *mut GIOStream,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketClientClass"][::std::mem::size_of::<_GSocketClientClass>() - 176usize];
    ["Alignment of _GSocketClientClass"][::std::mem::align_of::<_GSocketClientClass>() - 8usize];
    ["Offset of field: _GSocketClientClass::parent_class"]
        [::std::mem::offset_of!(_GSocketClientClass, parent_class) - 0usize];
    ["Offset of field: _GSocketClientClass::event"]
        [::std::mem::offset_of!(_GSocketClientClass, event) - 136usize];
    ["Offset of field: _GSocketClientClass::_g_reserved1"]
        [::std::mem::offset_of!(_GSocketClientClass, _g_reserved1) - 144usize];
    ["Offset of field: _GSocketClientClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSocketClientClass, _g_reserved2) - 152usize];
    ["Offset of field: _GSocketClientClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSocketClientClass, _g_reserved3) - 160usize];
    ["Offset of field: _GSocketClientClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSocketClientClass, _g_reserved4) - 168usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClient {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketClientPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketClient"][::std::mem::size_of::<_GSocketClient>() - 32usize];
    ["Alignment of _GSocketClient"][::std::mem::align_of::<_GSocketClient>() - 8usize];
    ["Offset of field: _GSocketClient::parent_instance"]
        [::std::mem::offset_of!(_GSocketClient, parent_instance) - 0usize];
    ["Offset of field: _GSocketClient::priv_"]
        [::std::mem::offset_of!(_GSocketClient, priv_) - 24usize];
};
unsafe extern "C" {
    pub fn g_socket_client_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_client_new() -> *mut GSocketClient;
}
unsafe extern "C" {
    pub fn g_socket_client_get_family(client: *mut GSocketClient) -> GSocketFamily;
}
unsafe extern "C" {
    pub fn g_socket_client_set_family(client: *mut GSocketClient, family: GSocketFamily);
}
unsafe extern "C" {
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient) -> GSocketType;
}
unsafe extern "C" {
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient, type_: GSocketType);
}
unsafe extern "C" {
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient) -> GSocketProtocol;
}
unsafe extern "C" {
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient, protocol: GSocketProtocol);
}
unsafe extern "C" {
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_client_set_local_address(
        client: *mut GSocketClient,
        address: *mut GSocketAddress,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> guint;
}
unsafe extern "C" {
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient, timeout: guint);
}
unsafe extern "C" {
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient, enable: gboolean);
}
unsafe extern "C" {
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
}
unsafe extern "C" {
    pub fn g_socket_client_get_tls_validation_flags(
        client: *mut GSocketClient,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_socket_client_set_tls_validation_flags(
        client: *mut GSocketClient,
        flags: GTlsCertificateFlags,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient) -> *mut GProxyResolver;
}
unsafe extern "C" {
    pub fn g_socket_client_set_proxy_resolver(
        client: *mut GSocketClient,
        proxy_resolver: *mut GProxyResolver,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_connect(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_host(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_service(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_uri(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_async(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_connect_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_host_async(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_host_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_service_async(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_service_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_uri_async(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_client_connect_to_uri_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_client_add_application_proxy(
        client: *mut GSocketClient,
        protocol: *const gchar,
    );
}
#[doc = " GSocketConnectableIface:\n @g_iface: The parent interface.\n @enumerate: Creates a #GSocketAddressEnumerator\n @proxy_enumerate: Creates a #GProxyAddressEnumerator\n @to_string: Format the connectable’s address as a string for debugging.\n    Implementing this is optional. (Since: 2.48)\n\n Provides an interface for returning a #GSocketAddressEnumerator\n and #GProxyAddressEnumerator"]
pub type GSocketConnectableIface = _GSocketConnectableIface;
#[doc = " GSocketConnectableIface:\n @g_iface: The parent interface.\n @enumerate: Creates a #GSocketAddressEnumerator\n @proxy_enumerate: Creates a #GProxyAddressEnumerator\n @to_string: Format the connectable’s address as a string for debugging.\n    Implementing this is optional. (Since: 2.48)\n\n Provides an interface for returning a #GSocketAddressEnumerator\n and #GProxyAddressEnumerator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectableIface {
    pub g_iface: GTypeInterface,
    pub enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub proxy_enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub to_string: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut gchar,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketConnectableIface"]
        [::std::mem::size_of::<_GSocketConnectableIface>() - 40usize];
    ["Alignment of _GSocketConnectableIface"]
        [::std::mem::align_of::<_GSocketConnectableIface>() - 8usize];
    ["Offset of field: _GSocketConnectableIface::g_iface"]
        [::std::mem::offset_of!(_GSocketConnectableIface, g_iface) - 0usize];
    ["Offset of field: _GSocketConnectableIface::enumerate"]
        [::std::mem::offset_of!(_GSocketConnectableIface, enumerate) - 16usize];
    ["Offset of field: _GSocketConnectableIface::proxy_enumerate"]
        [::std::mem::offset_of!(_GSocketConnectableIface, proxy_enumerate) - 24usize];
    ["Offset of field: _GSocketConnectableIface::to_string"]
        [::std::mem::offset_of!(_GSocketConnectableIface, to_string) - 32usize];
};
unsafe extern "C" {
    pub fn g_socket_connectable_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_connectable_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
unsafe extern "C" {
    pub fn g_socket_connectable_proxy_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
unsafe extern "C" {
    pub fn g_socket_connectable_to_string(connectable: *mut GSocketConnectable) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionPrivate {
    _unused: [u8; 0],
}
pub type GSocketConnectionPrivate = _GSocketConnectionPrivate;
pub type GSocketConnectionClass = _GSocketConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketConnectionClass"]
        [::std::mem::size_of::<_GSocketConnectionClass>() - 304usize];
    ["Alignment of _GSocketConnectionClass"]
        [::std::mem::align_of::<_GSocketConnectionClass>() - 8usize];
    ["Offset of field: _GSocketConnectionClass::parent_class"]
        [::std::mem::offset_of!(_GSocketConnectionClass, parent_class) - 0usize];
    ["Offset of field: _GSocketConnectionClass::_g_reserved1"]
        [::std::mem::offset_of!(_GSocketConnectionClass, _g_reserved1) - 256usize];
    ["Offset of field: _GSocketConnectionClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSocketConnectionClass, _g_reserved2) - 264usize];
    ["Offset of field: _GSocketConnectionClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSocketConnectionClass, _g_reserved3) - 272usize];
    ["Offset of field: _GSocketConnectionClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSocketConnectionClass, _g_reserved4) - 280usize];
    ["Offset of field: _GSocketConnectionClass::_g_reserved5"]
        [::std::mem::offset_of!(_GSocketConnectionClass, _g_reserved5) - 288usize];
    ["Offset of field: _GSocketConnectionClass::_g_reserved6"]
        [::std::mem::offset_of!(_GSocketConnectionClass, _g_reserved6) - 296usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GSocketConnectionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketConnection"][::std::mem::size_of::<_GSocketConnection>() - 40usize];
    ["Alignment of _GSocketConnection"][::std::mem::align_of::<_GSocketConnection>() - 8usize];
    ["Offset of field: _GSocketConnection::parent_instance"]
        [::std::mem::offset_of!(_GSocketConnection, parent_instance) - 0usize];
    ["Offset of field: _GSocketConnection::priv_"]
        [::std::mem::offset_of!(_GSocketConnection, priv_) - 32usize];
};
unsafe extern "C" {
    pub fn g_socket_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_connection_is_connected(connection: *mut GSocketConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_connection_connect(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_connection_connect_async(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_connection_connect_finish(
        connection: *mut GSocketConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection) -> *mut GSocket;
}
unsafe extern "C" {
    pub fn g_socket_connection_get_local_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_connection_get_remote_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_socket_connection_factory_register_type(
        g_type: GType,
        family: GSocketFamily,
        type_: GSocketType,
        protocol: gint,
    );
}
unsafe extern "C" {
    pub fn g_socket_connection_factory_lookup_type(
        family: GSocketFamily,
        type_: GSocketType,
        protocol_id: gint,
    ) -> GType;
}
unsafe extern "C" {
    pub fn g_socket_connection_factory_create_connection(
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessagePrivate {
    _unused: [u8; 0],
}
pub type GSocketControlMessagePrivate = _GSocketControlMessagePrivate;
#[doc = " GSocketControlMessageClass:\n @get_size: gets the size of the message.\n @get_level: gets the protocol of the message.\n @get_type: gets the protocol specific type of the message.\n @serialize: Writes out the message data.\n @deserialize: Tries to deserialize a message.\n\n Class structure for #GSocketControlMessage."]
pub type GSocketControlMessageClass = _GSocketControlMessageClass;
#[doc = " GSocketControlMessageClass:\n @get_size: gets the size of the message.\n @get_level: gets the protocol of the message.\n @get_type: gets the protocol specific type of the message.\n @serialize: Writes out the message data.\n @deserialize: Tries to deserialize a message.\n\n Class structure for #GSocketControlMessage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessageClass {
    pub parent_class: GObjectClass,
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(message: *mut GSocketControlMessage) -> gsize>,
    pub get_level: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub serialize: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage, data: gpointer),
    >,
    pub deserialize: ::std::option::Option<
        unsafe extern "C" fn(
            level: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            size: gsize,
            data: gpointer,
        ) -> *mut GSocketControlMessage,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketControlMessageClass"]
        [::std::mem::size_of::<_GSocketControlMessageClass>() - 216usize];
    ["Alignment of _GSocketControlMessageClass"]
        [::std::mem::align_of::<_GSocketControlMessageClass>() - 8usize];
    ["Offset of field: _GSocketControlMessageClass::parent_class"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, parent_class) - 0usize];
    ["Offset of field: _GSocketControlMessageClass::get_size"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, get_size) - 136usize];
    ["Offset of field: _GSocketControlMessageClass::get_level"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, get_level) - 144usize];
    ["Offset of field: _GSocketControlMessageClass::get_type"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, get_type) - 152usize];
    ["Offset of field: _GSocketControlMessageClass::serialize"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, serialize) - 160usize];
    ["Offset of field: _GSocketControlMessageClass::deserialize"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, deserialize) - 168usize];
    ["Offset of field: _GSocketControlMessageClass::_g_reserved1"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, _g_reserved1) - 176usize];
    ["Offset of field: _GSocketControlMessageClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, _g_reserved2) - 184usize];
    ["Offset of field: _GSocketControlMessageClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, _g_reserved3) - 192usize];
    ["Offset of field: _GSocketControlMessageClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, _g_reserved4) - 200usize];
    ["Offset of field: _GSocketControlMessageClass::_g_reserved5"]
        [::std::mem::offset_of!(_GSocketControlMessageClass, _g_reserved5) - 208usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessage {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketControlMessagePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketControlMessage"][::std::mem::size_of::<_GSocketControlMessage>() - 32usize];
    ["Alignment of _GSocketControlMessage"]
        [::std::mem::align_of::<_GSocketControlMessage>() - 8usize];
    ["Offset of field: _GSocketControlMessage::parent_instance"]
        [::std::mem::offset_of!(_GSocketControlMessage, parent_instance) - 0usize];
    ["Offset of field: _GSocketControlMessage::priv_"]
        [::std::mem::offset_of!(_GSocketControlMessage, priv_) - 24usize];
};
unsafe extern "C" {
    pub fn g_socket_control_message_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_control_message_get_size(message: *mut GSocketControlMessage) -> gsize;
}
unsafe extern "C" {
    pub fn g_socket_control_message_get_level(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_socket_control_message_get_msg_type(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn g_socket_control_message_serialize(message: *mut GSocketControlMessage, data: gpointer);
}
unsafe extern "C" {
    pub fn g_socket_control_message_deserialize(
        level: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        size: gsize,
        data: gpointer,
    ) -> *mut GSocketControlMessage;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerPrivate {
    _unused: [u8; 0],
}
pub type GSocketListenerPrivate = _GSocketListenerPrivate;
#[doc = " GSocketListenerClass:\n @changed: virtual method called when the set of socket listened to changes\n\n Class structure for #GSocketListener."]
pub type GSocketListenerClass = _GSocketListenerClass;
#[doc = " GSocketListenerClass:\n @changed: virtual method called when the set of socket listened to changes\n\n Class structure for #GSocketListener."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(listener: *mut GSocketListener)>,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut GSocketListener,
            event: GSocketListenerEvent,
            socket: *mut GSocket,
        ),
    >,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketListenerClass"][::std::mem::size_of::<_GSocketListenerClass>() - 192usize];
    ["Alignment of _GSocketListenerClass"]
        [::std::mem::align_of::<_GSocketListenerClass>() - 8usize];
    ["Offset of field: _GSocketListenerClass::parent_class"]
        [::std::mem::offset_of!(_GSocketListenerClass, parent_class) - 0usize];
    ["Offset of field: _GSocketListenerClass::changed"]
        [::std::mem::offset_of!(_GSocketListenerClass, changed) - 136usize];
    ["Offset of field: _GSocketListenerClass::event"]
        [::std::mem::offset_of!(_GSocketListenerClass, event) - 144usize];
    ["Offset of field: _GSocketListenerClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSocketListenerClass, _g_reserved2) - 152usize];
    ["Offset of field: _GSocketListenerClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSocketListenerClass, _g_reserved3) - 160usize];
    ["Offset of field: _GSocketListenerClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSocketListenerClass, _g_reserved4) - 168usize];
    ["Offset of field: _GSocketListenerClass::_g_reserved5"]
        [::std::mem::offset_of!(_GSocketListenerClass, _g_reserved5) - 176usize];
    ["Offset of field: _GSocketListenerClass::_g_reserved6"]
        [::std::mem::offset_of!(_GSocketListenerClass, _g_reserved6) - 184usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListener {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketListenerPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketListener"][::std::mem::size_of::<_GSocketListener>() - 32usize];
    ["Alignment of _GSocketListener"][::std::mem::align_of::<_GSocketListener>() - 8usize];
    ["Offset of field: _GSocketListener::parent_instance"]
        [::std::mem::offset_of!(_GSocketListener, parent_instance) - 0usize];
    ["Offset of field: _GSocketListener::priv_"]
        [::std::mem::offset_of!(_GSocketListener, priv_) - 24usize];
};
unsafe extern "C" {
    pub fn g_socket_listener_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_listener_new() -> *mut GSocketListener;
}
unsafe extern "C" {
    pub fn g_socket_listener_set_backlog(
        listener: *mut GSocketListener,
        listen_backlog: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn g_socket_listener_add_socket(
        listener: *mut GSocketListener,
        socket: *mut GSocket,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_listener_add_address(
        listener: *mut GSocketListener,
        address: *mut GSocketAddress,
        type_: GSocketType,
        protocol: GSocketProtocol,
        source_object: *mut GObject,
        effective_address: *mut *mut GSocketAddress,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_listener_add_inet_port(
        listener: *mut GSocketListener,
        port: guint16,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_socket_listener_add_any_inet_port(
        listener: *mut GSocketListener,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> guint16;
}
unsafe extern "C" {
    pub fn g_socket_listener_accept_socket(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
unsafe extern "C" {
    pub fn g_socket_listener_accept_socket_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_listener_accept_socket_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
unsafe extern "C" {
    pub fn g_socket_listener_accept(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_listener_accept_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_socket_listener_accept_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GSocketServicePrivate = _GSocketServicePrivate;
#[doc = " GSocketServiceClass:\n @incoming: signal emitted when new connections are accepted\n\n Class structure for #GSocketService."]
pub type GSocketServiceClass = _GSocketServiceClass;
#[doc = " GSocketServiceClass:\n @incoming: signal emitted when new connections are accepted\n\n Class structure for #GSocketService."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketServiceClass"][::std::mem::size_of::<_GSocketServiceClass>() - 248usize];
    ["Alignment of _GSocketServiceClass"][::std::mem::align_of::<_GSocketServiceClass>() - 8usize];
    ["Offset of field: _GSocketServiceClass::parent_class"]
        [::std::mem::offset_of!(_GSocketServiceClass, parent_class) - 0usize];
    ["Offset of field: _GSocketServiceClass::incoming"]
        [::std::mem::offset_of!(_GSocketServiceClass, incoming) - 192usize];
    ["Offset of field: _GSocketServiceClass::_g_reserved1"]
        [::std::mem::offset_of!(_GSocketServiceClass, _g_reserved1) - 200usize];
    ["Offset of field: _GSocketServiceClass::_g_reserved2"]
        [::std::mem::offset_of!(_GSocketServiceClass, _g_reserved2) - 208usize];
    ["Offset of field: _GSocketServiceClass::_g_reserved3"]
        [::std::mem::offset_of!(_GSocketServiceClass, _g_reserved3) - 216usize];
    ["Offset of field: _GSocketServiceClass::_g_reserved4"]
        [::std::mem::offset_of!(_GSocketServiceClass, _g_reserved4) - 224usize];
    ["Offset of field: _GSocketServiceClass::_g_reserved5"]
        [::std::mem::offset_of!(_GSocketServiceClass, _g_reserved5) - 232usize];
    ["Offset of field: _GSocketServiceClass::_g_reserved6"]
        [::std::mem::offset_of!(_GSocketServiceClass, _g_reserved6) - 240usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketService {
    pub parent_instance: GSocketListener,
    pub priv_: *mut GSocketServicePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GSocketService"][::std::mem::size_of::<_GSocketService>() - 40usize];
    ["Alignment of _GSocketService"][::std::mem::align_of::<_GSocketService>() - 8usize];
    ["Offset of field: _GSocketService::parent_instance"]
        [::std::mem::offset_of!(_GSocketService, parent_instance) - 0usize];
    ["Offset of field: _GSocketService::priv_"]
        [::std::mem::offset_of!(_GSocketService, priv_) - 32usize];
};
unsafe extern "C" {
    pub fn g_socket_service_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_socket_service_new() -> *mut GSocketService;
}
unsafe extern "C" {
    pub fn g_socket_service_start(service: *mut GSocketService);
}
unsafe extern "C" {
    pub fn g_socket_service_stop(service: *mut GSocketService);
}
unsafe extern "C" {
    pub fn g_socket_service_is_active(service: *mut GSocketService) -> gboolean;
}
unsafe extern "C" {
    pub fn g_srv_target_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_srv_target_new(
        hostname: *const gchar,
        port: guint16,
        priority: guint16,
        weight: guint16,
    ) -> *mut GSrvTarget;
}
unsafe extern "C" {
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
}
unsafe extern "C" {
    pub fn g_srv_target_free(target: *mut GSrvTarget);
}
unsafe extern "C" {
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> guint16;
}
unsafe extern "C" {
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> guint16;
}
unsafe extern "C" {
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> guint16;
}
unsafe extern "C" {
    pub fn g_srv_target_list_sort(targets: *mut GList) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_subprocess_get_type() -> GType;
}
unsafe extern "C" {
    #[doc = " Core API"]
    pub fn g_subprocess_new(
        flags: GSubprocessFlags,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
unsafe extern "C" {
    pub fn g_subprocess_newv(
        argv: *const *const gchar,
        flags: GSubprocessFlags,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
unsafe extern "C" {
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess) -> *mut GOutputStream;
}
unsafe extern "C" {
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
unsafe extern "C" {
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess, signal_num: gint);
}
unsafe extern "C" {
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
}
unsafe extern "C" {
    pub fn g_subprocess_wait(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_wait_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_wait_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_wait_check(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_wait_check_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_wait_check_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> gint;
}
unsafe extern "C" {
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> gint;
}
unsafe extern "C" {
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> gint;
}
unsafe extern "C" {
    pub fn g_subprocess_communicate(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_communicate_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_communicate_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_communicate_utf8(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_communicate_utf8_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_communicate_utf8_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags) -> *mut GSubprocessLauncher;
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_spawn(
        self_: *mut GSubprocessLauncher,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_spawnv(
        self_: *mut GSubprocessLauncher,
        argv: *const *const gchar,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_environ(self_: *mut GSubprocessLauncher, env: *mut *mut gchar);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_setenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_unsetenv(self_: *mut GSubprocessLauncher, variable: *const gchar);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_getenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
    ) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_cwd(self_: *mut GSubprocessLauncher, cwd: *const gchar);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_flags(
        self_: *mut GSubprocessLauncher,
        flags: GSubprocessFlags,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_stdin_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_take_stdin_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_stdout_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_take_stdout_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_stderr_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_take_stderr_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_take_fd(
        self_: *mut GSubprocessLauncher,
        source_fd: gint,
        target_fd: gint,
    );
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_close(self_: *mut GSubprocessLauncher);
}
unsafe extern "C" {
    pub fn g_subprocess_launcher_set_child_setup(
        self_: *mut GSubprocessLauncher,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTaskClass {
    _unused: [u8; 0],
}
pub type GTaskClass = _GTaskClass;
unsafe extern "C" {
    pub fn g_task_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_task_new(
        source_object: gpointer,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
    ) -> *mut GTask;
}
unsafe extern "C" {
    pub fn g_task_report_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        error: *mut GError,
    );
}
unsafe extern "C" {
    pub fn g_task_report_new_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_task_set_task_data(
        task: *mut GTask,
        task_data: gpointer,
        task_data_destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_task_set_priority(task: *mut GTask, priority: gint);
}
unsafe extern "C" {
    pub fn g_task_set_check_cancellable(task: *mut GTask, check_cancellable: gboolean);
}
unsafe extern "C" {
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
}
unsafe extern "C" {
    pub fn g_task_set_name(task: *mut GTask, name: *const gchar);
}
unsafe extern "C" {
    pub fn g_task_set_static_name(task: *mut GTask, name: *const gchar);
}
unsafe extern "C" {
    pub fn g_task_get_source_object(task: *mut GTask) -> gpointer;
}
unsafe extern "C" {
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
}
unsafe extern "C" {
    pub fn g_task_get_priority(task: *mut GTask) -> gint;
}
unsafe extern "C" {
    pub fn g_task_get_context(task: *mut GTask) -> *mut GMainContext;
}
unsafe extern "C" {
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
}
unsafe extern "C" {
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
}
unsafe extern "C" {
    pub fn g_task_get_name(task: *mut GTask) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_task_is_valid(result: gpointer, source_object: gpointer) -> gboolean;
}
pub type GTaskThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut GTask,
        source_object: gpointer,
        task_data: gpointer,
        cancellable: *mut GCancellable,
    ),
>;
unsafe extern "C" {
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
}
unsafe extern "C" {
    pub fn g_task_run_in_thread_sync(task: *mut GTask, task_func: GTaskThreadFunc);
}
unsafe extern "C" {
    pub fn g_task_set_return_on_cancel(task: *mut GTask, return_on_cancel: gboolean) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_attach_source(task: *mut GTask, source: *mut GSource, callback: GSourceFunc);
}
unsafe extern "C" {
    pub fn g_task_return_pointer(
        task: *mut GTask,
        result: gpointer,
        result_destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
}
unsafe extern "C" {
    pub fn g_task_return_int(task: *mut GTask, result: gssize);
}
unsafe extern "C" {
    pub fn g_task_return_error(task: *mut GTask, error: *mut GError);
}
unsafe extern "C" {
    pub fn g_task_return_prefixed_error(
        task: *mut GTask,
        error: *mut GError,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_task_return_new_error(
        task: *mut GTask,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn g_task_return_new_error_literal(
        task: *mut GTask,
        domain: GQuark,
        code: gint,
        message: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_task_return_value(task: *mut GTask, result: *mut GValue);
}
unsafe extern "C" {
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_propagate_pointer(task: *mut GTask, error: *mut *mut GError) -> gpointer;
}
unsafe extern "C" {
    pub fn g_task_propagate_boolean(task: *mut GTask, error: *mut *mut GError) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_propagate_int(task: *mut GTask, error: *mut *mut GError) -> gssize;
}
unsafe extern "C" {
    pub fn g_task_propagate_value(
        task: *mut GTask,
        value: *mut GValue,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
}
unsafe extern "C" {
    pub fn g_task_print_alive_tasks();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpConnectionPrivate = _GTcpConnectionPrivate;
pub type GTcpConnectionClass = _GTcpConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTcpConnectionClass"][::std::mem::size_of::<_GTcpConnectionClass>() - 304usize];
    ["Alignment of _GTcpConnectionClass"][::std::mem::align_of::<_GTcpConnectionClass>() - 8usize];
    ["Offset of field: _GTcpConnectionClass::parent_class"]
        [::std::mem::offset_of!(_GTcpConnectionClass, parent_class) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GTcpConnectionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTcpConnection"][::std::mem::size_of::<_GTcpConnection>() - 48usize];
    ["Alignment of _GTcpConnection"][::std::mem::align_of::<_GTcpConnection>() - 8usize];
    ["Offset of field: _GTcpConnection::parent_instance"]
        [::std::mem::offset_of!(_GTcpConnection, parent_instance) - 0usize];
    ["Offset of field: _GTcpConnection::priv_"]
        [::std::mem::offset_of!(_GTcpConnection, priv_) - 40usize];
};
unsafe extern "C" {
    pub fn g_tcp_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tcp_connection_set_graceful_disconnect(
        connection: *mut GTcpConnection,
        graceful_disconnect: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_tcp_connection_get_graceful_disconnect(connection: *mut GTcpConnection) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate;
pub type GTcpWrapperConnectionClass = _GTcpWrapperConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTcpWrapperConnectionClass"]
        [::std::mem::size_of::<_GTcpWrapperConnectionClass>() - 304usize];
    ["Alignment of _GTcpWrapperConnectionClass"]
        [::std::mem::align_of::<_GTcpWrapperConnectionClass>() - 8usize];
    ["Offset of field: _GTcpWrapperConnectionClass::parent_class"]
        [::std::mem::offset_of!(_GTcpWrapperConnectionClass, parent_class) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub priv_: *mut GTcpWrapperConnectionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTcpWrapperConnection"][::std::mem::size_of::<_GTcpWrapperConnection>() - 56usize];
    ["Alignment of _GTcpWrapperConnection"]
        [::std::mem::align_of::<_GTcpWrapperConnection>() - 8usize];
    ["Offset of field: _GTcpWrapperConnection::parent_instance"]
        [::std::mem::offset_of!(_GTcpWrapperConnection, parent_instance) - 0usize];
    ["Offset of field: _GTcpWrapperConnection::priv_"]
        [::std::mem::offset_of!(_GTcpWrapperConnection, priv_) - 48usize];
};
unsafe extern "C" {
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tcp_wrapper_connection_new(
        base_io_stream: *mut GIOStream,
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
unsafe extern "C" {
    pub fn g_tcp_wrapper_connection_get_base_io_stream(
        conn: *mut GTcpWrapperConnection,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_test_dbus_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
}
unsafe extern "C" {
    pub fn g_test_dbus_get_flags(self_: *mut GTestDBus) -> GTestDBusFlags;
}
unsafe extern "C" {
    pub fn g_test_dbus_get_bus_address(self_: *mut GTestDBus) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_test_dbus_add_service_dir(self_: *mut GTestDBus, path: *const gchar);
}
unsafe extern "C" {
    pub fn g_test_dbus_up(self_: *mut GTestDBus);
}
unsafe extern "C" {
    pub fn g_test_dbus_stop(self_: *mut GTestDBus);
}
unsafe extern "C" {
    pub fn g_test_dbus_down(self_: *mut GTestDBus);
}
unsafe extern "C" {
    pub fn g_test_dbus_unset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIconClass {
    _unused: [u8; 0],
}
pub type GThemedIconClass = _GThemedIconClass;
unsafe extern "C" {
    pub fn g_themed_icon_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_themed_icon_new(iconname: *const ::std::os::raw::c_char) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_themed_icon_new_with_default_fallbacks(
        iconname: *const ::std::os::raw::c_char,
    ) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_themed_icon_new_from_names(
        iconnames: *mut *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_themed_icon_prepend_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_themed_icon_append_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon) -> *const *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate;
pub type GThreadedSocketServiceClass = _GThreadedSocketServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GThreadedSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadedSocketServiceClass"]
        [::std::mem::size_of::<_GThreadedSocketServiceClass>() - 296usize];
    ["Alignment of _GThreadedSocketServiceClass"]
        [::std::mem::align_of::<_GThreadedSocketServiceClass>() - 8usize];
    ["Offset of field: _GThreadedSocketServiceClass::parent_class"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, parent_class) - 0usize];
    ["Offset of field: _GThreadedSocketServiceClass::run"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, run) - 248usize];
    ["Offset of field: _GThreadedSocketServiceClass::_g_reserved1"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, _g_reserved1) - 256usize];
    ["Offset of field: _GThreadedSocketServiceClass::_g_reserved2"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, _g_reserved2) - 264usize];
    ["Offset of field: _GThreadedSocketServiceClass::_g_reserved3"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, _g_reserved3) - 272usize];
    ["Offset of field: _GThreadedSocketServiceClass::_g_reserved4"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, _g_reserved4) - 280usize];
    ["Offset of field: _GThreadedSocketServiceClass::_g_reserved5"]
        [::std::mem::offset_of!(_GThreadedSocketServiceClass, _g_reserved5) - 288usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub priv_: *mut GThreadedSocketServicePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GThreadedSocketService"][::std::mem::size_of::<_GThreadedSocketService>() - 48usize];
    ["Alignment of _GThreadedSocketService"]
        [::std::mem::align_of::<_GThreadedSocketService>() - 8usize];
    ["Offset of field: _GThreadedSocketService::parent_instance"]
        [::std::mem::offset_of!(_GThreadedSocketService, parent_instance) - 0usize];
    ["Offset of field: _GThreadedSocketService::priv_"]
        [::std::mem::offset_of!(_GThreadedSocketService, priv_) - 40usize];
};
unsafe extern "C" {
    pub fn g_threaded_socket_service_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_threaded_socket_service_new(max_threads: ::std::os::raw::c_int)
        -> *mut GSocketService;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackend {
    _unused: [u8; 0],
}
pub type GTlsBackend = _GTlsBackend;
#[doc = " GTlsBackendInterface:\n @g_iface: The parent interface.\n @supports_tls: returns whether the backend supports TLS.\n @supports_dtls: returns whether the backend supports DTLS\n @get_default_database: returns a default #GTlsDatabase instance.\n @get_certificate_type: returns the #GTlsCertificate implementation type\n @get_client_connection_type: returns the #GTlsClientConnection implementation type\n @get_server_connection_type: returns the #GTlsServerConnection implementation type\n @get_file_database_type: returns the #GTlsFileDatabase implementation type.\n @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type\n @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type\n\n Provides an interface for describing TLS-related types.\n\n Since: 2.28"]
pub type GTlsBackendInterface = _GTlsBackendInterface;
#[doc = " GTlsBackendInterface:\n @g_iface: The parent interface.\n @supports_tls: returns whether the backend supports TLS.\n @supports_dtls: returns whether the backend supports DTLS\n @get_default_database: returns a default #GTlsDatabase instance.\n @get_certificate_type: returns the #GTlsCertificate implementation type\n @get_client_connection_type: returns the #GTlsClientConnection implementation type\n @get_server_connection_type: returns the #GTlsServerConnection implementation type\n @get_file_database_type: returns the #GTlsFileDatabase implementation type.\n @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type\n @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type\n\n Provides an interface for describing TLS-related types.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackendInterface {
    pub g_iface: GTypeInterface,
    pub supports_tls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_certificate_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_file_database_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_default_database:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> *mut GTlsDatabase>,
    pub supports_dtls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_dtls_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_dtls_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsBackendInterface"][::std::mem::size_of::<_GTlsBackendInterface>() - 88usize];
    ["Alignment of _GTlsBackendInterface"]
        [::std::mem::align_of::<_GTlsBackendInterface>() - 8usize];
    ["Offset of field: _GTlsBackendInterface::g_iface"]
        [::std::mem::offset_of!(_GTlsBackendInterface, g_iface) - 0usize];
    ["Offset of field: _GTlsBackendInterface::supports_tls"]
        [::std::mem::offset_of!(_GTlsBackendInterface, supports_tls) - 16usize];
    ["Offset of field: _GTlsBackendInterface::get_certificate_type"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_certificate_type) - 24usize];
    ["Offset of field: _GTlsBackendInterface::get_client_connection_type"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_client_connection_type) - 32usize];
    ["Offset of field: _GTlsBackendInterface::get_server_connection_type"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_server_connection_type) - 40usize];
    ["Offset of field: _GTlsBackendInterface::get_file_database_type"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_file_database_type) - 48usize];
    ["Offset of field: _GTlsBackendInterface::get_default_database"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_default_database) - 56usize];
    ["Offset of field: _GTlsBackendInterface::supports_dtls"]
        [::std::mem::offset_of!(_GTlsBackendInterface, supports_dtls) - 64usize];
    ["Offset of field: _GTlsBackendInterface::get_dtls_client_connection_type"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_dtls_client_connection_type) - 72usize];
    ["Offset of field: _GTlsBackendInterface::get_dtls_server_connection_type"]
        [::std::mem::offset_of!(_GTlsBackendInterface, get_dtls_server_connection_type) - 80usize];
};
unsafe extern "C" {
    pub fn g_tls_backend_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend) -> *mut GTlsDatabase;
}
unsafe extern "C" {
    pub fn g_tls_backend_set_default_database(
        backend: *mut GTlsBackend,
        database: *mut GTlsDatabase,
    );
}
unsafe extern "C" {
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_backend_supports_dtls(backend: *mut GTlsBackend) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend) -> GType;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend) -> GType;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_dtls_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
unsafe extern "C" {
    pub fn g_tls_backend_get_dtls_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
pub type GTlsCertificateClass = _GTlsCertificateClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificatePrivate {
    _unused: [u8; 0],
}
pub type GTlsCertificatePrivate = _GTlsCertificatePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificate {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsCertificatePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsCertificate"][::std::mem::size_of::<_GTlsCertificate>() - 32usize];
    ["Alignment of _GTlsCertificate"][::std::mem::align_of::<_GTlsCertificate>() - 8usize];
    ["Offset of field: _GTlsCertificate::parent_instance"]
        [::std::mem::offset_of!(_GTlsCertificate, parent_instance) - 0usize];
    ["Offset of field: _GTlsCertificate::priv_"]
        [::std::mem::offset_of!(_GTlsCertificate, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificateClass {
    pub parent_class: GObjectClass,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            cert: *mut GTlsCertificate,
            identity: *mut GSocketConnectable,
            trusted_ca: *mut GTlsCertificate,
        ) -> GTlsCertificateFlags,
    >,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsCertificateClass"][::std::mem::size_of::<_GTlsCertificateClass>() - 208usize];
    ["Alignment of _GTlsCertificateClass"]
        [::std::mem::align_of::<_GTlsCertificateClass>() - 8usize];
    ["Offset of field: _GTlsCertificateClass::parent_class"]
        [::std::mem::offset_of!(_GTlsCertificateClass, parent_class) - 0usize];
    ["Offset of field: _GTlsCertificateClass::verify"]
        [::std::mem::offset_of!(_GTlsCertificateClass, verify) - 136usize];
    ["Offset of field: _GTlsCertificateClass::padding"]
        [::std::mem::offset_of!(_GTlsCertificateClass, padding) - 144usize];
};
unsafe extern "C" {
    pub fn g_tls_certificate_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_certificate_new_from_pem(
        data: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_new_from_pkcs12(
        data: *const guint8,
        length: gsize,
        password: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_new_from_file_with_password(
        file: *const gchar,
        password: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_new_from_files(
        cert_file: *const gchar,
        key_file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_new_from_pkcs11_uris(
        pkcs11_uri: *const gchar,
        private_key_pkcs11_uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_list_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_certificate_verify(
        cert: *mut GTlsCertificate,
        identity: *mut GSocketConnectable,
        trusted_ca: *mut GTlsCertificate,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_tls_certificate_is_same(
        cert_one: *mut GTlsCertificate,
        cert_two: *mut GTlsCertificate,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_not_valid_before(cert: *mut GTlsCertificate) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_not_valid_after(cert: *mut GTlsCertificate) -> *mut GDateTime;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_subject_name(cert: *mut GTlsCertificate) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_issuer_name(cert: *mut GTlsCertificate) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_dns_names(cert: *mut GTlsCertificate) -> *mut GPtrArray;
}
unsafe extern "C" {
    pub fn g_tls_certificate_get_ip_addresses(cert: *mut GTlsCertificate) -> *mut GPtrArray;
}
#[doc = " GTlsConnectionClass:\n @parent_class: The parent class.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)\n\n The class structure for the #GTlsConnection type.\n\n Since: 2.28"]
pub type GTlsConnectionClass = _GTlsConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTlsConnectionPrivate = _GTlsConnectionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GTlsConnectionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsConnection"][::std::mem::size_of::<_GTlsConnection>() - 40usize];
    ["Alignment of _GTlsConnection"][::std::mem::align_of::<_GTlsConnection>() - 8usize];
    ["Offset of field: _GTlsConnection::parent_instance"]
        [::std::mem::offset_of!(_GTlsConnection, parent_instance) - 0usize];
    ["Offset of field: _GTlsConnection::priv_"]
        [::std::mem::offset_of!(_GTlsConnection, priv_) - 32usize];
};
#[doc = " GTlsConnectionClass:\n @parent_class: The parent class.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)\n\n The class structure for the #GTlsConnection type.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GTlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_binding_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            type_: GTlsChannelBindingType,
            data: *mut GByteArray,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_negotiated_protocol:
        ::std::option::Option<unsafe extern "C" fn(conn: *mut GTlsConnection) -> *const gchar>,
    pub padding: [gpointer; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsConnectionClass"][::std::mem::size_of::<_GTlsConnectionClass>() - 352usize];
    ["Alignment of _GTlsConnectionClass"][::std::mem::align_of::<_GTlsConnectionClass>() - 8usize];
    ["Offset of field: _GTlsConnectionClass::parent_class"]
        [::std::mem::offset_of!(_GTlsConnectionClass, parent_class) - 0usize];
    ["Offset of field: _GTlsConnectionClass::accept_certificate"]
        [::std::mem::offset_of!(_GTlsConnectionClass, accept_certificate) - 256usize];
    ["Offset of field: _GTlsConnectionClass::handshake"]
        [::std::mem::offset_of!(_GTlsConnectionClass, handshake) - 264usize];
    ["Offset of field: _GTlsConnectionClass::handshake_async"]
        [::std::mem::offset_of!(_GTlsConnectionClass, handshake_async) - 272usize];
    ["Offset of field: _GTlsConnectionClass::handshake_finish"]
        [::std::mem::offset_of!(_GTlsConnectionClass, handshake_finish) - 280usize];
    ["Offset of field: _GTlsConnectionClass::get_binding_data"]
        [::std::mem::offset_of!(_GTlsConnectionClass, get_binding_data) - 288usize];
    ["Offset of field: _GTlsConnectionClass::get_negotiated_protocol"]
        [::std::mem::offset_of!(_GTlsConnectionClass, get_negotiated_protocol) - 296usize];
    ["Offset of field: _GTlsConnectionClass::padding"]
        [::std::mem::offset_of!(_GTlsConnectionClass, padding) - 304usize];
};
unsafe extern "C" {
    pub fn g_tls_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_use_system_certdb(
        conn: *mut GTlsConnection,
        use_system_certdb: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection, database: *mut GTlsDatabase);
}
unsafe extern "C" {
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection) -> *mut GTlsDatabase;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_certificate(
        conn: *mut GTlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_interaction(
        conn: *mut GTlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection) -> *mut GTlsInteraction;
}
unsafe extern "C" {
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection)
        -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_connection_get_peer_certificate_errors(
        conn: *mut GTlsConnection,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_require_close_notify(
        conn: *mut GTlsConnection,
        require_close_notify: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_get_require_close_notify(conn: *mut GTlsConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_rehandshake_mode(
        conn: *mut GTlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection) -> GTlsRehandshakeMode;
}
unsafe extern "C" {
    pub fn g_tls_connection_set_advertised_protocols(
        conn: *mut GTlsConnection,
        protocols: *const *const gchar,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_get_negotiated_protocol(conn: *mut GTlsConnection) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_tls_connection_get_channel_binding_data(
        conn: *mut GTlsConnection,
        type_: GTlsChannelBindingType,
        data: *mut GByteArray,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_connection_handshake(
        conn: *mut GTlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_connection_handshake_async(
        conn: *mut GTlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_connection_handshake_finish(
        conn: *mut GTlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_connection_get_protocol_version(conn: *mut GTlsConnection) -> GTlsProtocolVersion;
}
unsafe extern "C" {
    pub fn g_tls_connection_get_ciphersuite_name(conn: *mut GTlsConnection) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_tls_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_tls_channel_binding_error_quark() -> GQuark;
}
unsafe extern "C" {
    pub fn g_tls_connection_emit_accept_certificate(
        conn: *mut GTlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
#[doc = " GTlsClientConnectionInterface:\n @g_iface: The parent interface.\n @copy_session_state: Copies session state from one #GTlsClientConnection to another.\n\n vtable for a #GTlsClientConnection implementation.\n\n Since: 2.26"]
pub type GTlsClientConnectionInterface = _GTlsClientConnectionInterface;
#[doc = " GTlsClientConnectionInterface:\n @g_iface: The parent interface.\n @copy_session_state: Copies session state from one #GTlsClientConnection to another.\n\n vtable for a #GTlsClientConnection implementation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
    pub copy_session_state: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GTlsClientConnection, source: *mut GTlsClientConnection),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsClientConnectionInterface"]
        [::std::mem::size_of::<_GTlsClientConnectionInterface>() - 24usize];
    ["Alignment of _GTlsClientConnectionInterface"]
        [::std::mem::align_of::<_GTlsClientConnectionInterface>() - 8usize];
    ["Offset of field: _GTlsClientConnectionInterface::g_iface"]
        [::std::mem::offset_of!(_GTlsClientConnectionInterface, g_iface) - 0usize];
    ["Offset of field: _GTlsClientConnectionInterface::copy_session_state"]
        [::std::mem::offset_of!(_GTlsClientConnectionInterface, copy_session_state) - 16usize];
};
unsafe extern "C" {
    pub fn g_tls_client_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_client_connection_new(
        base_io_stream: *mut GIOStream,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
unsafe extern "C" {
    pub fn g_tls_client_connection_get_validation_flags(
        conn: *mut GTlsClientConnection,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_tls_client_connection_set_validation_flags(
        conn: *mut GTlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
unsafe extern "C" {
    pub fn g_tls_client_connection_get_server_identity(
        conn: *mut GTlsClientConnection,
    ) -> *mut GSocketConnectable;
}
unsafe extern "C" {
    pub fn g_tls_client_connection_set_server_identity(
        conn: *mut GTlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
unsafe extern "C" {
    pub fn g_tls_client_connection_get_use_ssl3(conn: *mut GTlsClientConnection) -> gboolean;
}
unsafe extern "C" {
    pub fn g_tls_client_connection_set_use_ssl3(
        conn: *mut GTlsClientConnection,
        use_ssl3: gboolean,
    );
}
unsafe extern "C" {
    pub fn g_tls_client_connection_get_accepted_cas(conn: *mut GTlsClientConnection) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_tls_client_connection_copy_session_state(
        conn: *mut GTlsClientConnection,
        source: *mut GTlsClientConnection,
    );
}
pub type GTlsDatabaseClass = _GTlsDatabaseClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabasePrivate {
    _unused: [u8; 0],
}
pub type GTlsDatabasePrivate = _GTlsDatabasePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabase {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsDatabasePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsDatabase"][::std::mem::size_of::<_GTlsDatabase>() - 32usize];
    ["Alignment of _GTlsDatabase"][::std::mem::align_of::<_GTlsDatabase>() - 8usize];
    ["Offset of field: _GTlsDatabase::parent_instance"]
        [::std::mem::offset_of!(_GTlsDatabase, parent_instance) - 0usize];
    ["Offset of field: _GTlsDatabase::priv_"]
        [::std::mem::offset_of!(_GTlsDatabase, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabaseClass {
    pub parent_class: GObjectClass,
    pub verify_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub verify_chain_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub verify_chain_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub create_certificate_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
        ) -> *mut gchar,
    >,
    pub lookup_certificate_for_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_for_handle_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_for_handle_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_issuer_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificates_issued_by: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_certificates_issued_by_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificates_issued_by_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub padding: [gpointer; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsDatabaseClass"][::std::mem::size_of::<_GTlsDatabaseClass>() - 368usize];
    ["Alignment of _GTlsDatabaseClass"][::std::mem::align_of::<_GTlsDatabaseClass>() - 8usize];
    ["Offset of field: _GTlsDatabaseClass::parent_class"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, parent_class) - 0usize];
    ["Offset of field: _GTlsDatabaseClass::verify_chain"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, verify_chain) - 136usize];
    ["Offset of field: _GTlsDatabaseClass::verify_chain_async"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, verify_chain_async) - 144usize];
    ["Offset of field: _GTlsDatabaseClass::verify_chain_finish"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, verify_chain_finish) - 152usize];
    ["Offset of field: _GTlsDatabaseClass::create_certificate_handle"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, create_certificate_handle) - 160usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificate_for_handle"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, lookup_certificate_for_handle) - 168usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificate_for_handle_async"][::std::mem::offset_of!(
        _GTlsDatabaseClass,
        lookup_certificate_for_handle_async
    ) - 176usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificate_for_handle_finish"][::std::mem::offset_of!(
        _GTlsDatabaseClass,
        lookup_certificate_for_handle_finish
    ) - 184usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificate_issuer"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, lookup_certificate_issuer) - 192usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificate_issuer_async"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, lookup_certificate_issuer_async) - 200usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificate_issuer_finish"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, lookup_certificate_issuer_finish) - 208usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificates_issued_by"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, lookup_certificates_issued_by) - 216usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificates_issued_by_async"][::std::mem::offset_of!(
        _GTlsDatabaseClass,
        lookup_certificates_issued_by_async
    ) - 224usize];
    ["Offset of field: _GTlsDatabaseClass::lookup_certificates_issued_by_finish"][::std::mem::offset_of!(
        _GTlsDatabaseClass,
        lookup_certificates_issued_by_finish
    ) - 232usize];
    ["Offset of field: _GTlsDatabaseClass::padding"]
        [::std::mem::offset_of!(_GTlsDatabaseClass, padding) - 240usize];
};
unsafe extern "C" {
    pub fn g_tls_database_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_database_verify_chain(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_tls_database_verify_chain_async(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_database_verify_chain_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
unsafe extern "C" {
    pub fn g_tls_database_create_certificate_handle(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
    ) -> *mut gchar;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle_async(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer_async(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by_async(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
#[doc = " GTlsFileDatabaseInterface:\n @g_iface: The parent interface.\n\n Provides an interface for #GTlsFileDatabase implementations.\n"]
pub type GTlsFileDatabaseInterface = _GTlsFileDatabaseInterface;
#[doc = " GTlsFileDatabaseInterface:\n @g_iface: The parent interface.\n\n Provides an interface for #GTlsFileDatabase implementations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabaseInterface {
    pub g_iface: GTypeInterface,
    pub padding: [gpointer; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsFileDatabaseInterface"]
        [::std::mem::size_of::<_GTlsFileDatabaseInterface>() - 80usize];
    ["Alignment of _GTlsFileDatabaseInterface"]
        [::std::mem::align_of::<_GTlsFileDatabaseInterface>() - 8usize];
    ["Offset of field: _GTlsFileDatabaseInterface::g_iface"]
        [::std::mem::offset_of!(_GTlsFileDatabaseInterface, g_iface) - 0usize];
    ["Offset of field: _GTlsFileDatabaseInterface::padding"]
        [::std::mem::offset_of!(_GTlsFileDatabaseInterface, padding) - 16usize];
};
unsafe extern "C" {
    pub fn g_tls_file_database_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_file_database_new(
        anchors: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsDatabase;
}
pub type GTlsInteractionClass = _GTlsInteractionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionPrivate {
    _unused: [u8; 0],
}
pub type GTlsInteractionPrivate = _GTlsInteractionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteraction {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsInteractionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsInteraction"][::std::mem::size_of::<_GTlsInteraction>() - 32usize];
    ["Alignment of _GTlsInteraction"][::std::mem::align_of::<_GTlsInteraction>() - 8usize];
    ["Offset of field: _GTlsInteraction::parent_instance"]
        [::std::mem::offset_of!(_GTlsInteraction, parent_instance) - 0usize];
    ["Offset of field: _GTlsInteraction::priv_"]
        [::std::mem::offset_of!(_GTlsInteraction, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub ask_password_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub ask_password_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub request_certificate_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub padding: [gpointer; 21usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsInteractionClass"][::std::mem::size_of::<_GTlsInteractionClass>() - 352usize];
    ["Alignment of _GTlsInteractionClass"]
        [::std::mem::align_of::<_GTlsInteractionClass>() - 8usize];
    ["Offset of field: _GTlsInteractionClass::parent_class"]
        [::std::mem::offset_of!(_GTlsInteractionClass, parent_class) - 0usize];
    ["Offset of field: _GTlsInteractionClass::ask_password"]
        [::std::mem::offset_of!(_GTlsInteractionClass, ask_password) - 136usize];
    ["Offset of field: _GTlsInteractionClass::ask_password_async"]
        [::std::mem::offset_of!(_GTlsInteractionClass, ask_password_async) - 144usize];
    ["Offset of field: _GTlsInteractionClass::ask_password_finish"]
        [::std::mem::offset_of!(_GTlsInteractionClass, ask_password_finish) - 152usize];
    ["Offset of field: _GTlsInteractionClass::request_certificate"]
        [::std::mem::offset_of!(_GTlsInteractionClass, request_certificate) - 160usize];
    ["Offset of field: _GTlsInteractionClass::request_certificate_async"]
        [::std::mem::offset_of!(_GTlsInteractionClass, request_certificate_async) - 168usize];
    ["Offset of field: _GTlsInteractionClass::request_certificate_finish"]
        [::std::mem::offset_of!(_GTlsInteractionClass, request_certificate_finish) - 176usize];
    ["Offset of field: _GTlsInteractionClass::padding"]
        [::std::mem::offset_of!(_GTlsInteractionClass, padding) - 184usize];
};
unsafe extern "C" {
    pub fn g_tls_interaction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_interaction_invoke_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
unsafe extern "C" {
    pub fn g_tls_interaction_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
unsafe extern "C" {
    pub fn g_tls_interaction_ask_password_async(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_interaction_ask_password_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
unsafe extern "C" {
    pub fn g_tls_interaction_invoke_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
unsafe extern "C" {
    pub fn g_tls_interaction_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
unsafe extern "C" {
    pub fn g_tls_interaction_request_certificate_async(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_tls_interaction_request_certificate_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
#[doc = " GTlsPasswordClass:\n @get_value: virtual method for g_tls_password_get_value()\n @set_value: virtual method for g_tls_password_set_value()\n @get_default_warning: virtual method for g_tls_password_get_warning() if no\n  value has been set using g_tls_password_set_warning()\n\n Class structure for #GTlsPassword."]
pub type GTlsPasswordClass = _GTlsPasswordClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordPrivate {
    _unused: [u8; 0],
}
pub type GTlsPasswordPrivate = _GTlsPasswordPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPassword {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsPasswordPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsPassword"][::std::mem::size_of::<_GTlsPassword>() - 32usize];
    ["Alignment of _GTlsPassword"][::std::mem::align_of::<_GTlsPassword>() - 8usize];
    ["Offset of field: _GTlsPassword::parent_instance"]
        [::std::mem::offset_of!(_GTlsPassword, parent_instance) - 0usize];
    ["Offset of field: _GTlsPassword::priv_"]
        [::std::mem::offset_of!(_GTlsPassword, priv_) - 24usize];
};
#[doc = " GTlsPasswordClass:\n @get_value: virtual method for g_tls_password_get_value()\n @set_value: virtual method for g_tls_password_set_value()\n @get_default_warning: virtual method for g_tls_password_get_warning() if no\n  value has been set using g_tls_password_set_warning()\n\n Class structure for #GTlsPassword."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordClass {
    pub parent_class: GObjectClass,
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(password: *mut GTlsPassword, length: *mut gsize) -> *const guchar,
    >,
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            password: *mut GTlsPassword,
            value: *mut guchar,
            length: gssize,
            destroy: GDestroyNotify,
        ),
    >,
    pub get_default_warning:
        ::std::option::Option<unsafe extern "C" fn(password: *mut GTlsPassword) -> *const gchar>,
    pub padding: [gpointer; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsPasswordClass"][::std::mem::size_of::<_GTlsPasswordClass>() - 192usize];
    ["Alignment of _GTlsPasswordClass"][::std::mem::align_of::<_GTlsPasswordClass>() - 8usize];
    ["Offset of field: _GTlsPasswordClass::parent_class"]
        [::std::mem::offset_of!(_GTlsPasswordClass, parent_class) - 0usize];
    ["Offset of field: _GTlsPasswordClass::get_value"]
        [::std::mem::offset_of!(_GTlsPasswordClass, get_value) - 136usize];
    ["Offset of field: _GTlsPasswordClass::set_value"]
        [::std::mem::offset_of!(_GTlsPasswordClass, set_value) - 144usize];
    ["Offset of field: _GTlsPasswordClass::get_default_warning"]
        [::std::mem::offset_of!(_GTlsPasswordClass, get_default_warning) - 152usize];
    ["Offset of field: _GTlsPasswordClass::padding"]
        [::std::mem::offset_of!(_GTlsPasswordClass, padding) - 160usize];
};
unsafe extern "C" {
    pub fn g_tls_password_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_password_new(
        flags: GTlsPasswordFlags,
        description: *const gchar,
    ) -> *mut GTlsPassword;
}
unsafe extern "C" {
    pub fn g_tls_password_get_value(
        password: *mut GTlsPassword,
        length: *mut gsize,
    ) -> *const guchar;
}
unsafe extern "C" {
    pub fn g_tls_password_set_value(
        password: *mut GTlsPassword,
        value: *const guchar,
        length: gssize,
    );
}
unsafe extern "C" {
    pub fn g_tls_password_set_value_full(
        password: *mut GTlsPassword,
        value: *mut guchar,
        length: gssize,
        destroy: GDestroyNotify,
    );
}
unsafe extern "C" {
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword) -> GTlsPasswordFlags;
}
unsafe extern "C" {
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword, flags: GTlsPasswordFlags);
}
unsafe extern "C" {
    pub fn g_tls_password_get_description(password: *mut GTlsPassword) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_tls_password_set_description(password: *mut GTlsPassword, description: *const gchar);
}
unsafe extern "C" {
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword) -> *const gchar;
}
unsafe extern "C" {
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword, warning: *const gchar);
}
#[doc = " GTlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GTlsServerConnection implementation.\n\n Since: 2.26"]
pub type GTlsServerConnectionInterface = _GTlsServerConnectionInterface;
#[doc = " GTlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GTlsServerConnection implementation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GTlsServerConnectionInterface"]
        [::std::mem::size_of::<_GTlsServerConnectionInterface>() - 16usize];
    ["Alignment of _GTlsServerConnectionInterface"]
        [::std::mem::align_of::<_GTlsServerConnectionInterface>() - 8usize];
    ["Offset of field: _GTlsServerConnectionInterface::g_iface"]
        [::std::mem::offset_of!(_GTlsServerConnectionInterface, g_iface) - 0usize];
};
unsafe extern "C" {
    pub fn g_tls_server_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_tls_server_connection_new(
        base_io_stream: *mut GIOStream,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
pub type GUnixConnection = _GUnixConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnectionPrivate {
    _unused: [u8; 0],
}
pub type GUnixConnectionPrivate = _GUnixConnectionPrivate;
pub type GUnixConnectionClass = _GUnixConnectionClass;
pub type GUnixConnection_autoptr = *mut GUnixConnection;
pub type GUnixConnection_listautoptr = *mut GList;
pub type GUnixConnection_slistautoptr = *mut GSList;
pub type GUnixConnection_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixConnectionClass"][::std::mem::size_of::<_GUnixConnectionClass>() - 304usize];
    ["Alignment of _GUnixConnectionClass"]
        [::std::mem::align_of::<_GUnixConnectionClass>() - 8usize];
    ["Offset of field: _GUnixConnectionClass::parent_class"]
        [::std::mem::offset_of!(_GUnixConnectionClass, parent_class) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GUnixConnectionPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixConnection"][::std::mem::size_of::<_GUnixConnection>() - 48usize];
    ["Alignment of _GUnixConnection"][::std::mem::align_of::<_GUnixConnection>() - 8usize];
    ["Offset of field: _GUnixConnection::parent_instance"]
        [::std::mem::offset_of!(_GUnixConnection, parent_instance) - 0usize];
    ["Offset of field: _GUnixConnection::priv_"]
        [::std::mem::offset_of!(_GUnixConnection, priv_) - 40usize];
};
unsafe extern "C" {
    pub fn g_unix_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unix_connection_send_fd(
        connection: *mut GUnixConnection,
        fd: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unix_connection_receive_fd(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_unix_connection_send_credentials(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unix_connection_send_credentials_async(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_unix_connection_send_credentials_finish(
        connection: *mut GUnixConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unix_connection_receive_credentials(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
unsafe extern "C" {
    pub fn g_unix_connection_receive_credentials_async(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_unix_connection_receive_credentials_finish(
        connection: *mut GUnixConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessagePrivate {
    _unused: [u8; 0],
}
pub type GUnixCredentialsMessagePrivate = _GUnixCredentialsMessagePrivate;
#[doc = " GUnixCredentialsMessageClass:\n\n Class structure for #GUnixCredentialsMessage.\n\n Since: 2.26"]
pub type GUnixCredentialsMessageClass = _GUnixCredentialsMessageClass;
pub type GUnixCredentialsMessage_autoptr = *mut GUnixCredentialsMessage;
pub type GUnixCredentialsMessage_listautoptr = *mut GList;
pub type GUnixCredentialsMessage_slistautoptr = *mut GSList;
pub type GUnixCredentialsMessage_queueautoptr = *mut GQueue;
#[doc = " GUnixCredentialsMessageClass:\n\n Class structure for #GUnixCredentialsMessage.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessageClass {
    pub parent_class: GSocketControlMessageClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixCredentialsMessageClass"]
        [::std::mem::size_of::<_GUnixCredentialsMessageClass>() - 232usize];
    ["Alignment of _GUnixCredentialsMessageClass"]
        [::std::mem::align_of::<_GUnixCredentialsMessageClass>() - 8usize];
    ["Offset of field: _GUnixCredentialsMessageClass::parent_class"]
        [::std::mem::offset_of!(_GUnixCredentialsMessageClass, parent_class) - 0usize];
    ["Offset of field: _GUnixCredentialsMessageClass::_g_reserved1"]
        [::std::mem::offset_of!(_GUnixCredentialsMessageClass, _g_reserved1) - 216usize];
    ["Offset of field: _GUnixCredentialsMessageClass::_g_reserved2"]
        [::std::mem::offset_of!(_GUnixCredentialsMessageClass, _g_reserved2) - 224usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessage {
    pub parent_instance: GSocketControlMessage,
    pub priv_: *mut GUnixCredentialsMessagePrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixCredentialsMessage"]
        [::std::mem::size_of::<_GUnixCredentialsMessage>() - 40usize];
    ["Alignment of _GUnixCredentialsMessage"]
        [::std::mem::align_of::<_GUnixCredentialsMessage>() - 8usize];
    ["Offset of field: _GUnixCredentialsMessage::parent_instance"]
        [::std::mem::offset_of!(_GUnixCredentialsMessage, parent_instance) - 0usize];
    ["Offset of field: _GUnixCredentialsMessage::priv_"]
        [::std::mem::offset_of!(_GUnixCredentialsMessage, priv_) - 32usize];
};
unsafe extern "C" {
    pub fn g_unix_credentials_message_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unix_credentials_message_new() -> *mut GSocketControlMessage;
}
unsafe extern "C" {
    pub fn g_unix_credentials_message_new_with_credentials(
        credentials: *mut GCredentials,
    ) -> *mut GSocketControlMessage;
}
unsafe extern "C" {
    pub fn g_unix_credentials_message_get_credentials(
        message: *mut GUnixCredentialsMessage,
    ) -> *mut GCredentials;
}
unsafe extern "C" {
    pub fn g_unix_credentials_message_is_supported() -> gboolean;
}
pub type GUnixFDList_autoptr = *mut GUnixFDList;
pub type GUnixFDList_listautoptr = *mut GList;
pub type GUnixFDList_slistautoptr = *mut GSList;
pub type GUnixFDList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDListPrivate {
    _unused: [u8; 0],
}
pub type GUnixFDListPrivate = _GUnixFDListPrivate;
pub type GUnixFDListClass = _GUnixFDListClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDListClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixFDListClass"][::std::mem::size_of::<_GUnixFDListClass>() - 176usize];
    ["Alignment of _GUnixFDListClass"][::std::mem::align_of::<_GUnixFDListClass>() - 8usize];
    ["Offset of field: _GUnixFDListClass::parent_class"]
        [::std::mem::offset_of!(_GUnixFDListClass, parent_class) - 0usize];
    ["Offset of field: _GUnixFDListClass::_g_reserved1"]
        [::std::mem::offset_of!(_GUnixFDListClass, _g_reserved1) - 136usize];
    ["Offset of field: _GUnixFDListClass::_g_reserved2"]
        [::std::mem::offset_of!(_GUnixFDListClass, _g_reserved2) - 144usize];
    ["Offset of field: _GUnixFDListClass::_g_reserved3"]
        [::std::mem::offset_of!(_GUnixFDListClass, _g_reserved3) - 152usize];
    ["Offset of field: _GUnixFDListClass::_g_reserved4"]
        [::std::mem::offset_of!(_GUnixFDListClass, _g_reserved4) - 160usize];
    ["Offset of field: _GUnixFDListClass::_g_reserved5"]
        [::std::mem::offset_of!(_GUnixFDListClass, _g_reserved5) - 168usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDList {
    pub parent_instance: GObject,
    pub priv_: *mut GUnixFDListPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixFDList"][::std::mem::size_of::<_GUnixFDList>() - 32usize];
    ["Alignment of _GUnixFDList"][::std::mem::align_of::<_GUnixFDList>() - 8usize];
    ["Offset of field: _GUnixFDList::parent_instance"]
        [::std::mem::offset_of!(_GUnixFDList, parent_instance) - 0usize];
    ["Offset of field: _GUnixFDList::priv_"][::std::mem::offset_of!(_GUnixFDList, priv_) - 24usize];
};
unsafe extern "C" {
    pub fn g_unix_fd_list_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_new() -> *mut GUnixFDList;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_new_from_array(fds: *const gint, n_fds: gint) -> *mut GUnixFDList;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_append(list: *mut GUnixFDList, fd: gint, error: *mut *mut GError)
        -> gint;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_get_length(list: *mut GUnixFDList) -> gint;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_get(
        list: *mut GUnixFDList,
        index_: gint,
        error: *mut *mut GError,
    ) -> gint;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_peek_fds(list: *mut GUnixFDList, length: *mut gint) -> *const gint;
}
unsafe extern "C" {
    pub fn g_unix_fd_list_steal_fds(list: *mut GUnixFDList, length: *mut gint) -> *mut gint;
}
pub type GUnixSocketAddress = _GUnixSocketAddress;
pub type GUnixSocketAddressClass = _GUnixSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GUnixSocketAddressPrivate = _GUnixSocketAddressPrivate;
pub type GUnixSocketAddress_autoptr = *mut GUnixSocketAddress;
pub type GUnixSocketAddress_listautoptr = *mut GList;
pub type GUnixSocketAddress_slistautoptr = *mut GSList;
pub type GUnixSocketAddress_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GUnixSocketAddressPrivate,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixSocketAddress"][::std::mem::size_of::<_GUnixSocketAddress>() - 32usize];
    ["Alignment of _GUnixSocketAddress"][::std::mem::align_of::<_GUnixSocketAddress>() - 8usize];
    ["Offset of field: _GUnixSocketAddress::parent_instance"]
        [::std::mem::offset_of!(_GUnixSocketAddress, parent_instance) - 0usize];
    ["Offset of field: _GUnixSocketAddress::priv_"]
        [::std::mem::offset_of!(_GUnixSocketAddress, priv_) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GUnixSocketAddressClass"]
        [::std::mem::size_of::<_GUnixSocketAddressClass>() - 160usize];
    ["Alignment of _GUnixSocketAddressClass"]
        [::std::mem::align_of::<_GUnixSocketAddressClass>() - 8usize];
    ["Offset of field: _GUnixSocketAddressClass::parent_class"]
        [::std::mem::offset_of!(_GUnixSocketAddressClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_unix_socket_address_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_new(path: *const gchar) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_new_abstract(
        path: *const gchar,
        path_len: gint,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_new_with_type(
        path: *const gchar,
        path_len: gint,
        type_: GUnixSocketAddressType,
    ) -> *mut GSocketAddress;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_get_path(
        address: *mut GUnixSocketAddress,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_get_path_len(address: *mut GUnixSocketAddress) -> gsize;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_get_address_type(
        address: *mut GUnixSocketAddress,
    ) -> GUnixSocketAddressType;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_get_is_abstract(address: *mut GUnixSocketAddress) -> gboolean;
}
unsafe extern "C" {
    pub fn g_unix_socket_address_abstract_names_supported() -> gboolean;
}
#[doc = " GVfsFileLookupFunc:\n @vfs: a #GVfs\n @identifier: the identifier to look up a #GFile for. This can either\n     be an URI or a parse name as returned by g_file_get_parse_name()\n @user_data: user data passed to the function\n\n This function type is used by g_vfs_register_uri_scheme() to make it\n possible for a client to associate an URI scheme to a different #GFile\n implementation.\n\n The client should return a reference to the new file that has been\n created for @uri, or %NULL to continue with the default implementation.\n\n Returns: (transfer full): a #GFile for @identifier.\n\n Since: 2.50"]
pub type GVfsFileLookupFunc = ::std::option::Option<
    unsafe extern "C" fn(
        vfs: *mut GVfs,
        identifier: *const ::std::os::raw::c_char,
        user_data: gpointer,
    ) -> *mut GFile,
>;
pub type GVfsClass = _GVfsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVfs {
    pub parent_instance: GObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVfs"][::std::mem::size_of::<_GVfs>() - 24usize];
    ["Alignment of _GVfs"][::std::mem::align_of::<_GVfs>() - 8usize];
    ["Offset of field: _GVfs::parent_instance"]
        [::std::mem::offset_of!(_GVfs, parent_instance) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVfsClass {
    pub parent_class: GObjectClass,
    pub is_active: ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> gboolean>,
    pub get_file_for_path: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, path: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_file_for_uri: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_supported_uri_schemes:
        ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> *const *const gchar>,
    pub parse_name: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            parse_name: *const ::std::os::raw::c_char,
        ) -> *mut GFile,
    >,
    pub local_file_add_info: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            device: guint64,
            attribute_matcher: *mut GFileAttributeMatcher,
            info: *mut GFileInfo,
            cancellable: *mut GCancellable,
            extra_data: *mut gpointer,
            free_extra_data: *mut GDestroyNotify,
        ),
    >,
    pub add_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, list: *mut GFileAttributeInfoList),
    >,
    pub local_file_set_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub local_file_removed: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, filename: *const ::std::os::raw::c_char),
    >,
    pub local_file_moved: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            source: *const ::std::os::raw::c_char,
            dest: *const ::std::os::raw::c_char,
        ),
    >,
    pub deserialize_icon: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, value: *mut GVariant) -> *mut GIcon,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVfsClass"][::std::mem::size_of::<_GVfsClass>() - 272usize];
    ["Alignment of _GVfsClass"][::std::mem::align_of::<_GVfsClass>() - 8usize];
    ["Offset of field: _GVfsClass::parent_class"]
        [::std::mem::offset_of!(_GVfsClass, parent_class) - 0usize];
    ["Offset of field: _GVfsClass::is_active"]
        [::std::mem::offset_of!(_GVfsClass, is_active) - 136usize];
    ["Offset of field: _GVfsClass::get_file_for_path"]
        [::std::mem::offset_of!(_GVfsClass, get_file_for_path) - 144usize];
    ["Offset of field: _GVfsClass::get_file_for_uri"]
        [::std::mem::offset_of!(_GVfsClass, get_file_for_uri) - 152usize];
    ["Offset of field: _GVfsClass::get_supported_uri_schemes"]
        [::std::mem::offset_of!(_GVfsClass, get_supported_uri_schemes) - 160usize];
    ["Offset of field: _GVfsClass::parse_name"]
        [::std::mem::offset_of!(_GVfsClass, parse_name) - 168usize];
    ["Offset of field: _GVfsClass::local_file_add_info"]
        [::std::mem::offset_of!(_GVfsClass, local_file_add_info) - 176usize];
    ["Offset of field: _GVfsClass::add_writable_namespaces"]
        [::std::mem::offset_of!(_GVfsClass, add_writable_namespaces) - 184usize];
    ["Offset of field: _GVfsClass::local_file_set_attributes"]
        [::std::mem::offset_of!(_GVfsClass, local_file_set_attributes) - 192usize];
    ["Offset of field: _GVfsClass::local_file_removed"]
        [::std::mem::offset_of!(_GVfsClass, local_file_removed) - 200usize];
    ["Offset of field: _GVfsClass::local_file_moved"]
        [::std::mem::offset_of!(_GVfsClass, local_file_moved) - 208usize];
    ["Offset of field: _GVfsClass::deserialize_icon"]
        [::std::mem::offset_of!(_GVfsClass, deserialize_icon) - 216usize];
    ["Offset of field: _GVfsClass::_g_reserved1"]
        [::std::mem::offset_of!(_GVfsClass, _g_reserved1) - 224usize];
    ["Offset of field: _GVfsClass::_g_reserved2"]
        [::std::mem::offset_of!(_GVfsClass, _g_reserved2) - 232usize];
    ["Offset of field: _GVfsClass::_g_reserved3"]
        [::std::mem::offset_of!(_GVfsClass, _g_reserved3) - 240usize];
    ["Offset of field: _GVfsClass::_g_reserved4"]
        [::std::mem::offset_of!(_GVfsClass, _g_reserved4) - 248usize];
    ["Offset of field: _GVfsClass::_g_reserved5"]
        [::std::mem::offset_of!(_GVfsClass, _g_reserved5) - 256usize];
    ["Offset of field: _GVfsClass::_g_reserved6"]
        [::std::mem::offset_of!(_GVfsClass, _g_reserved6) - 264usize];
};
unsafe extern "C" {
    pub fn g_vfs_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
}
unsafe extern "C" {
    pub fn g_vfs_get_file_for_path(
        vfs: *mut GVfs,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char)
        -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs) -> *const *const gchar;
}
unsafe extern "C" {
    pub fn g_vfs_parse_name(
        vfs: *mut GVfs,
        parse_name: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_vfs_get_default() -> *mut GVfs;
}
unsafe extern "C" {
    pub fn g_vfs_get_local() -> *mut GVfs;
}
unsafe extern "C" {
    pub fn g_vfs_register_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
        uri_func: GVfsFileLookupFunc,
        uri_data: gpointer,
        uri_destroy: GDestroyNotify,
        parse_name_func: GVfsFileLookupFunc,
        parse_name_data: gpointer,
        parse_name_destroy: GDestroyNotify,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_vfs_unregister_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
#[doc = " GVolumeIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the volume's state has changed.\n @removed: The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.\n @get_name: Gets a string containing the name of the #GVolume.\n @get_icon: Gets a #GIcon for the #GVolume.\n @get_uuid: Gets the UUID for the #GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_drive: Gets a #GDrive the volume is located on. Returns %NULL if the #GVolume is not associated with a #GDrive.\n @get_mount: Gets a #GMount representing the mounted volume. Returns %NULL if the #GVolume is not mounted.\n @can_mount: Returns %TRUE if the #GVolume can be mounted.\n @can_eject: Checks if a #GVolume can be ejected.\n @mount_fn: Mounts a given #GVolume.\n     #GVolume implementations must emit the #GMountOperation::aborted\n     signal before completing a mount operation that is aborted while\n     awaiting input from the user through a #GMountOperation instance.\n @mount_finish: Finishes a mount operation.\n @eject: Ejects a given #GVolume.\n @eject_finish: Finishes an eject operation.\n @get_identifier: Returns the [identifier](#volume-identifiers) of the given kind, or %NULL if\n    the #GVolume doesn't have one.\n @enumerate_identifiers: Returns an array strings listing the kinds\n    of [identifiers](#volume-identifiers) which the #GVolume has.\n @should_automount: Returns %TRUE if the #GVolume should be automatically mounted.\n @get_activation_root: Returns the activation root for the #GVolume if it is known in advance or %NULL if\n   it is not known.\n @eject_with_operation: Starts ejecting a #GVolume using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_sort_key: Gets a key used for sorting #GVolume instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GVolume. Since 2.34.\n\n Interface for implementing operations for mountable volumes."]
pub type GVolumeIface = _GVolumeIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub removed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GDrive>,
    pub get_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GMount>,
    pub can_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub mount_fn: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            kind: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub should_automount:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub get_activation_root:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GFile>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GVolumeIface"][::std::mem::size_of::<_GVolumeIface>() - 184usize];
    ["Alignment of _GVolumeIface"][::std::mem::align_of::<_GVolumeIface>() - 8usize];
    ["Offset of field: _GVolumeIface::g_iface"]
        [::std::mem::offset_of!(_GVolumeIface, g_iface) - 0usize];
    ["Offset of field: _GVolumeIface::changed"]
        [::std::mem::offset_of!(_GVolumeIface, changed) - 16usize];
    ["Offset of field: _GVolumeIface::removed"]
        [::std::mem::offset_of!(_GVolumeIface, removed) - 24usize];
    ["Offset of field: _GVolumeIface::get_name"]
        [::std::mem::offset_of!(_GVolumeIface, get_name) - 32usize];
    ["Offset of field: _GVolumeIface::get_icon"]
        [::std::mem::offset_of!(_GVolumeIface, get_icon) - 40usize];
    ["Offset of field: _GVolumeIface::get_uuid"]
        [::std::mem::offset_of!(_GVolumeIface, get_uuid) - 48usize];
    ["Offset of field: _GVolumeIface::get_drive"]
        [::std::mem::offset_of!(_GVolumeIface, get_drive) - 56usize];
    ["Offset of field: _GVolumeIface::get_mount"]
        [::std::mem::offset_of!(_GVolumeIface, get_mount) - 64usize];
    ["Offset of field: _GVolumeIface::can_mount"]
        [::std::mem::offset_of!(_GVolumeIface, can_mount) - 72usize];
    ["Offset of field: _GVolumeIface::can_eject"]
        [::std::mem::offset_of!(_GVolumeIface, can_eject) - 80usize];
    ["Offset of field: _GVolumeIface::mount_fn"]
        [::std::mem::offset_of!(_GVolumeIface, mount_fn) - 88usize];
    ["Offset of field: _GVolumeIface::mount_finish"]
        [::std::mem::offset_of!(_GVolumeIface, mount_finish) - 96usize];
    ["Offset of field: _GVolumeIface::eject"]
        [::std::mem::offset_of!(_GVolumeIface, eject) - 104usize];
    ["Offset of field: _GVolumeIface::eject_finish"]
        [::std::mem::offset_of!(_GVolumeIface, eject_finish) - 112usize];
    ["Offset of field: _GVolumeIface::get_identifier"]
        [::std::mem::offset_of!(_GVolumeIface, get_identifier) - 120usize];
    ["Offset of field: _GVolumeIface::enumerate_identifiers"]
        [::std::mem::offset_of!(_GVolumeIface, enumerate_identifiers) - 128usize];
    ["Offset of field: _GVolumeIface::should_automount"]
        [::std::mem::offset_of!(_GVolumeIface, should_automount) - 136usize];
    ["Offset of field: _GVolumeIface::get_activation_root"]
        [::std::mem::offset_of!(_GVolumeIface, get_activation_root) - 144usize];
    ["Offset of field: _GVolumeIface::eject_with_operation"]
        [::std::mem::offset_of!(_GVolumeIface, eject_with_operation) - 152usize];
    ["Offset of field: _GVolumeIface::eject_with_operation_finish"]
        [::std::mem::offset_of!(_GVolumeIface, eject_with_operation_finish) - 160usize];
    ["Offset of field: _GVolumeIface::get_sort_key"]
        [::std::mem::offset_of!(_GVolumeIface, get_sort_key) - 168usize];
    ["Offset of field: _GVolumeIface::get_symbolic_icon"]
        [::std::mem::offset_of!(_GVolumeIface, get_symbolic_icon) - 176usize];
};
unsafe extern "C" {
    pub fn g_volume_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_volume_get_name(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
}
unsafe extern "C" {
    pub fn g_volume_get_uuid(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
}
unsafe extern "C" {
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
}
unsafe extern "C" {
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
}
unsafe extern "C" {
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
}
unsafe extern "C" {
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;
}
unsafe extern "C" {
    pub fn g_volume_mount(
        volume: *mut GVolume,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_volume_mount_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_volume_eject(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_volume_eject_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_volume_get_identifier(
        volume: *mut GVolume,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume)
        -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
}
unsafe extern "C" {
    pub fn g_volume_eject_with_operation(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
unsafe extern "C" {
    pub fn g_volume_eject_with_operation_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const gchar;
}
pub type GZlibCompressorClass = _GZlibCompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressorClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GZlibCompressorClass"][::std::mem::size_of::<_GZlibCompressorClass>() - 136usize];
    ["Alignment of _GZlibCompressorClass"]
        [::std::mem::align_of::<_GZlibCompressorClass>() - 8usize];
    ["Offset of field: _GZlibCompressorClass::parent_class"]
        [::std::mem::offset_of!(_GZlibCompressorClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_zlib_compressor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_zlib_compressor_new(
        format: GZlibCompressorFormat,
        level: ::std::os::raw::c_int,
    ) -> *mut GZlibCompressor;
}
unsafe extern "C" {
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor) -> *mut GFileInfo;
}
unsafe extern "C" {
    pub fn g_zlib_compressor_set_file_info(
        compressor: *mut GZlibCompressor,
        file_info: *mut GFileInfo,
    );
}
pub type GZlibDecompressorClass = _GZlibDecompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressorClass {
    pub parent_class: GObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _GZlibDecompressorClass"]
        [::std::mem::size_of::<_GZlibDecompressorClass>() - 136usize];
    ["Alignment of _GZlibDecompressorClass"]
        [::std::mem::align_of::<_GZlibDecompressorClass>() - 8usize];
    ["Offset of field: _GZlibDecompressorClass::parent_class"]
        [::std::mem::offset_of!(_GZlibDecompressorClass, parent_class) - 0usize];
};
unsafe extern "C" {
    pub fn g_zlib_decompressor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat) -> *mut GZlibDecompressor;
}
unsafe extern "C" {
    pub fn g_zlib_decompressor_get_file_info(
        decompressor: *mut GZlibDecompressor,
    ) -> *mut GFileInfo;
}
pub type GAction_autoptr = *mut GAction;
pub type GAction_listautoptr = *mut GList;
pub type GAction_slistautoptr = *mut GSList;
pub type GAction_queueautoptr = *mut GQueue;
pub type GActionMap_autoptr = *mut GActionMap;
pub type GActionMap_listautoptr = *mut GList;
pub type GActionMap_slistautoptr = *mut GSList;
pub type GActionMap_queueautoptr = *mut GQueue;
pub type GAppInfo_autoptr = *mut GAppInfo;
pub type GAppInfo_listautoptr = *mut GList;
pub type GAppInfo_slistautoptr = *mut GSList;
pub type GAppInfo_queueautoptr = *mut GQueue;
pub type GAppLaunchContext_autoptr = *mut GAppLaunchContext;
pub type GAppLaunchContext_listautoptr = *mut GList;
pub type GAppLaunchContext_slistautoptr = *mut GSList;
pub type GAppLaunchContext_queueautoptr = *mut GQueue;
pub type GAppInfoMonitor_autoptr = *mut GAppInfoMonitor;
pub type GAppInfoMonitor_listautoptr = *mut GList;
pub type GAppInfoMonitor_slistautoptr = *mut GSList;
pub type GAppInfoMonitor_queueautoptr = *mut GQueue;
pub type GApplicationCommandLine_autoptr = *mut GApplicationCommandLine;
pub type GApplicationCommandLine_listautoptr = *mut GList;
pub type GApplicationCommandLine_slistautoptr = *mut GSList;
pub type GApplicationCommandLine_queueautoptr = *mut GQueue;
pub type GApplication_autoptr = *mut GApplication;
pub type GApplication_listautoptr = *mut GList;
pub type GApplication_slistautoptr = *mut GSList;
pub type GApplication_queueautoptr = *mut GQueue;
pub type GAsyncInitable_autoptr = *mut GAsyncInitable;
pub type GAsyncInitable_listautoptr = *mut GList;
pub type GAsyncInitable_slistautoptr = *mut GSList;
pub type GAsyncInitable_queueautoptr = *mut GQueue;
pub type GAsyncResult_autoptr = *mut GAsyncResult;
pub type GAsyncResult_listautoptr = *mut GList;
pub type GAsyncResult_slistautoptr = *mut GSList;
pub type GAsyncResult_queueautoptr = *mut GQueue;
pub type GBufferedInputStream_autoptr = *mut GBufferedInputStream;
pub type GBufferedInputStream_listautoptr = *mut GList;
pub type GBufferedInputStream_slistautoptr = *mut GSList;
pub type GBufferedInputStream_queueautoptr = *mut GQueue;
pub type GBufferedOutputStream_autoptr = *mut GBufferedOutputStream;
pub type GBufferedOutputStream_listautoptr = *mut GList;
pub type GBufferedOutputStream_slistautoptr = *mut GSList;
pub type GBufferedOutputStream_queueautoptr = *mut GQueue;
pub type GBytesIcon_autoptr = *mut GBytesIcon;
pub type GBytesIcon_listautoptr = *mut GList;
pub type GBytesIcon_slistautoptr = *mut GSList;
pub type GBytesIcon_queueautoptr = *mut GQueue;
pub type GCancellable_autoptr = *mut GCancellable;
pub type GCancellable_listautoptr = *mut GList;
pub type GCancellable_slistautoptr = *mut GSList;
pub type GCancellable_queueautoptr = *mut GQueue;
pub type GCharsetConverter_autoptr = *mut GCharsetConverter;
pub type GCharsetConverter_listautoptr = *mut GList;
pub type GCharsetConverter_slistautoptr = *mut GSList;
pub type GCharsetConverter_queueautoptr = *mut GQueue;
pub type GConverter_autoptr = *mut GConverter;
pub type GConverter_listautoptr = *mut GList;
pub type GConverter_slistautoptr = *mut GSList;
pub type GConverter_queueautoptr = *mut GQueue;
pub type GConverterInputStream_autoptr = *mut GConverterInputStream;
pub type GConverterInputStream_listautoptr = *mut GList;
pub type GConverterInputStream_slistautoptr = *mut GSList;
pub type GConverterInputStream_queueautoptr = *mut GQueue;
pub type GConverterOutputStream_autoptr = *mut GConverterOutputStream;
pub type GConverterOutputStream_listautoptr = *mut GList;
pub type GConverterOutputStream_slistautoptr = *mut GSList;
pub type GConverterOutputStream_queueautoptr = *mut GQueue;
pub type GCredentials_autoptr = *mut GCredentials;
pub type GCredentials_listautoptr = *mut GList;
pub type GCredentials_slistautoptr = *mut GSList;
pub type GCredentials_queueautoptr = *mut GQueue;
pub type GDatagramBased_autoptr = *mut GDatagramBased;
pub type GDatagramBased_listautoptr = *mut GList;
pub type GDatagramBased_slistautoptr = *mut GSList;
pub type GDatagramBased_queueautoptr = *mut GQueue;
pub type GDataInputStream_autoptr = *mut GDataInputStream;
pub type GDataInputStream_listautoptr = *mut GList;
pub type GDataInputStream_slistautoptr = *mut GSList;
pub type GDataInputStream_queueautoptr = *mut GQueue;
pub type GDataOutputStream_autoptr = *mut GDataOutputStream;
pub type GDataOutputStream_listautoptr = *mut GList;
pub type GDataOutputStream_slistautoptr = *mut GSList;
pub type GDataOutputStream_queueautoptr = *mut GQueue;
pub type GDBusActionGroup_autoptr = *mut GDBusActionGroup;
pub type GDBusActionGroup_listautoptr = *mut GList;
pub type GDBusActionGroup_slistautoptr = *mut GSList;
pub type GDBusActionGroup_queueautoptr = *mut GQueue;
pub type GDBusAuthObserver_autoptr = *mut GDBusAuthObserver;
pub type GDBusAuthObserver_listautoptr = *mut GList;
pub type GDBusAuthObserver_slistautoptr = *mut GSList;
pub type GDBusAuthObserver_queueautoptr = *mut GQueue;
pub type GDBusConnection_autoptr = *mut GDBusConnection;
pub type GDBusConnection_listautoptr = *mut GList;
pub type GDBusConnection_slistautoptr = *mut GSList;
pub type GDBusConnection_queueautoptr = *mut GQueue;
pub type GDBusInterface_autoptr = *mut GDBusInterface;
pub type GDBusInterface_listautoptr = *mut GList;
pub type GDBusInterface_slistautoptr = *mut GSList;
pub type GDBusInterface_queueautoptr = *mut GQueue;
pub type GDBusInterfaceSkeleton_autoptr = *mut GDBusInterfaceSkeleton;
pub type GDBusInterfaceSkeleton_listautoptr = *mut GList;
pub type GDBusInterfaceSkeleton_slistautoptr = *mut GSList;
pub type GDBusInterfaceSkeleton_queueautoptr = *mut GQueue;
pub type GDBusMenuModel_autoptr = *mut GDBusMenuModel;
pub type GDBusMenuModel_listautoptr = *mut GList;
pub type GDBusMenuModel_slistautoptr = *mut GSList;
pub type GDBusMenuModel_queueautoptr = *mut GQueue;
pub type GDBusMessage_autoptr = *mut GDBusMessage;
pub type GDBusMessage_listautoptr = *mut GList;
pub type GDBusMessage_slistautoptr = *mut GSList;
pub type GDBusMessage_queueautoptr = *mut GQueue;
pub type GDBusMethodInvocation_autoptr = *mut GDBusMethodInvocation;
pub type GDBusMethodInvocation_listautoptr = *mut GList;
pub type GDBusMethodInvocation_slistautoptr = *mut GSList;
pub type GDBusMethodInvocation_queueautoptr = *mut GQueue;
pub type GDBusNodeInfo_autoptr = *mut GDBusNodeInfo;
pub type GDBusNodeInfo_listautoptr = *mut GList;
pub type GDBusNodeInfo_slistautoptr = *mut GSList;
pub type GDBusNodeInfo_queueautoptr = *mut GQueue;
pub type GDBusObject_autoptr = *mut GDBusObject;
pub type GDBusObject_listautoptr = *mut GList;
pub type GDBusObject_slistautoptr = *mut GSList;
pub type GDBusObject_queueautoptr = *mut GQueue;
pub type GDBusObjectManagerClient_autoptr = *mut GDBusObjectManagerClient;
pub type GDBusObjectManagerClient_listautoptr = *mut GList;
pub type GDBusObjectManagerClient_slistautoptr = *mut GSList;
pub type GDBusObjectManagerClient_queueautoptr = *mut GQueue;
pub type GDBusObjectManager_autoptr = *mut GDBusObjectManager;
pub type GDBusObjectManager_listautoptr = *mut GList;
pub type GDBusObjectManager_slistautoptr = *mut GSList;
pub type GDBusObjectManager_queueautoptr = *mut GQueue;
pub type GDBusObjectManagerServer_autoptr = *mut GDBusObjectManagerServer;
pub type GDBusObjectManagerServer_listautoptr = *mut GList;
pub type GDBusObjectManagerServer_slistautoptr = *mut GSList;
pub type GDBusObjectManagerServer_queueautoptr = *mut GQueue;
pub type GDBusObjectProxy_autoptr = *mut GDBusObjectProxy;
pub type GDBusObjectProxy_listautoptr = *mut GList;
pub type GDBusObjectProxy_slistautoptr = *mut GSList;
pub type GDBusObjectProxy_queueautoptr = *mut GQueue;
pub type GDBusObjectSkeleton_autoptr = *mut GDBusObjectSkeleton;
pub type GDBusObjectSkeleton_listautoptr = *mut GList;
pub type GDBusObjectSkeleton_slistautoptr = *mut GSList;
pub type GDBusObjectSkeleton_queueautoptr = *mut GQueue;
pub type GDBusProxy_autoptr = *mut GDBusProxy;
pub type GDBusProxy_listautoptr = *mut GList;
pub type GDBusProxy_slistautoptr = *mut GSList;
pub type GDBusProxy_queueautoptr = *mut GQueue;
pub type GDBusServer_autoptr = *mut GDBusServer;
pub type GDBusServer_listautoptr = *mut GList;
pub type GDBusServer_slistautoptr = *mut GSList;
pub type GDBusServer_queueautoptr = *mut GQueue;
pub type GDrive_autoptr = *mut GDrive;
pub type GDrive_listautoptr = *mut GList;
pub type GDrive_slistautoptr = *mut GSList;
pub type GDrive_queueautoptr = *mut GQueue;
pub type GEmblemedIcon_autoptr = *mut GEmblemedIcon;
pub type GEmblemedIcon_listautoptr = *mut GList;
pub type GEmblemedIcon_slistautoptr = *mut GSList;
pub type GEmblemedIcon_queueautoptr = *mut GQueue;
pub type GEmblem_autoptr = *mut GEmblem;
pub type GEmblem_listautoptr = *mut GList;
pub type GEmblem_slistautoptr = *mut GSList;
pub type GEmblem_queueautoptr = *mut GQueue;
pub type GFileEnumerator_autoptr = *mut GFileEnumerator;
pub type GFileEnumerator_listautoptr = *mut GList;
pub type GFileEnumerator_slistautoptr = *mut GSList;
pub type GFileEnumerator_queueautoptr = *mut GQueue;
pub type GFile_autoptr = *mut GFile;
pub type GFile_listautoptr = *mut GList;
pub type GFile_slistautoptr = *mut GSList;
pub type GFile_queueautoptr = *mut GQueue;
pub type GFileAttributeInfoList_autoptr = *mut GFileAttributeInfoList;
pub type GFileAttributeInfoList_listautoptr = *mut GList;
pub type GFileAttributeInfoList_slistautoptr = *mut GSList;
pub type GFileAttributeInfoList_queueautoptr = *mut GQueue;
pub type GFileIcon_autoptr = *mut GFileIcon;
pub type GFileIcon_listautoptr = *mut GList;
pub type GFileIcon_slistautoptr = *mut GSList;
pub type GFileIcon_queueautoptr = *mut GQueue;
pub type GFileInfo_autoptr = *mut GFileInfo;
pub type GFileInfo_listautoptr = *mut GList;
pub type GFileInfo_slistautoptr = *mut GSList;
pub type GFileInfo_queueautoptr = *mut GQueue;
pub type GFileInputStream_autoptr = *mut GFileInputStream;
pub type GFileInputStream_listautoptr = *mut GList;
pub type GFileInputStream_slistautoptr = *mut GSList;
pub type GFileInputStream_queueautoptr = *mut GQueue;
pub type GFileIOStream_autoptr = *mut GFileIOStream;
pub type GFileIOStream_listautoptr = *mut GList;
pub type GFileIOStream_slistautoptr = *mut GSList;
pub type GFileIOStream_queueautoptr = *mut GQueue;
pub type GFileMonitor_autoptr = *mut GFileMonitor;
pub type GFileMonitor_listautoptr = *mut GList;
pub type GFileMonitor_slistautoptr = *mut GSList;
pub type GFileMonitor_queueautoptr = *mut GQueue;
pub type GFilenameCompleter_autoptr = *mut GFilenameCompleter;
pub type GFilenameCompleter_listautoptr = *mut GList;
pub type GFilenameCompleter_slistautoptr = *mut GSList;
pub type GFilenameCompleter_queueautoptr = *mut GQueue;
pub type GFileOutputStream_autoptr = *mut GFileOutputStream;
pub type GFileOutputStream_listautoptr = *mut GList;
pub type GFileOutputStream_slistautoptr = *mut GSList;
pub type GFileOutputStream_queueautoptr = *mut GQueue;
pub type GFilterInputStream_autoptr = *mut GFilterInputStream;
pub type GFilterInputStream_listautoptr = *mut GList;
pub type GFilterInputStream_slistautoptr = *mut GSList;
pub type GFilterInputStream_queueautoptr = *mut GQueue;
pub type GFilterOutputStream_autoptr = *mut GFilterOutputStream;
pub type GFilterOutputStream_listautoptr = *mut GList;
pub type GFilterOutputStream_slistautoptr = *mut GSList;
pub type GFilterOutputStream_queueautoptr = *mut GQueue;
pub type GIcon_autoptr = *mut GIcon;
pub type GIcon_listautoptr = *mut GList;
pub type GIcon_slistautoptr = *mut GSList;
pub type GIcon_queueautoptr = *mut GQueue;
pub type GInetAddress_autoptr = *mut GInetAddress;
pub type GInetAddress_listautoptr = *mut GList;
pub type GInetAddress_slistautoptr = *mut GSList;
pub type GInetAddress_queueautoptr = *mut GQueue;
pub type GInetAddressMask_autoptr = *mut GInetAddressMask;
pub type GInetAddressMask_listautoptr = *mut GList;
pub type GInetAddressMask_slistautoptr = *mut GSList;
pub type GInetAddressMask_queueautoptr = *mut GQueue;
pub type GInetSocketAddress_autoptr = *mut GInetSocketAddress;
pub type GInetSocketAddress_listautoptr = *mut GList;
pub type GInetSocketAddress_slistautoptr = *mut GSList;
pub type GInetSocketAddress_queueautoptr = *mut GQueue;
pub type GInitable_autoptr = *mut GInitable;
pub type GInitable_listautoptr = *mut GList;
pub type GInitable_slistautoptr = *mut GSList;
pub type GInitable_queueautoptr = *mut GQueue;
pub type GInputStream_autoptr = *mut GInputStream;
pub type GInputStream_listautoptr = *mut GList;
pub type GInputStream_slistautoptr = *mut GSList;
pub type GInputStream_queueautoptr = *mut GQueue;
pub type GIOModule_autoptr = *mut GIOModule;
pub type GIOModule_listautoptr = *mut GList;
pub type GIOModule_slistautoptr = *mut GSList;
pub type GIOModule_queueautoptr = *mut GQueue;
pub type GIOStream_autoptr = *mut GIOStream;
pub type GIOStream_listautoptr = *mut GList;
pub type GIOStream_slistautoptr = *mut GSList;
pub type GIOStream_queueautoptr = *mut GQueue;
pub type GLoadableIcon_autoptr = *mut GLoadableIcon;
pub type GLoadableIcon_listautoptr = *mut GList;
pub type GLoadableIcon_slistautoptr = *mut GSList;
pub type GLoadableIcon_queueautoptr = *mut GQueue;
pub type GMemoryInputStream_autoptr = *mut GMemoryInputStream;
pub type GMemoryInputStream_listautoptr = *mut GList;
pub type GMemoryInputStream_slistautoptr = *mut GSList;
pub type GMemoryInputStream_queueautoptr = *mut GQueue;
pub type GMemoryOutputStream_autoptr = *mut GMemoryOutputStream;
pub type GMemoryOutputStream_listautoptr = *mut GList;
pub type GMemoryOutputStream_slistautoptr = *mut GSList;
pub type GMemoryOutputStream_queueautoptr = *mut GQueue;
pub type GMenu_autoptr = *mut GMenu;
pub type GMenu_listautoptr = *mut GList;
pub type GMenu_slistautoptr = *mut GSList;
pub type GMenu_queueautoptr = *mut GQueue;
pub type GMenuItem_autoptr = *mut GMenuItem;
pub type GMenuItem_listautoptr = *mut GList;
pub type GMenuItem_slistautoptr = *mut GSList;
pub type GMenuItem_queueautoptr = *mut GQueue;
pub type GMenuModel_autoptr = *mut GMenuModel;
pub type GMenuModel_listautoptr = *mut GList;
pub type GMenuModel_slistautoptr = *mut GSList;
pub type GMenuModel_queueautoptr = *mut GQueue;
pub type GMenuAttributeIter_autoptr = *mut GMenuAttributeIter;
pub type GMenuAttributeIter_listautoptr = *mut GList;
pub type GMenuAttributeIter_slistautoptr = *mut GSList;
pub type GMenuAttributeIter_queueautoptr = *mut GQueue;
pub type GMenuLinkIter_autoptr = *mut GMenuLinkIter;
pub type GMenuLinkIter_listautoptr = *mut GList;
pub type GMenuLinkIter_slistautoptr = *mut GSList;
pub type GMenuLinkIter_queueautoptr = *mut GQueue;
pub type GMount_autoptr = *mut GMount;
pub type GMount_listautoptr = *mut GList;
pub type GMount_slistautoptr = *mut GSList;
pub type GMount_queueautoptr = *mut GQueue;
pub type GMountOperation_autoptr = *mut GMountOperation;
pub type GMountOperation_listautoptr = *mut GList;
pub type GMountOperation_slistautoptr = *mut GSList;
pub type GMountOperation_queueautoptr = *mut GQueue;
pub type GNativeVolumeMonitor_autoptr = *mut GNativeVolumeMonitor;
pub type GNativeVolumeMonitor_listautoptr = *mut GList;
pub type GNativeVolumeMonitor_slistautoptr = *mut GSList;
pub type GNativeVolumeMonitor_queueautoptr = *mut GQueue;
pub type GNetworkAddress_autoptr = *mut GNetworkAddress;
pub type GNetworkAddress_listautoptr = *mut GList;
pub type GNetworkAddress_slistautoptr = *mut GSList;
pub type GNetworkAddress_queueautoptr = *mut GQueue;
pub type GNetworkMonitor_autoptr = *mut GNetworkMonitor;
pub type GNetworkMonitor_listautoptr = *mut GList;
pub type GNetworkMonitor_slistautoptr = *mut GSList;
pub type GNetworkMonitor_queueautoptr = *mut GQueue;
pub type GNetworkService_autoptr = *mut GNetworkService;
pub type GNetworkService_listautoptr = *mut GList;
pub type GNetworkService_slistautoptr = *mut GSList;
pub type GNetworkService_queueautoptr = *mut GQueue;
pub type GNotification_autoptr = *mut GNotification;
pub type GNotification_listautoptr = *mut GList;
pub type GNotification_slistautoptr = *mut GSList;
pub type GNotification_queueautoptr = *mut GQueue;
pub type GOutputStream_autoptr = *mut GOutputStream;
pub type GOutputStream_listautoptr = *mut GList;
pub type GOutputStream_slistautoptr = *mut GSList;
pub type GOutputStream_queueautoptr = *mut GQueue;
pub type GPermission_autoptr = *mut GPermission;
pub type GPermission_listautoptr = *mut GList;
pub type GPermission_slistautoptr = *mut GSList;
pub type GPermission_queueautoptr = *mut GQueue;
pub type GPollableInputStream_autoptr = *mut GPollableInputStream;
pub type GPollableInputStream_listautoptr = *mut GList;
pub type GPollableInputStream_slistautoptr = *mut GSList;
pub type GPollableInputStream_queueautoptr = *mut GQueue;
pub type GPollableOutputStream_autoptr = *mut GPollableOutputStream;
pub type GPollableOutputStream_listautoptr = *mut GList;
pub type GPollableOutputStream_slistautoptr = *mut GSList;
pub type GPollableOutputStream_queueautoptr = *mut GQueue;
pub type GPropertyAction_autoptr = *mut GPropertyAction;
pub type GPropertyAction_listautoptr = *mut GList;
pub type GPropertyAction_slistautoptr = *mut GSList;
pub type GPropertyAction_queueautoptr = *mut GQueue;
pub type GProxyAddressEnumerator_autoptr = *mut GProxyAddressEnumerator;
pub type GProxyAddressEnumerator_listautoptr = *mut GList;
pub type GProxyAddressEnumerator_slistautoptr = *mut GSList;
pub type GProxyAddressEnumerator_queueautoptr = *mut GQueue;
pub type GProxyAddress_autoptr = *mut GProxyAddress;
pub type GProxyAddress_listautoptr = *mut GList;
pub type GProxyAddress_slistautoptr = *mut GSList;
pub type GProxyAddress_queueautoptr = *mut GQueue;
pub type GProxy_autoptr = *mut GProxy;
pub type GProxy_listautoptr = *mut GList;
pub type GProxy_slistautoptr = *mut GSList;
pub type GProxy_queueautoptr = *mut GQueue;
pub type GProxyResolver_autoptr = *mut GProxyResolver;
pub type GProxyResolver_listautoptr = *mut GList;
pub type GProxyResolver_slistautoptr = *mut GSList;
pub type GProxyResolver_queueautoptr = *mut GQueue;
pub type GRemoteActionGroup_autoptr = *mut GRemoteActionGroup;
pub type GRemoteActionGroup_listautoptr = *mut GList;
pub type GRemoteActionGroup_slistautoptr = *mut GSList;
pub type GRemoteActionGroup_queueautoptr = *mut GQueue;
pub type GResolver_autoptr = *mut GResolver;
pub type GResolver_listautoptr = *mut GList;
pub type GResolver_slistautoptr = *mut GSList;
pub type GResolver_queueautoptr = *mut GQueue;
pub type GResource_autoptr = *mut GResource;
pub type GResource_listautoptr = *mut GList;
pub type GResource_slistautoptr = *mut GSList;
pub type GResource_queueautoptr = *mut GQueue;
pub type GSeekable_autoptr = *mut GSeekable;
pub type GSeekable_listautoptr = *mut GList;
pub type GSeekable_slistautoptr = *mut GSList;
pub type GSeekable_queueautoptr = *mut GQueue;
pub type GSettingsBackend_autoptr = *mut GSettingsBackend;
pub type GSettingsBackend_listautoptr = *mut GList;
pub type GSettingsBackend_slistautoptr = *mut GSList;
pub type GSettingsBackend_queueautoptr = *mut GQueue;
pub type GSettingsSchema_autoptr = *mut GSettingsSchema;
pub type GSettingsSchema_listautoptr = *mut GList;
pub type GSettingsSchema_slistautoptr = *mut GSList;
pub type GSettingsSchema_queueautoptr = *mut GQueue;
pub type GSettingsSchemaKey_autoptr = *mut GSettingsSchemaKey;
pub type GSettingsSchemaKey_listautoptr = *mut GList;
pub type GSettingsSchemaKey_slistautoptr = *mut GSList;
pub type GSettingsSchemaKey_queueautoptr = *mut GQueue;
pub type GSettingsSchemaSource_autoptr = *mut GSettingsSchemaSource;
pub type GSettingsSchemaSource_listautoptr = *mut GList;
pub type GSettingsSchemaSource_slistautoptr = *mut GSList;
pub type GSettingsSchemaSource_queueautoptr = *mut GQueue;
pub type GSettings_autoptr = *mut GSettings;
pub type GSettings_listautoptr = *mut GList;
pub type GSettings_slistautoptr = *mut GSList;
pub type GSettings_queueautoptr = *mut GQueue;
pub type GSimpleActionGroup_autoptr = *mut GSimpleActionGroup;
pub type GSimpleActionGroup_listautoptr = *mut GList;
pub type GSimpleActionGroup_slistautoptr = *mut GSList;
pub type GSimpleActionGroup_queueautoptr = *mut GQueue;
pub type GSimpleAction_autoptr = *mut GSimpleAction;
pub type GSimpleAction_listautoptr = *mut GList;
pub type GSimpleAction_slistautoptr = *mut GSList;
pub type GSimpleAction_queueautoptr = *mut GQueue;
pub type GSimpleAsyncResult_autoptr = *mut GSimpleAsyncResult;
pub type GSimpleAsyncResult_listautoptr = *mut GList;
pub type GSimpleAsyncResult_slistautoptr = *mut GSList;
pub type GSimpleAsyncResult_queueautoptr = *mut GQueue;
pub type GSimplePermission_autoptr = *mut GSimplePermission;
pub type GSimplePermission_listautoptr = *mut GList;
pub type GSimplePermission_slistautoptr = *mut GSList;
pub type GSimplePermission_queueautoptr = *mut GQueue;
pub type GSimpleProxyResolver_autoptr = *mut GSimpleProxyResolver;
pub type GSimpleProxyResolver_listautoptr = *mut GList;
pub type GSimpleProxyResolver_slistautoptr = *mut GSList;
pub type GSimpleProxyResolver_queueautoptr = *mut GQueue;
pub type GSocketAddressEnumerator_autoptr = *mut GSocketAddressEnumerator;
pub type GSocketAddressEnumerator_listautoptr = *mut GList;
pub type GSocketAddressEnumerator_slistautoptr = *mut GSList;
pub type GSocketAddressEnumerator_queueautoptr = *mut GQueue;
pub type GSocketAddress_autoptr = *mut GSocketAddress;
pub type GSocketAddress_listautoptr = *mut GList;
pub type GSocketAddress_slistautoptr = *mut GSList;
pub type GSocketAddress_queueautoptr = *mut GQueue;
pub type GSocketClient_autoptr = *mut GSocketClient;
pub type GSocketClient_listautoptr = *mut GList;
pub type GSocketClient_slistautoptr = *mut GSList;
pub type GSocketClient_queueautoptr = *mut GQueue;
pub type GSocketConnectable_autoptr = *mut GSocketConnectable;
pub type GSocketConnectable_listautoptr = *mut GList;
pub type GSocketConnectable_slistautoptr = *mut GSList;
pub type GSocketConnectable_queueautoptr = *mut GQueue;
pub type GSocketConnection_autoptr = *mut GSocketConnection;
pub type GSocketConnection_listautoptr = *mut GList;
pub type GSocketConnection_slistautoptr = *mut GSList;
pub type GSocketConnection_queueautoptr = *mut GQueue;
pub type GSocketControlMessage_autoptr = *mut GSocketControlMessage;
pub type GSocketControlMessage_listautoptr = *mut GList;
pub type GSocketControlMessage_slistautoptr = *mut GSList;
pub type GSocketControlMessage_queueautoptr = *mut GQueue;
pub type GSocket_autoptr = *mut GSocket;
pub type GSocket_listautoptr = *mut GList;
pub type GSocket_slistautoptr = *mut GSList;
pub type GSocket_queueautoptr = *mut GQueue;
pub type GSocketListener_autoptr = *mut GSocketListener;
pub type GSocketListener_listautoptr = *mut GList;
pub type GSocketListener_slistautoptr = *mut GSList;
pub type GSocketListener_queueautoptr = *mut GQueue;
pub type GSocketService_autoptr = *mut GSocketService;
pub type GSocketService_listautoptr = *mut GList;
pub type GSocketService_slistautoptr = *mut GSList;
pub type GSocketService_queueautoptr = *mut GQueue;
pub type GSubprocess_autoptr = *mut GSubprocess;
pub type GSubprocess_listautoptr = *mut GList;
pub type GSubprocess_slistautoptr = *mut GSList;
pub type GSubprocess_queueautoptr = *mut GQueue;
pub type GSubprocessLauncher_autoptr = *mut GSubprocessLauncher;
pub type GSubprocessLauncher_listautoptr = *mut GList;
pub type GSubprocessLauncher_slistautoptr = *mut GSList;
pub type GSubprocessLauncher_queueautoptr = *mut GQueue;
pub type GTask_autoptr = *mut GTask;
pub type GTask_listautoptr = *mut GList;
pub type GTask_slistautoptr = *mut GSList;
pub type GTask_queueautoptr = *mut GQueue;
pub type GTcpConnection_autoptr = *mut GTcpConnection;
pub type GTcpConnection_listautoptr = *mut GList;
pub type GTcpConnection_slistautoptr = *mut GSList;
pub type GTcpConnection_queueautoptr = *mut GQueue;
pub type GTcpWrapperConnection_autoptr = *mut GTcpWrapperConnection;
pub type GTcpWrapperConnection_listautoptr = *mut GList;
pub type GTcpWrapperConnection_slistautoptr = *mut GSList;
pub type GTcpWrapperConnection_queueautoptr = *mut GQueue;
pub type GTestDBus_autoptr = *mut GTestDBus;
pub type GTestDBus_listautoptr = *mut GList;
pub type GTestDBus_slistautoptr = *mut GSList;
pub type GTestDBus_queueautoptr = *mut GQueue;
pub type GThemedIcon_autoptr = *mut GThemedIcon;
pub type GThemedIcon_listautoptr = *mut GList;
pub type GThemedIcon_slistautoptr = *mut GSList;
pub type GThemedIcon_queueautoptr = *mut GQueue;
pub type GThreadedSocketService_autoptr = *mut GThreadedSocketService;
pub type GThreadedSocketService_listautoptr = *mut GList;
pub type GThreadedSocketService_slistautoptr = *mut GSList;
pub type GThreadedSocketService_queueautoptr = *mut GQueue;
pub type GTlsBackend_autoptr = *mut GTlsBackend;
pub type GTlsBackend_listautoptr = *mut GList;
pub type GTlsBackend_slistautoptr = *mut GSList;
pub type GTlsBackend_queueautoptr = *mut GQueue;
pub type GTlsCertificate_autoptr = *mut GTlsCertificate;
pub type GTlsCertificate_listautoptr = *mut GList;
pub type GTlsCertificate_slistautoptr = *mut GSList;
pub type GTlsCertificate_queueautoptr = *mut GQueue;
pub type GTlsClientConnection_autoptr = *mut GTlsClientConnection;
pub type GTlsClientConnection_listautoptr = *mut GList;
pub type GTlsClientConnection_slistautoptr = *mut GSList;
pub type GTlsClientConnection_queueautoptr = *mut GQueue;
pub type GTlsConnection_autoptr = *mut GTlsConnection;
pub type GTlsConnection_listautoptr = *mut GList;
pub type GTlsConnection_slistautoptr = *mut GSList;
pub type GTlsConnection_queueautoptr = *mut GQueue;
pub type GTlsDatabase_autoptr = *mut GTlsDatabase;
pub type GTlsDatabase_listautoptr = *mut GList;
pub type GTlsDatabase_slistautoptr = *mut GSList;
pub type GTlsDatabase_queueautoptr = *mut GQueue;
pub type GTlsFileDatabase_autoptr = *mut GTlsFileDatabase;
pub type GTlsFileDatabase_listautoptr = *mut GList;
pub type GTlsFileDatabase_slistautoptr = *mut GSList;
pub type GTlsFileDatabase_queueautoptr = *mut GQueue;
pub type GTlsInteraction_autoptr = *mut GTlsInteraction;
pub type GTlsInteraction_listautoptr = *mut GList;
pub type GTlsInteraction_slistautoptr = *mut GSList;
pub type GTlsInteraction_queueautoptr = *mut GQueue;
pub type GTlsPassword_autoptr = *mut GTlsPassword;
pub type GTlsPassword_listautoptr = *mut GList;
pub type GTlsPassword_slistautoptr = *mut GSList;
pub type GTlsPassword_queueautoptr = *mut GQueue;
pub type GTlsServerConnection_autoptr = *mut GTlsServerConnection;
pub type GTlsServerConnection_listautoptr = *mut GList;
pub type GTlsServerConnection_slistautoptr = *mut GSList;
pub type GTlsServerConnection_queueautoptr = *mut GQueue;
pub type GVfs_autoptr = *mut GVfs;
pub type GVfs_listautoptr = *mut GList;
pub type GVfs_slistautoptr = *mut GSList;
pub type GVfs_queueautoptr = *mut GQueue;
pub type GVolume_autoptr = *mut GVolume;
pub type GVolume_listautoptr = *mut GList;
pub type GVolume_slistautoptr = *mut GSList;
pub type GVolume_queueautoptr = *mut GQueue;
pub type GVolumeMonitor_autoptr = *mut GVolumeMonitor;
pub type GVolumeMonitor_listautoptr = *mut GList;
pub type GVolumeMonitor_slistautoptr = *mut GSList;
pub type GVolumeMonitor_queueautoptr = *mut GQueue;
pub type GZlibCompressor_autoptr = *mut GZlibCompressor;
pub type GZlibCompressor_listautoptr = *mut GList;
pub type GZlibCompressor_slistautoptr = *mut GSList;
pub type GZlibCompressor_queueautoptr = *mut GQueue;
pub type GZlibDecompressor_autoptr = *mut GZlibDecompressor;
pub type GZlibDecompressor_listautoptr = *mut GList;
pub type GZlibDecompressor_slistautoptr = *mut GSList;
pub type GZlibDecompressor_queueautoptr = *mut GQueue;
pub type VipsPel = ::std::os::raw::c_uchar;
pub type VipsCallbackFn = ::std::option::Option<
    unsafe extern "C" fn(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsSListMap2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsSListMap4Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsSListFold2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub const VipsPrecision_VIPS_PRECISION_INTEGER: VipsPrecision = 0;
pub const VipsPrecision_VIPS_PRECISION_FLOAT: VipsPrecision = 1;
pub const VipsPrecision_VIPS_PRECISION_APPROXIMATE: VipsPrecision = 2;
pub const VipsPrecision_VIPS_PRECISION_LAST: VipsPrecision = 3;
pub type VipsPrecision = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_path_filename7(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_path_mode7(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub type VipsImage = _VipsImage;
pub type VipsRegion = _VipsRegion;
pub type VipsBuf = _VipsBuf;
pub type VipsSource = _VipsSource;
pub type VipsTarget = _VipsTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBuf {
    pub base: *mut ::std::os::raw::c_char,
    pub mx: ::std::os::raw::c_int,
    pub i: ::std::os::raw::c_int,
    pub full: gboolean,
    pub lasti: ::std::os::raw::c_int,
    pub dynamic: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsBuf"][::std::mem::size_of::<_VipsBuf>() - 32usize];
    ["Alignment of _VipsBuf"][::std::mem::align_of::<_VipsBuf>() - 8usize];
    ["Offset of field: _VipsBuf::base"][::std::mem::offset_of!(_VipsBuf, base) - 0usize];
    ["Offset of field: _VipsBuf::mx"][::std::mem::offset_of!(_VipsBuf, mx) - 8usize];
    ["Offset of field: _VipsBuf::i"][::std::mem::offset_of!(_VipsBuf, i) - 12usize];
    ["Offset of field: _VipsBuf::full"][::std::mem::offset_of!(_VipsBuf, full) - 16usize];
    ["Offset of field: _VipsBuf::lasti"][::std::mem::offset_of!(_VipsBuf, lasti) - 20usize];
    ["Offset of field: _VipsBuf::dynamic"][::std::mem::offset_of!(_VipsBuf, dynamic) - 24usize];
};
unsafe extern "C" {
    pub fn vips_buf_rewind(buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_buf_destroy(buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_buf_init(buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_buf_set_static(
        buf: *mut VipsBuf,
        base: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_buf_set_dynamic(buf: *mut VipsBuf, mx: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_buf_init_static(
        buf: *mut VipsBuf,
        base: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_buf_init_dynamic(buf: *mut VipsBuf, mx: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_buf_appendns(
        buf: *mut VipsBuf,
        str_: *const ::std::os::raw::c_char,
        sz: ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_appends(buf: *mut VipsBuf, str_: *const ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_appendf(buf: *mut VipsBuf, fmt: *const ::std::os::raw::c_char, ...)
        -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_vappendf(
        buf: *mut VipsBuf,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_appendc(buf: *mut VipsBuf, ch: ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_appendsc(
        buf: *mut VipsBuf,
        quote: gboolean,
        str_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_appendgv(buf: *mut VipsBuf, value: *mut GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_append_size(buf: *mut VipsBuf, n: usize) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_removec(buf: *mut VipsBuf, ch: ::std::os::raw::c_char) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_change(
        buf: *mut VipsBuf,
        o: *const ::std::os::raw::c_char,
        n: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_is_empty(buf: *mut VipsBuf) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_is_full(buf: *mut VipsBuf) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_all(buf: *mut VipsBuf) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_buf_firstline(buf: *mut VipsBuf) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_buf_appendg(buf: *mut VipsBuf, g: f64) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_appendd(buf: *mut VipsBuf, d: ::std::os::raw::c_int) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_buf_len(buf: *mut VipsBuf) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsDbuf {
    pub data: *mut ::std::os::raw::c_uchar,
    pub allocated_size: usize,
    pub data_size: usize,
    pub write_point: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsDbuf"][::std::mem::size_of::<_VipsDbuf>() - 32usize];
    ["Alignment of _VipsDbuf"][::std::mem::align_of::<_VipsDbuf>() - 8usize];
    ["Offset of field: _VipsDbuf::data"][::std::mem::offset_of!(_VipsDbuf, data) - 0usize];
    ["Offset of field: _VipsDbuf::allocated_size"]
        [::std::mem::offset_of!(_VipsDbuf, allocated_size) - 8usize];
    ["Offset of field: _VipsDbuf::data_size"]
        [::std::mem::offset_of!(_VipsDbuf, data_size) - 16usize];
    ["Offset of field: _VipsDbuf::write_point"]
        [::std::mem::offset_of!(_VipsDbuf, write_point) - 24usize];
};
pub type VipsDbuf = _VipsDbuf;
unsafe extern "C" {
    pub fn vips_dbuf_init(dbuf: *mut VipsDbuf);
}
unsafe extern "C" {
    pub fn vips_dbuf_minimum_size(dbuf: *mut VipsDbuf, size: usize) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dbuf_allocate(dbuf: *mut VipsDbuf, size: usize) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dbuf_read(
        dbuf: *mut VipsDbuf,
        data: *mut ::std::os::raw::c_uchar,
        size: usize,
    ) -> usize;
}
unsafe extern "C" {
    pub fn vips_dbuf_get_write(
        dbuf: *mut VipsDbuf,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn vips_dbuf_write(
        dbuf: *mut VipsDbuf,
        data: *const ::std::os::raw::c_uchar,
        size: usize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dbuf_writef(
        dbuf: *mut VipsDbuf,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dbuf_write_amp(
        dbuf: *mut VipsDbuf,
        str_: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dbuf_reset(dbuf: *mut VipsDbuf);
}
unsafe extern "C" {
    pub fn vips_dbuf_destroy(dbuf: *mut VipsDbuf);
}
unsafe extern "C" {
    pub fn vips_dbuf_seek(
        dbuf: *mut VipsDbuf,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dbuf_truncate(dbuf: *mut VipsDbuf);
}
unsafe extern "C" {
    pub fn vips_dbuf_tell(dbuf: *mut VipsDbuf) -> off_t;
}
unsafe extern "C" {
    pub fn vips_dbuf_string(dbuf: *mut VipsDbuf, size: *mut usize) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn vips_dbuf_steal(dbuf: *mut VipsDbuf, size: *mut usize) -> *mut ::std::os::raw::c_uchar;
}
pub type float_t = f32;
pub type double_t = f64;
unsafe extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
unsafe extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
unsafe extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
unsafe extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
unsafe extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
unsafe extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
unsafe extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __round(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
unsafe extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
unsafe extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
unsafe extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
unsafe extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
unsafe extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
unsafe extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
unsafe extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
unsafe extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
unsafe extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
unsafe extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
unsafe extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
unsafe extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
unsafe extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
unsafe extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
unsafe extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
unsafe extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
unsafe extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
unsafe extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
unsafe extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
unsafe extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
unsafe extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
unsafe extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
unsafe extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
unsafe extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
unsafe extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
unsafe extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
unsafe extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
unsafe extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
unsafe extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_24 = 0;
pub const FP_INFINITE: _bindgen_ty_24 = 1;
pub const FP_ZERO: _bindgen_ty_24 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_24 = 3;
pub const FP_NORMAL: _bindgen_ty_24 = 4;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_enum_string(
        enm: GType,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_enum_nick(
        enm: GType,
        value: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_enum_from_nick(
        domain: *const ::std::os::raw::c_char,
        type_: GType,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_flags_from_nick(
        domain: *const ::std::os::raw::c_char,
        type_: GType,
        nick: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_slist_equal(l1: *mut GSList, l2: *mut GSList) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_slist_map2(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_slist_map2_rev(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_slist_map4(
        list: *mut GSList,
        fn_: VipsSListMap4Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        c: *mut ::std::os::raw::c_void,
        d: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_slist_fold2(
        list: *mut GSList,
        start: *mut ::std::os::raw::c_void,
        fn_: VipsSListFold2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_slist_filter(
        list: *mut GSList,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut GSList;
}
unsafe extern "C" {
    pub fn vips_slist_free_all(list: *mut GSList);
}
unsafe extern "C" {
    pub fn vips_map_equal(
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_hash_table_map(
        hash: *mut GHashTable,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_strncpy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_strrstr(
        haystack: *const ::std::os::raw::c_char,
        needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_ispostfix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_iscasepostfix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_isprefix(
        a: *const ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_break_token(
        str_: *mut ::std::os::raw::c_char,
        brk: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__chomp(str_: *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips_vsnprintf(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_snprintf(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_filename_suffix_match(
        path: *const ::std::os::raw::c_char,
        suffixes: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_file_length(fd: ::std::os::raw::c_int) -> gint64;
}
unsafe extern "C" {
    pub fn vips__write(
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__open(
        filename: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__open_read(filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn vips__file_open_read(
        filename: *const ::std::os::raw::c_char,
        fallback_dir: *const ::std::os::raw::c_char,
        text_mode: gboolean,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn vips__file_open_write(
        filename: *const ::std::os::raw::c_char,
        text_mode: gboolean,
    ) -> *mut FILE;
}
unsafe extern "C" {
    pub fn vips__file_read(
        fp: *mut FILE,
        name: *const ::std::os::raw::c_char,
        length_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__file_read_name(
        name: *const ::std::os::raw::c_char,
        fallback_dir: *const ::std::os::raw::c_char,
        length_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__file_write(
        data: *mut ::std::os::raw::c_void,
        size: usize,
        nmemb: usize,
        stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__get_bytes(
        filename: *const ::std::os::raw::c_char,
        buf: *mut ::std::os::raw::c_uchar,
        len: gint64,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips__fgetc(fp: *mut FILE) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__gvalue_ref_string_new(text: *const ::std::os::raw::c_char) -> *mut GValue;
}
unsafe extern "C" {
    pub fn vips__gslist_gvalue_free(list: *mut GSList);
}
unsafe extern "C" {
    pub fn vips__gslist_gvalue_copy(list: *const GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn vips__gslist_gvalue_merge(a: *mut GSList, b: *const GSList) -> *mut GSList;
}
unsafe extern "C" {
    pub fn vips__gslist_gvalue_get(list: *const GSList) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__seek_no_error(
        fd: ::std::os::raw::c_int,
        pos: gint64,
        whence: ::std::os::raw::c_int,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips__seek(
        fd: ::std::os::raw::c_int,
        pos: gint64,
        whence: ::std::os::raw::c_int,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips__ftruncate(fd: ::std::os::raw::c_int, pos: gint64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_existsf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_isdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mkdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rmdirf(name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rename(
        old_name: *const ::std::os::raw::c_char,
        new_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub const VipsToken_VIPS_TOKEN_LEFT: VipsToken = 1;
pub const VipsToken_VIPS_TOKEN_RIGHT: VipsToken = 2;
pub const VipsToken_VIPS_TOKEN_STRING: VipsToken = 3;
pub const VipsToken_VIPS_TOKEN_EQUALS: VipsToken = 4;
pub const VipsToken_VIPS_TOKEN_COMMA: VipsToken = 5;
pub type VipsToken = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips__token_get(
        buffer: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__token_must(
        buffer: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__token_need(
        buffer: *const ::std::os::raw::c_char,
        need_token: VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__token_segment(
        p: *const ::std::os::raw::c_char,
        token: *mut VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__token_segment_need(
        p: *const ::std::os::raw::c_char,
        need_token: VipsToken,
        string: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__find_rightmost_brackets(
        p: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__filename_split8(
        name: *const ::std::os::raw::c_char,
        filename: *mut ::std::os::raw::c_char,
        option_string: *mut ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn vips_ispoweroftwo(p: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_amiMSBfirst() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__temp_name(format: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__change_suffix(
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_char,
        mx: ::std::os::raw::c_int,
        new_suff: *const ::std::os::raw::c_char,
        olds: *mut *const ::std::os::raw::c_char,
        nolds: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_realpath(path: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__random(seed: guint32) -> guint32;
}
unsafe extern "C" {
    pub fn vips__random_add(seed: guint32, value: ::std::os::raw::c_int) -> guint32;
}
unsafe extern "C" {
    pub fn vips__icc_dir() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__windows_prefix() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips__get_iso8601() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_strtod(str_: *const ::std::os::raw::c_char, out: *mut f64)
        -> ::std::os::raw::c_int;
}
pub type VipsObject = _VipsObject;
pub type VipsObjectClass = _VipsObjectClass;
pub const VipsArgumentFlags_VIPS_ARGUMENT_NONE: VipsArgumentFlags = 0;
pub const VipsArgumentFlags_VIPS_ARGUMENT_REQUIRED: VipsArgumentFlags = 1;
pub const VipsArgumentFlags_VIPS_ARGUMENT_CONSTRUCT: VipsArgumentFlags = 2;
pub const VipsArgumentFlags_VIPS_ARGUMENT_SET_ONCE: VipsArgumentFlags = 4;
pub const VipsArgumentFlags_VIPS_ARGUMENT_SET_ALWAYS: VipsArgumentFlags = 8;
pub const VipsArgumentFlags_VIPS_ARGUMENT_INPUT: VipsArgumentFlags = 16;
pub const VipsArgumentFlags_VIPS_ARGUMENT_OUTPUT: VipsArgumentFlags = 32;
pub const VipsArgumentFlags_VIPS_ARGUMENT_DEPRECATED: VipsArgumentFlags = 64;
pub const VipsArgumentFlags_VIPS_ARGUMENT_MODIFY: VipsArgumentFlags = 128;
pub const VipsArgumentFlags_VIPS_ARGUMENT_NON_HASHABLE: VipsArgumentFlags = 256;
pub type VipsArgumentFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArgument {
    pub pspec: *mut GParamSpec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArgument"][::std::mem::size_of::<_VipsArgument>() - 8usize];
    ["Alignment of _VipsArgument"][::std::mem::align_of::<_VipsArgument>() - 8usize];
    ["Offset of field: _VipsArgument::pspec"]
        [::std::mem::offset_of!(_VipsArgument, pspec) - 0usize];
};
pub type VipsArgument = _VipsArgument;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArgumentClass {
    pub parent: VipsArgument,
    pub object_class: *mut VipsObjectClass,
    pub flags: VipsArgumentFlags,
    pub priority: ::std::os::raw::c_int,
    pub offset: guint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArgumentClass"][::std::mem::size_of::<_VipsArgumentClass>() - 32usize];
    ["Alignment of _VipsArgumentClass"][::std::mem::align_of::<_VipsArgumentClass>() - 8usize];
    ["Offset of field: _VipsArgumentClass::parent"]
        [::std::mem::offset_of!(_VipsArgumentClass, parent) - 0usize];
    ["Offset of field: _VipsArgumentClass::object_class"]
        [::std::mem::offset_of!(_VipsArgumentClass, object_class) - 8usize];
    ["Offset of field: _VipsArgumentClass::flags"]
        [::std::mem::offset_of!(_VipsArgumentClass, flags) - 16usize];
    ["Offset of field: _VipsArgumentClass::priority"]
        [::std::mem::offset_of!(_VipsArgumentClass, priority) - 20usize];
    ["Offset of field: _VipsArgumentClass::offset"]
        [::std::mem::offset_of!(_VipsArgumentClass, offset) - 24usize];
};
pub type VipsArgumentClass = _VipsArgumentClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArgumentInstance {
    pub parent: VipsArgument,
    pub argument_class: *mut VipsArgumentClass,
    pub object: *mut VipsObject,
    pub assigned: gboolean,
    pub close_id: gulong,
    pub invalidate_id: gulong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArgumentInstance"][::std::mem::size_of::<_VipsArgumentInstance>() - 48usize];
    ["Alignment of _VipsArgumentInstance"]
        [::std::mem::align_of::<_VipsArgumentInstance>() - 8usize];
    ["Offset of field: _VipsArgumentInstance::parent"]
        [::std::mem::offset_of!(_VipsArgumentInstance, parent) - 0usize];
    ["Offset of field: _VipsArgumentInstance::argument_class"]
        [::std::mem::offset_of!(_VipsArgumentInstance, argument_class) - 8usize];
    ["Offset of field: _VipsArgumentInstance::object"]
        [::std::mem::offset_of!(_VipsArgumentInstance, object) - 16usize];
    ["Offset of field: _VipsArgumentInstance::assigned"]
        [::std::mem::offset_of!(_VipsArgumentInstance, assigned) - 24usize];
    ["Offset of field: _VipsArgumentInstance::close_id"]
        [::std::mem::offset_of!(_VipsArgumentInstance, close_id) - 32usize];
    ["Offset of field: _VipsArgumentInstance::invalidate_id"]
        [::std::mem::offset_of!(_VipsArgumentInstance, invalidate_id) - 40usize];
};
pub type VipsArgumentInstance = _VipsArgumentInstance;
pub type VipsArgumentTable = GHashTable;
unsafe extern "C" {
    pub fn vips_argument_get_id() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__object_set_member(
        object: *mut VipsObject,
        pspec: *mut GParamSpec,
        member: *mut *mut GObject,
        argument: *mut GObject,
    );
}
pub type VipsArgumentMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut VipsObject,
        pspec: *mut GParamSpec,
        argument_class: *mut VipsArgumentClass,
        argument_instance: *mut VipsArgumentInstance,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    pub fn vips_argument_map(
        object: *mut VipsObject,
        fn_: VipsArgumentMapFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_object_get_args(
        object: *mut VipsObject,
        names: *mut *mut *const ::std::os::raw::c_char,
        flags: *mut *mut ::std::os::raw::c_int,
        n_args: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type VipsArgumentClassMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        object_class: *mut VipsObjectClass,
        pspec: *mut GParamSpec,
        argument_class: *mut VipsArgumentClass,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    pub fn vips_argument_class_map(
        object_class: *mut VipsObjectClass,
        fn_: VipsArgumentClassMapFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_argument_class_needsstring(argument_class: *mut VipsArgumentClass) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_object_get_argument(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        pspec: *mut *mut GParamSpec,
        argument_class: *mut *mut VipsArgumentClass,
        argument_instance: *mut *mut VipsArgumentInstance,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_argument_isset(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_object_get_argument_flags(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> VipsArgumentFlags;
}
unsafe extern "C" {
    pub fn vips_object_get_argument_priority(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsObject {
    pub parent_instance: GObject,
    pub constructed: gboolean,
    pub static_object: gboolean,
    pub argument_table: *mut VipsArgumentTable,
    pub nickname: *mut ::std::os::raw::c_char,
    pub description: *mut ::std::os::raw::c_char,
    pub preclose: gboolean,
    pub close: gboolean,
    pub postclose: gboolean,
    pub local_memory: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsObject"][::std::mem::size_of::<_VipsObject>() - 80usize];
    ["Alignment of _VipsObject"][::std::mem::align_of::<_VipsObject>() - 8usize];
    ["Offset of field: _VipsObject::parent_instance"]
        [::std::mem::offset_of!(_VipsObject, parent_instance) - 0usize];
    ["Offset of field: _VipsObject::constructed"]
        [::std::mem::offset_of!(_VipsObject, constructed) - 24usize];
    ["Offset of field: _VipsObject::static_object"]
        [::std::mem::offset_of!(_VipsObject, static_object) - 28usize];
    ["Offset of field: _VipsObject::argument_table"]
        [::std::mem::offset_of!(_VipsObject, argument_table) - 32usize];
    ["Offset of field: _VipsObject::nickname"]
        [::std::mem::offset_of!(_VipsObject, nickname) - 40usize];
    ["Offset of field: _VipsObject::description"]
        [::std::mem::offset_of!(_VipsObject, description) - 48usize];
    ["Offset of field: _VipsObject::preclose"]
        [::std::mem::offset_of!(_VipsObject, preclose) - 56usize];
    ["Offset of field: _VipsObject::close"][::std::mem::offset_of!(_VipsObject, close) - 60usize];
    ["Offset of field: _VipsObject::postclose"]
        [::std::mem::offset_of!(_VipsObject, postclose) - 64usize];
    ["Offset of field: _VipsObject::local_memory"]
        [::std::mem::offset_of!(_VipsObject, local_memory) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsObjectClass {
    pub parent_class: GObjectClass,
    pub build: ::std::option::Option<
        unsafe extern "C" fn(object: *mut VipsObject) -> ::std::os::raw::c_int,
    >,
    pub postbuild: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut VipsObject,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub summary_class:
        ::std::option::Option<unsafe extern "C" fn(cls: *mut _VipsObjectClass, buf: *mut VipsBuf)>,
    pub summary:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub dump:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub sanity:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub rewind: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub preclose: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub close: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub postclose: ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject)>,
    pub new_from_string: ::std::option::Option<
        unsafe extern "C" fn(string: *const ::std::os::raw::c_char) -> *mut VipsObject,
    >,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject, buf: *mut VipsBuf)>,
    pub output_needs_arg: gboolean,
    pub output_to_arg: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut VipsObject,
            string: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub nickname: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub argument_table: *mut VipsArgumentTable,
    pub argument_table_traverse: *mut GSList,
    pub argument_table_traverse_gtype: GType,
    pub deprecated: gboolean,
    pub _vips_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _vips_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsObjectClass"][::std::mem::size_of::<_VipsObjectClass>() - 328usize];
    ["Alignment of _VipsObjectClass"][::std::mem::align_of::<_VipsObjectClass>() - 8usize];
    ["Offset of field: _VipsObjectClass::parent_class"]
        [::std::mem::offset_of!(_VipsObjectClass, parent_class) - 0usize];
    ["Offset of field: _VipsObjectClass::build"]
        [::std::mem::offset_of!(_VipsObjectClass, build) - 136usize];
    ["Offset of field: _VipsObjectClass::postbuild"]
        [::std::mem::offset_of!(_VipsObjectClass, postbuild) - 144usize];
    ["Offset of field: _VipsObjectClass::summary_class"]
        [::std::mem::offset_of!(_VipsObjectClass, summary_class) - 152usize];
    ["Offset of field: _VipsObjectClass::summary"]
        [::std::mem::offset_of!(_VipsObjectClass, summary) - 160usize];
    ["Offset of field: _VipsObjectClass::dump"]
        [::std::mem::offset_of!(_VipsObjectClass, dump) - 168usize];
    ["Offset of field: _VipsObjectClass::sanity"]
        [::std::mem::offset_of!(_VipsObjectClass, sanity) - 176usize];
    ["Offset of field: _VipsObjectClass::rewind"]
        [::std::mem::offset_of!(_VipsObjectClass, rewind) - 184usize];
    ["Offset of field: _VipsObjectClass::preclose"]
        [::std::mem::offset_of!(_VipsObjectClass, preclose) - 192usize];
    ["Offset of field: _VipsObjectClass::close"]
        [::std::mem::offset_of!(_VipsObjectClass, close) - 200usize];
    ["Offset of field: _VipsObjectClass::postclose"]
        [::std::mem::offset_of!(_VipsObjectClass, postclose) - 208usize];
    ["Offset of field: _VipsObjectClass::new_from_string"]
        [::std::mem::offset_of!(_VipsObjectClass, new_from_string) - 216usize];
    ["Offset of field: _VipsObjectClass::to_string"]
        [::std::mem::offset_of!(_VipsObjectClass, to_string) - 224usize];
    ["Offset of field: _VipsObjectClass::output_needs_arg"]
        [::std::mem::offset_of!(_VipsObjectClass, output_needs_arg) - 232usize];
    ["Offset of field: _VipsObjectClass::output_to_arg"]
        [::std::mem::offset_of!(_VipsObjectClass, output_to_arg) - 240usize];
    ["Offset of field: _VipsObjectClass::nickname"]
        [::std::mem::offset_of!(_VipsObjectClass, nickname) - 248usize];
    ["Offset of field: _VipsObjectClass::description"]
        [::std::mem::offset_of!(_VipsObjectClass, description) - 256usize];
    ["Offset of field: _VipsObjectClass::argument_table"]
        [::std::mem::offset_of!(_VipsObjectClass, argument_table) - 264usize];
    ["Offset of field: _VipsObjectClass::argument_table_traverse"]
        [::std::mem::offset_of!(_VipsObjectClass, argument_table_traverse) - 272usize];
    ["Offset of field: _VipsObjectClass::argument_table_traverse_gtype"]
        [::std::mem::offset_of!(_VipsObjectClass, argument_table_traverse_gtype) - 280usize];
    ["Offset of field: _VipsObjectClass::deprecated"]
        [::std::mem::offset_of!(_VipsObjectClass, deprecated) - 288usize];
    ["Offset of field: _VipsObjectClass::_vips_reserved1"]
        [::std::mem::offset_of!(_VipsObjectClass, _vips_reserved1) - 296usize];
    ["Offset of field: _VipsObjectClass::_vips_reserved2"]
        [::std::mem::offset_of!(_VipsObjectClass, _vips_reserved2) - 304usize];
    ["Offset of field: _VipsObjectClass::_vips_reserved3"]
        [::std::mem::offset_of!(_VipsObjectClass, _vips_reserved3) - 312usize];
    ["Offset of field: _VipsObjectClass::_vips_reserved4"]
        [::std::mem::offset_of!(_VipsObjectClass, _vips_reserved4) - 320usize];
};
unsafe extern "C" {
    pub fn vips_value_is_null(psoec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_object_set_property(
        gobject: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    );
}
unsafe extern "C" {
    pub fn vips_object_get_property(
        gobject: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    );
}
unsafe extern "C" {
    pub fn vips_object_preclose(object: *mut VipsObject);
}
unsafe extern "C" {
    pub fn vips_object_build(object: *mut VipsObject) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_summary_class(klass: *mut VipsObjectClass, buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_object_summary(object: *mut VipsObject, buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_object_dump(object: *mut VipsObject, buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_object_print_summary_class(klass: *mut VipsObjectClass);
}
unsafe extern "C" {
    pub fn vips_object_print_summary(object: *mut VipsObject);
}
unsafe extern "C" {
    pub fn vips_object_print_dump(object: *mut VipsObject);
}
unsafe extern "C" {
    pub fn vips_object_print_name(object: *mut VipsObject);
}
unsafe extern "C" {
    pub fn vips_object_sanity(object: *mut VipsObject) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_object_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_object_class_install_argument(
        cls: *mut VipsObjectClass,
        pspec: *mut GParamSpec,
        flags: VipsArgumentFlags,
        priority: ::std::os::raw::c_int,
        offset: guint,
    );
}
unsafe extern "C" {
    pub fn vips_object_set_argument_from_string(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_argument_needsstring(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_object_get_argument_to_string(
        object: *mut VipsObject,
        name: *const ::std::os::raw::c_char,
        arg: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_set_required(
        object: *mut VipsObject,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type VipsObjectSetArguments = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut VipsObject,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    pub fn vips_object_new(
        type_: GType,
        set: VipsObjectSetArguments,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut VipsObject;
}
unsafe extern "C" {
    pub fn vips_object_set_valist(
        object: *mut VipsObject,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_set(object: *mut VipsObject, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_set_from_string(
        object: *mut VipsObject,
        string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_object_new_from_string(
        object_class: *mut VipsObjectClass,
        p: *const ::std::os::raw::c_char,
    ) -> *mut VipsObject;
}
unsafe extern "C" {
    pub fn vips_object_to_string(object: *mut VipsObject, buf: *mut VipsBuf);
}
unsafe extern "C" {
    pub fn vips_object_map(
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub type VipsTypeMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: GType,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsTypeMap2Fn = ::std::option::Option<
    unsafe extern "C" fn(
        type_: GType,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsClassMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        cls: *mut VipsObjectClass,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    pub fn vips_type_map(
        base: GType,
        fn_: VipsTypeMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_type_map_all(
        base: GType,
        fn_: VipsTypeMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_type_depth(type_: GType) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_type_find(
        basename: *const ::std::os::raw::c_char,
        nickname: *const ::std::os::raw::c_char,
    ) -> GType;
}
unsafe extern "C" {
    pub fn vips_nickname_find(type_: GType) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_class_map_all(
        type_: GType,
        fn_: VipsClassMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_class_find(
        basename: *const ::std::os::raw::c_char,
        nickname: *const ::std::os::raw::c_char,
    ) -> *const VipsObjectClass;
}
unsafe extern "C" {
    pub fn vips_object_local_array(
        parent: *mut VipsObject,
        n: ::std::os::raw::c_int,
    ) -> *mut *mut VipsObject;
}
unsafe extern "C" {
    pub fn vips_object_local_cb(vobject: *mut VipsObject, gobject: *mut GObject);
}
unsafe extern "C" {
    pub fn vips_object_set_static(object: *mut VipsObject, static_object: gboolean);
}
unsafe extern "C" {
    pub fn vips_object_print_all();
}
unsafe extern "C" {
    pub fn vips_object_sanity_all();
}
unsafe extern "C" {
    pub fn vips_object_rewind(object: *mut VipsObject);
}
unsafe extern "C" {
    pub fn vips_object_unref_outputs(object: *mut VipsObject);
}
unsafe extern "C" {
    pub fn vips_object_get_description(object: *mut VipsObject) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThing {
    pub i: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsThing"][::std::mem::size_of::<_VipsThing>() - 4usize];
    ["Alignment of _VipsThing"][::std::mem::align_of::<_VipsThing>() - 4usize];
    ["Offset of field: _VipsThing::i"][::std::mem::offset_of!(_VipsThing, i) - 0usize];
};
pub type VipsThing = _VipsThing;
unsafe extern "C" {
    pub fn vips_thing_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_thing_new(i: ::std::os::raw::c_int) -> *mut VipsThing;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArea {
    pub data: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub n: ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_int,
    pub lock: *mut GMutex,
    pub free_fn: VipsCallbackFn,
    pub client: *mut ::std::os::raw::c_void,
    pub type_: GType,
    pub sizeof_type: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArea"][::std::mem::size_of::<_VipsArea>() - 64usize];
    ["Alignment of _VipsArea"][::std::mem::align_of::<_VipsArea>() - 8usize];
    ["Offset of field: _VipsArea::data"][::std::mem::offset_of!(_VipsArea, data) - 0usize];
    ["Offset of field: _VipsArea::length"][::std::mem::offset_of!(_VipsArea, length) - 8usize];
    ["Offset of field: _VipsArea::n"][::std::mem::offset_of!(_VipsArea, n) - 16usize];
    ["Offset of field: _VipsArea::count"][::std::mem::offset_of!(_VipsArea, count) - 20usize];
    ["Offset of field: _VipsArea::lock"][::std::mem::offset_of!(_VipsArea, lock) - 24usize];
    ["Offset of field: _VipsArea::free_fn"][::std::mem::offset_of!(_VipsArea, free_fn) - 32usize];
    ["Offset of field: _VipsArea::client"][::std::mem::offset_of!(_VipsArea, client) - 40usize];
    ["Offset of field: _VipsArea::type_"][::std::mem::offset_of!(_VipsArea, type_) - 48usize];
    ["Offset of field: _VipsArea::sizeof_type"]
        [::std::mem::offset_of!(_VipsArea, sizeof_type) - 56usize];
};
pub type VipsArea = _VipsArea;
unsafe extern "C" {
    pub fn vips_area_copy(area: *mut VipsArea) -> *mut VipsArea;
}
unsafe extern "C" {
    pub fn vips_area_free_cb(
        mem: *mut ::std::os::raw::c_void,
        area: *mut VipsArea,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_area_unref(area: *mut VipsArea);
}
unsafe extern "C" {
    pub fn vips_area_new(
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut VipsArea;
}
unsafe extern "C" {
    pub fn vips_area_new_array(
        type_: GType,
        sizeof_type: usize,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArea;
}
unsafe extern "C" {
    pub fn vips_area_new_array_object(n: ::std::os::raw::c_int) -> *mut VipsArea;
}
unsafe extern "C" {
    pub fn vips_area_get_data(
        area: *mut VipsArea,
        length: *mut usize,
        n: *mut ::std::os::raw::c_int,
        type_: *mut GType,
        sizeof_type: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_area_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_save_string_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSaveString {
    pub s: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSaveString"][::std::mem::size_of::<_VipsSaveString>() - 8usize];
    ["Alignment of _VipsSaveString"][::std::mem::align_of::<_VipsSaveString>() - 8usize];
    ["Offset of field: _VipsSaveString::s"][::std::mem::offset_of!(_VipsSaveString, s) - 0usize];
};
pub type VipsSaveString = _VipsSaveString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRefString {
    pub area: VipsArea,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsRefString"][::std::mem::size_of::<_VipsRefString>() - 64usize];
    ["Alignment of _VipsRefString"][::std::mem::align_of::<_VipsRefString>() - 8usize];
    ["Offset of field: _VipsRefString::area"]
        [::std::mem::offset_of!(_VipsRefString, area) - 0usize];
};
pub type VipsRefString = _VipsRefString;
unsafe extern "C" {
    pub fn vips_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut VipsRefString;
}
unsafe extern "C" {
    pub fn vips_ref_string_get(
        refstr: *mut VipsRefString,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_ref_string_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBlob {
    pub area: VipsArea,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsBlob"][::std::mem::size_of::<_VipsBlob>() - 64usize];
    ["Alignment of _VipsBlob"][::std::mem::align_of::<_VipsBlob>() - 8usize];
    ["Offset of field: _VipsBlob::area"][::std::mem::offset_of!(_VipsBlob, area) - 0usize];
};
pub type VipsBlob = _VipsBlob;
unsafe extern "C" {
    pub fn vips_blob_new(
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: usize,
    ) -> *mut VipsBlob;
}
unsafe extern "C" {
    pub fn vips_blob_copy(data: *const ::std::os::raw::c_void, length: usize) -> *mut VipsBlob;
}
unsafe extern "C" {
    pub fn vips_blob_get(blob: *mut VipsBlob, length: *mut usize) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_blob_set(
        blob: *mut VipsBlob,
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: usize,
    );
}
unsafe extern "C" {
    pub fn vips_blob_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArrayDouble {
    pub area: VipsArea,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArrayDouble"][::std::mem::size_of::<_VipsArrayDouble>() - 64usize];
    ["Alignment of _VipsArrayDouble"][::std::mem::align_of::<_VipsArrayDouble>() - 8usize];
    ["Offset of field: _VipsArrayDouble::area"]
        [::std::mem::offset_of!(_VipsArrayDouble, area) - 0usize];
};
pub type VipsArrayDouble = _VipsArrayDouble;
unsafe extern "C" {
    pub fn vips_array_double_new(
        array: *const f64,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayDouble;
}
unsafe extern "C" {
    pub fn vips_array_double_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayDouble;
}
unsafe extern "C" {
    pub fn vips_array_double_get(
        array: *mut VipsArrayDouble,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
}
unsafe extern "C" {
    pub fn vips_array_double_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArrayInt {
    pub area: VipsArea,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArrayInt"][::std::mem::size_of::<_VipsArrayInt>() - 64usize];
    ["Alignment of _VipsArrayInt"][::std::mem::align_of::<_VipsArrayInt>() - 8usize];
    ["Offset of field: _VipsArrayInt::area"][::std::mem::offset_of!(_VipsArrayInt, area) - 0usize];
};
pub type VipsArrayInt = _VipsArrayInt;
unsafe extern "C" {
    pub fn vips_array_int_new(
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayInt;
}
unsafe extern "C" {
    pub fn vips_array_int_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayInt;
}
unsafe extern "C" {
    pub fn vips_array_int_get(
        array: *mut VipsArrayInt,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_array_int_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsArrayImage {
    pub area: VipsArea,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsArrayImage"][::std::mem::size_of::<_VipsArrayImage>() - 64usize];
    ["Alignment of _VipsArrayImage"][::std::mem::align_of::<_VipsArrayImage>() - 8usize];
    ["Offset of field: _VipsArrayImage::area"]
        [::std::mem::offset_of!(_VipsArrayImage, area) - 0usize];
};
pub type VipsArrayImage = _VipsArrayImage;
unsafe extern "C" {
    pub fn vips_array_image_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_value_set_area(
        value: *mut GValue,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn vips_value_get_area(
        value: *const GValue,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_value_get_save_string(value: *const GValue) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_value_set_save_string(value: *mut GValue, str_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips_value_set_save_stringf(value: *mut GValue, fmt: *const ::std::os::raw::c_char, ...);
}
unsafe extern "C" {
    pub fn vips_value_get_ref_string(
        value: *const GValue,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_value_set_ref_string(value: *mut GValue, str_: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips_value_get_blob(
        value: *const GValue,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_value_set_blob(
        value: *mut GValue,
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: usize,
    );
}
unsafe extern "C" {
    pub fn vips_value_set_blob_free(
        value: *mut GValue,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    );
}
unsafe extern "C" {
    pub fn vips_value_set_array(
        value: *mut GValue,
        n: ::std::os::raw::c_int,
        type_: GType,
        sizeof_type: usize,
    );
}
unsafe extern "C" {
    pub fn vips_value_get_array(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
        type_: *mut GType,
        sizeof_type: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_value_get_array_double(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut f64;
}
unsafe extern "C" {
    pub fn vips_value_set_array_double(
        value: *mut GValue,
        array: *const f64,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_value_get_array_int(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_value_set_array_int(
        value: *mut GValue,
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_value_get_array_object(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut GObject;
}
unsafe extern "C" {
    pub fn vips_value_set_array_object(value: *mut GValue, n: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub static mut vips__thread_profile: gboolean;
}
unsafe extern "C" {
    pub fn vips_profile_set(profile: gboolean);
}
unsafe extern "C" {
    pub fn vips__thread_profile_attach(thread_name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips__thread_profile_detach();
}
unsafe extern "C" {
    pub fn vips__thread_profile_stop();
}
unsafe extern "C" {
    pub fn vips__thread_gate_start(gate_name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips__thread_gate_stop(gate_name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips__thread_malloc_free(size: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsConnection {
    pub parent_object: VipsObject,
    pub descriptor: ::std::os::raw::c_int,
    pub tracked_descriptor: ::std::os::raw::c_int,
    pub close_descriptor: ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsConnection"][::std::mem::size_of::<_VipsConnection>() - 104usize];
    ["Alignment of _VipsConnection"][::std::mem::align_of::<_VipsConnection>() - 8usize];
    ["Offset of field: _VipsConnection::parent_object"]
        [::std::mem::offset_of!(_VipsConnection, parent_object) - 0usize];
    ["Offset of field: _VipsConnection::descriptor"]
        [::std::mem::offset_of!(_VipsConnection, descriptor) - 80usize];
    ["Offset of field: _VipsConnection::tracked_descriptor"]
        [::std::mem::offset_of!(_VipsConnection, tracked_descriptor) - 84usize];
    ["Offset of field: _VipsConnection::close_descriptor"]
        [::std::mem::offset_of!(_VipsConnection, close_descriptor) - 88usize];
    ["Offset of field: _VipsConnection::filename"]
        [::std::mem::offset_of!(_VipsConnection, filename) - 96usize];
};
pub type VipsConnection = _VipsConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsConnectionClass {
    pub parent_class: VipsObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsConnectionClass"][::std::mem::size_of::<_VipsConnectionClass>() - 328usize];
    ["Alignment of _VipsConnectionClass"][::std::mem::align_of::<_VipsConnectionClass>() - 8usize];
    ["Offset of field: _VipsConnectionClass::parent_class"]
        [::std::mem::offset_of!(_VipsConnectionClass, parent_class) - 0usize];
};
pub type VipsConnectionClass = _VipsConnectionClass;
unsafe extern "C" {
    pub fn vips_connection_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_connection_filename(
        connection: *mut VipsConnection,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_connection_nick(connection: *mut VipsConnection) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_pipe_read_limit_set(limit: gint64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSource {
    pub parent_object: VipsConnection,
    pub decode: gboolean,
    pub have_tested_seek: gboolean,
    pub is_pipe: gboolean,
    pub read_position: gint64,
    pub length: gint64,
    pub data: *const ::std::os::raw::c_void,
    pub header_bytes: *mut GByteArray,
    pub sniff: *mut GByteArray,
    pub blob: *mut VipsBlob,
    pub mmap_baseaddr: *mut ::std::os::raw::c_void,
    pub mmap_length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSource"][::std::mem::size_of::<_VipsSource>() - 184usize];
    ["Alignment of _VipsSource"][::std::mem::align_of::<_VipsSource>() - 8usize];
    ["Offset of field: _VipsSource::parent_object"]
        [::std::mem::offset_of!(_VipsSource, parent_object) - 0usize];
    ["Offset of field: _VipsSource::decode"]
        [::std::mem::offset_of!(_VipsSource, decode) - 104usize];
    ["Offset of field: _VipsSource::have_tested_seek"]
        [::std::mem::offset_of!(_VipsSource, have_tested_seek) - 108usize];
    ["Offset of field: _VipsSource::is_pipe"]
        [::std::mem::offset_of!(_VipsSource, is_pipe) - 112usize];
    ["Offset of field: _VipsSource::read_position"]
        [::std::mem::offset_of!(_VipsSource, read_position) - 120usize];
    ["Offset of field: _VipsSource::length"]
        [::std::mem::offset_of!(_VipsSource, length) - 128usize];
    ["Offset of field: _VipsSource::data"][::std::mem::offset_of!(_VipsSource, data) - 136usize];
    ["Offset of field: _VipsSource::header_bytes"]
        [::std::mem::offset_of!(_VipsSource, header_bytes) - 144usize];
    ["Offset of field: _VipsSource::sniff"][::std::mem::offset_of!(_VipsSource, sniff) - 152usize];
    ["Offset of field: _VipsSource::blob"][::std::mem::offset_of!(_VipsSource, blob) - 160usize];
    ["Offset of field: _VipsSource::mmap_baseaddr"]
        [::std::mem::offset_of!(_VipsSource, mmap_baseaddr) - 168usize];
    ["Offset of field: _VipsSource::mmap_length"]
        [::std::mem::offset_of!(_VipsSource, mmap_length) - 176usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSourceClass {
    pub parent_class: VipsConnectionClass,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSource,
            arg2: *mut ::std::os::raw::c_void,
            arg3: usize,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSource,
            arg2: gint64,
            arg3: ::std::os::raw::c_int,
        ) -> gint64,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSourceClass"][::std::mem::size_of::<_VipsSourceClass>() - 344usize];
    ["Alignment of _VipsSourceClass"][::std::mem::align_of::<_VipsSourceClass>() - 8usize];
    ["Offset of field: _VipsSourceClass::parent_class"]
        [::std::mem::offset_of!(_VipsSourceClass, parent_class) - 0usize];
    ["Offset of field: _VipsSourceClass::read"]
        [::std::mem::offset_of!(_VipsSourceClass, read) - 328usize];
    ["Offset of field: _VipsSourceClass::seek"]
        [::std::mem::offset_of!(_VipsSourceClass, seek) - 336usize];
};
pub type VipsSourceClass = _VipsSourceClass;
unsafe extern "C" {
    pub fn vips_source_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_source_new_from_descriptor(descriptor: ::std::os::raw::c_int) -> *mut VipsSource;
}
unsafe extern "C" {
    pub fn vips_source_new_from_file(filename: *const ::std::os::raw::c_char) -> *mut VipsSource;
}
unsafe extern "C" {
    pub fn vips_source_new_from_blob(blob: *mut VipsBlob) -> *mut VipsSource;
}
unsafe extern "C" {
    pub fn vips_source_new_from_target(target: *mut VipsTarget) -> *mut VipsSource;
}
unsafe extern "C" {
    pub fn vips_source_new_from_memory(
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *mut VipsSource;
}
unsafe extern "C" {
    pub fn vips_source_new_from_options(options: *const ::std::os::raw::c_char) -> *mut VipsSource;
}
unsafe extern "C" {
    pub fn vips_source_minimise(source: *mut VipsSource);
}
unsafe extern "C" {
    pub fn vips_source_unminimise(source: *mut VipsSource) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_source_decode(source: *mut VipsSource) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_source_read(
        source: *mut VipsSource,
        data: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips_source_is_mappable(source: *mut VipsSource) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_source_is_file(source: *mut VipsSource) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_source_map(
        source: *mut VipsSource,
        length: *mut usize,
    ) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_source_map_blob(source: *mut VipsSource) -> *mut VipsBlob;
}
unsafe extern "C" {
    pub fn vips_source_seek(
        source: *mut VipsSource,
        offset: gint64,
        whence: ::std::os::raw::c_int,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips_source_rewind(source: *mut VipsSource) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_source_sniff_at_most(
        source: *mut VipsSource,
        data: *mut *mut ::std::os::raw::c_uchar,
        length: usize,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips_source_sniff(
        source: *mut VipsSource,
        length: usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn vips_source_length(source: *mut VipsSource) -> gint64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSourceCustom {
    pub parent_object: VipsSource,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSourceCustom"][::std::mem::size_of::<_VipsSourceCustom>() - 184usize];
    ["Alignment of _VipsSourceCustom"][::std::mem::align_of::<_VipsSourceCustom>() - 8usize];
    ["Offset of field: _VipsSourceCustom::parent_object"]
        [::std::mem::offset_of!(_VipsSourceCustom, parent_object) - 0usize];
};
pub type VipsSourceCustom = _VipsSourceCustom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSourceCustomClass {
    pub parent_class: VipsSourceClass,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSourceCustom,
            arg2: *mut ::std::os::raw::c_void,
            arg3: gint64,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsSourceCustom,
            arg2: gint64,
            arg3: ::std::os::raw::c_int,
        ) -> gint64,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSourceCustomClass"][::std::mem::size_of::<_VipsSourceCustomClass>() - 360usize];
    ["Alignment of _VipsSourceCustomClass"]
        [::std::mem::align_of::<_VipsSourceCustomClass>() - 8usize];
    ["Offset of field: _VipsSourceCustomClass::parent_class"]
        [::std::mem::offset_of!(_VipsSourceCustomClass, parent_class) - 0usize];
    ["Offset of field: _VipsSourceCustomClass::read"]
        [::std::mem::offset_of!(_VipsSourceCustomClass, read) - 344usize];
    ["Offset of field: _VipsSourceCustomClass::seek"]
        [::std::mem::offset_of!(_VipsSourceCustomClass, seek) - 352usize];
};
pub type VipsSourceCustomClass = _VipsSourceCustomClass;
unsafe extern "C" {
    pub fn vips_source_custom_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_source_custom_new() -> *mut VipsSourceCustom;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsGInputStream {
    pub parent_instance: GInputStream,
    pub source: *mut VipsSource,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsGInputStream"][::std::mem::size_of::<_VipsGInputStream>() - 40usize];
    ["Alignment of _VipsGInputStream"][::std::mem::align_of::<_VipsGInputStream>() - 8usize];
    ["Offset of field: _VipsGInputStream::parent_instance"]
        [::std::mem::offset_of!(_VipsGInputStream, parent_instance) - 0usize];
    ["Offset of field: _VipsGInputStream::source"]
        [::std::mem::offset_of!(_VipsGInputStream, source) - 32usize];
};
pub type VipsGInputStream = _VipsGInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsGInputStreamClass {
    pub parent_class: GInputStreamClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsGInputStreamClass"][::std::mem::size_of::<_VipsGInputStreamClass>() - 248usize];
    ["Alignment of _VipsGInputStreamClass"]
        [::std::mem::align_of::<_VipsGInputStreamClass>() - 8usize];
    ["Offset of field: _VipsGInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_VipsGInputStreamClass, parent_class) - 0usize];
};
pub type VipsGInputStreamClass = _VipsGInputStreamClass;
unsafe extern "C" {
    pub fn vips_g_input_stream_new_from_source(source: *mut VipsSource) -> *mut GInputStream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSourceGInputStream {
    pub parent_instance: VipsSource,
    pub stream: *mut GInputStream,
    pub seekable: *mut GSeekable,
    pub info: *mut GFileInfo,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSourceGInputStream"]
        [::std::mem::size_of::<_VipsSourceGInputStream>() - 208usize];
    ["Alignment of _VipsSourceGInputStream"]
        [::std::mem::align_of::<_VipsSourceGInputStream>() - 8usize];
    ["Offset of field: _VipsSourceGInputStream::parent_instance"]
        [::std::mem::offset_of!(_VipsSourceGInputStream, parent_instance) - 0usize];
    ["Offset of field: _VipsSourceGInputStream::stream"]
        [::std::mem::offset_of!(_VipsSourceGInputStream, stream) - 184usize];
    ["Offset of field: _VipsSourceGInputStream::seekable"]
        [::std::mem::offset_of!(_VipsSourceGInputStream, seekable) - 192usize];
    ["Offset of field: _VipsSourceGInputStream::info"]
        [::std::mem::offset_of!(_VipsSourceGInputStream, info) - 200usize];
};
pub type VipsSourceGInputStream = _VipsSourceGInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSourceGInputStreamClass {
    pub parent_class: VipsSourceClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSourceGInputStreamClass"]
        [::std::mem::size_of::<_VipsSourceGInputStreamClass>() - 344usize];
    ["Alignment of _VipsSourceGInputStreamClass"]
        [::std::mem::align_of::<_VipsSourceGInputStreamClass>() - 8usize];
    ["Offset of field: _VipsSourceGInputStreamClass::parent_class"]
        [::std::mem::offset_of!(_VipsSourceGInputStreamClass, parent_class) - 0usize];
};
pub type VipsSourceGInputStreamClass = _VipsSourceGInputStreamClass;
unsafe extern "C" {
    pub fn vips_source_g_input_stream_new(stream: *mut GInputStream)
        -> *mut VipsSourceGInputStream;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsTarget {
    pub parent_object: VipsConnection,
    pub memory: gboolean,
    pub ended: gboolean,
    pub memory_buffer: *mut GString,
    pub blob: *mut VipsBlob,
    pub output_buffer: [::std::os::raw::c_uchar; 8500usize],
    pub write_point: ::std::os::raw::c_int,
    pub position: off_t,
    pub delete_on_close: gboolean,
    pub delete_on_close_filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsTarget"][::std::mem::size_of::<_VipsTarget>() - 8656usize];
    ["Alignment of _VipsTarget"][::std::mem::align_of::<_VipsTarget>() - 8usize];
    ["Offset of field: _VipsTarget::parent_object"]
        [::std::mem::offset_of!(_VipsTarget, parent_object) - 0usize];
    ["Offset of field: _VipsTarget::memory"]
        [::std::mem::offset_of!(_VipsTarget, memory) - 104usize];
    ["Offset of field: _VipsTarget::ended"][::std::mem::offset_of!(_VipsTarget, ended) - 108usize];
    ["Offset of field: _VipsTarget::memory_buffer"]
        [::std::mem::offset_of!(_VipsTarget, memory_buffer) - 112usize];
    ["Offset of field: _VipsTarget::blob"][::std::mem::offset_of!(_VipsTarget, blob) - 120usize];
    ["Offset of field: _VipsTarget::output_buffer"]
        [::std::mem::offset_of!(_VipsTarget, output_buffer) - 128usize];
    ["Offset of field: _VipsTarget::write_point"]
        [::std::mem::offset_of!(_VipsTarget, write_point) - 8628usize];
    ["Offset of field: _VipsTarget::position"]
        [::std::mem::offset_of!(_VipsTarget, position) - 8632usize];
    ["Offset of field: _VipsTarget::delete_on_close"]
        [::std::mem::offset_of!(_VipsTarget, delete_on_close) - 8640usize];
    ["Offset of field: _VipsTarget::delete_on_close_filename"]
        [::std::mem::offset_of!(_VipsTarget, delete_on_close_filename) - 8648usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsTargetClass {
    pub parent_class: VipsConnectionClass,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTarget,
            arg2: *const ::std::os::raw::c_void,
            arg3: usize,
        ) -> gint64,
    >,
    pub finish: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VipsTarget)>,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTarget,
            arg2: *mut ::std::os::raw::c_void,
            arg3: usize,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTarget,
            offset: off_t,
            whence: ::std::os::raw::c_int,
        ) -> off_t,
    >,
    pub end:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut VipsTarget) -> ::std::os::raw::c_int>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsTargetClass"][::std::mem::size_of::<_VipsTargetClass>() - 368usize];
    ["Alignment of _VipsTargetClass"][::std::mem::align_of::<_VipsTargetClass>() - 8usize];
    ["Offset of field: _VipsTargetClass::parent_class"]
        [::std::mem::offset_of!(_VipsTargetClass, parent_class) - 0usize];
    ["Offset of field: _VipsTargetClass::write"]
        [::std::mem::offset_of!(_VipsTargetClass, write) - 328usize];
    ["Offset of field: _VipsTargetClass::finish"]
        [::std::mem::offset_of!(_VipsTargetClass, finish) - 336usize];
    ["Offset of field: _VipsTargetClass::read"]
        [::std::mem::offset_of!(_VipsTargetClass, read) - 344usize];
    ["Offset of field: _VipsTargetClass::seek"]
        [::std::mem::offset_of!(_VipsTargetClass, seek) - 352usize];
    ["Offset of field: _VipsTargetClass::end"]
        [::std::mem::offset_of!(_VipsTargetClass, end) - 360usize];
};
pub type VipsTargetClass = _VipsTargetClass;
unsafe extern "C" {
    pub fn vips_target_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_target_new_to_descriptor(descriptor: ::std::os::raw::c_int) -> *mut VipsTarget;
}
unsafe extern "C" {
    pub fn vips_target_new_to_file(filename: *const ::std::os::raw::c_char) -> *mut VipsTarget;
}
unsafe extern "C" {
    pub fn vips_target_new_to_memory() -> *mut VipsTarget;
}
unsafe extern "C" {
    pub fn vips_target_new_temp(target: *mut VipsTarget) -> *mut VipsTarget;
}
unsafe extern "C" {
    pub fn vips_target_write(
        target: *mut VipsTarget,
        data: *const ::std::os::raw::c_void,
        length: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_target_read(
        target: *mut VipsTarget,
        buffer: *mut ::std::os::raw::c_void,
        length: usize,
    ) -> gint64;
}
unsafe extern "C" {
    pub fn vips_target_seek(
        target: *mut VipsTarget,
        offset: off_t,
        whence: ::std::os::raw::c_int,
    ) -> off_t;
}
unsafe extern "C" {
    pub fn vips_target_end(target: *mut VipsTarget) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_target_finish(target: *mut VipsTarget);
}
unsafe extern "C" {
    pub fn vips_target_steal(
        target: *mut VipsTarget,
        length: *mut usize,
    ) -> *mut ::std::os::raw::c_uchar;
}
unsafe extern "C" {
    pub fn vips_target_steal_text(target: *mut VipsTarget) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_target_putc(
        target: *mut VipsTarget,
        ch: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_target_writes(
        target: *mut VipsTarget,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_target_writef(
        target: *mut VipsTarget,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_target_write_amp(
        target: *mut VipsTarget,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsTargetCustom {
    pub parent_object: VipsTarget,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsTargetCustom"][::std::mem::size_of::<_VipsTargetCustom>() - 8656usize];
    ["Alignment of _VipsTargetCustom"][::std::mem::align_of::<_VipsTargetCustom>() - 8usize];
    ["Offset of field: _VipsTargetCustom::parent_object"]
        [::std::mem::offset_of!(_VipsTargetCustom, parent_object) - 0usize];
};
pub type VipsTargetCustom = _VipsTargetCustom;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsTargetCustomClass {
    pub parent_class: VipsTargetClass,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTargetCustom,
            arg2: *const ::std::os::raw::c_void,
            arg3: gint64,
        ) -> gint64,
    >,
    pub finish: ::std::option::Option<unsafe extern "C" fn(arg1: *mut VipsTargetCustom)>,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTargetCustom,
            arg2: *mut ::std::os::raw::c_void,
            arg3: gint64,
        ) -> gint64,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsTargetCustom,
            arg2: gint64,
            arg3: ::std::os::raw::c_int,
        ) -> gint64,
    >,
    pub end: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut VipsTargetCustom) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsTargetCustomClass"][::std::mem::size_of::<_VipsTargetCustomClass>() - 408usize];
    ["Alignment of _VipsTargetCustomClass"]
        [::std::mem::align_of::<_VipsTargetCustomClass>() - 8usize];
    ["Offset of field: _VipsTargetCustomClass::parent_class"]
        [::std::mem::offset_of!(_VipsTargetCustomClass, parent_class) - 0usize];
    ["Offset of field: _VipsTargetCustomClass::write"]
        [::std::mem::offset_of!(_VipsTargetCustomClass, write) - 368usize];
    ["Offset of field: _VipsTargetCustomClass::finish"]
        [::std::mem::offset_of!(_VipsTargetCustomClass, finish) - 376usize];
    ["Offset of field: _VipsTargetCustomClass::read"]
        [::std::mem::offset_of!(_VipsTargetCustomClass, read) - 384usize];
    ["Offset of field: _VipsTargetCustomClass::seek"]
        [::std::mem::offset_of!(_VipsTargetCustomClass, seek) - 392usize];
    ["Offset of field: _VipsTargetCustomClass::end"]
        [::std::mem::offset_of!(_VipsTargetCustomClass, end) - 400usize];
};
pub type VipsTargetCustomClass = _VipsTargetCustomClass;
unsafe extern "C" {
    pub fn vips_target_custom_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_target_custom_new() -> *mut VipsTargetCustom;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSbuf {
    pub parent_object: VipsObject,
    pub source: *mut VipsSource,
    pub input_buffer: [::std::os::raw::c_uchar; 4097usize],
    pub chars_in_buffer: ::std::os::raw::c_int,
    pub read_point: ::std::os::raw::c_int,
    pub line: [::std::os::raw::c_uchar; 4097usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSbuf"][::std::mem::size_of::<_VipsSbuf>() - 8296usize];
    ["Alignment of _VipsSbuf"][::std::mem::align_of::<_VipsSbuf>() - 8usize];
    ["Offset of field: _VipsSbuf::parent_object"]
        [::std::mem::offset_of!(_VipsSbuf, parent_object) - 0usize];
    ["Offset of field: _VipsSbuf::source"][::std::mem::offset_of!(_VipsSbuf, source) - 80usize];
    ["Offset of field: _VipsSbuf::input_buffer"]
        [::std::mem::offset_of!(_VipsSbuf, input_buffer) - 88usize];
    ["Offset of field: _VipsSbuf::chars_in_buffer"]
        [::std::mem::offset_of!(_VipsSbuf, chars_in_buffer) - 4188usize];
    ["Offset of field: _VipsSbuf::read_point"]
        [::std::mem::offset_of!(_VipsSbuf, read_point) - 4192usize];
    ["Offset of field: _VipsSbuf::line"][::std::mem::offset_of!(_VipsSbuf, line) - 4196usize];
};
pub type VipsSbuf = _VipsSbuf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsSbufClass {
    pub parent_class: VipsObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsSbufClass"][::std::mem::size_of::<_VipsSbufClass>() - 328usize];
    ["Alignment of _VipsSbufClass"][::std::mem::align_of::<_VipsSbufClass>() - 8usize];
    ["Offset of field: _VipsSbufClass::parent_class"]
        [::std::mem::offset_of!(_VipsSbufClass, parent_class) - 0usize];
};
pub type VipsSbufClass = _VipsSbufClass;
unsafe extern "C" {
    pub fn vips_sbuf_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_sbuf_new_from_source(source: *mut VipsSource) -> *mut VipsSbuf;
}
unsafe extern "C" {
    pub fn vips_sbuf_unbuffer(sbuf: *mut VipsSbuf);
}
unsafe extern "C" {
    pub fn vips_sbuf_getc(sbuf: *mut VipsSbuf) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sbuf_ungetc(sbuf: *mut VipsSbuf);
}
unsafe extern "C" {
    pub fn vips_sbuf_require(
        sbuf: *mut VipsSbuf,
        require: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sbuf_get_line(sbuf: *mut VipsSbuf) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_sbuf_get_line_copy(sbuf: *mut VipsSbuf) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_sbuf_get_non_whitespace(sbuf: *mut VipsSbuf) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_sbuf_skip_whitespace(sbuf: *mut VipsSbuf) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRect {
    pub left: ::std::os::raw::c_int,
    pub top: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsRect"][::std::mem::size_of::<_VipsRect>() - 16usize];
    ["Alignment of _VipsRect"][::std::mem::align_of::<_VipsRect>() - 4usize];
    ["Offset of field: _VipsRect::left"][::std::mem::offset_of!(_VipsRect, left) - 0usize];
    ["Offset of field: _VipsRect::top"][::std::mem::offset_of!(_VipsRect, top) - 4usize];
    ["Offset of field: _VipsRect::width"][::std::mem::offset_of!(_VipsRect, width) - 8usize];
    ["Offset of field: _VipsRect::height"][::std::mem::offset_of!(_VipsRect, height) - 12usize];
};
pub type VipsRect = _VipsRect;
unsafe extern "C" {
    pub fn vips_rect_isempty(r: *const VipsRect) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_rect_includespoint(
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_rect_includesrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_rect_equalsrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_rect_overlapsrect(r1: *const VipsRect, r2: *const VipsRect) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_rect_marginadjust(r: *mut VipsRect, n: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_rect_intersectrect(r1: *const VipsRect, r2: *const VipsRect, out: *mut VipsRect);
}
unsafe extern "C" {
    pub fn vips_rect_unionrect(r1: *const VipsRect, r2: *const VipsRect, out: *mut VipsRect);
}
unsafe extern "C" {
    pub fn vips_rect_dup(r: *const VipsRect) -> *mut VipsRect;
}
unsafe extern "C" {
    pub fn vips_rect_normalise(r: *mut VipsRect);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VipsWindow {
    pub ref_count: ::std::os::raw::c_int,
    pub im: *mut _VipsImage,
    pub top: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub data: *mut VipsPel,
    pub baseaddr: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VipsWindow"][::std::mem::size_of::<VipsWindow>() - 48usize];
    ["Alignment of VipsWindow"][::std::mem::align_of::<VipsWindow>() - 8usize];
    ["Offset of field: VipsWindow::ref_count"]
        [::std::mem::offset_of!(VipsWindow, ref_count) - 0usize];
    ["Offset of field: VipsWindow::im"][::std::mem::offset_of!(VipsWindow, im) - 8usize];
    ["Offset of field: VipsWindow::top"][::std::mem::offset_of!(VipsWindow, top) - 16usize];
    ["Offset of field: VipsWindow::height"][::std::mem::offset_of!(VipsWindow, height) - 20usize];
    ["Offset of field: VipsWindow::data"][::std::mem::offset_of!(VipsWindow, data) - 24usize];
    ["Offset of field: VipsWindow::baseaddr"]
        [::std::mem::offset_of!(VipsWindow, baseaddr) - 32usize];
    ["Offset of field: VipsWindow::length"][::std::mem::offset_of!(VipsWindow, length) - 40usize];
};
unsafe extern "C" {
    pub fn vips_window_unref(window: *mut VipsWindow) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_window_print(window: *mut VipsWindow);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VipsBufferThread {
    pub hash: *mut GHashTable,
    pub thread: *mut GThread,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VipsBufferThread"][::std::mem::size_of::<VipsBufferThread>() - 16usize];
    ["Alignment of VipsBufferThread"][::std::mem::align_of::<VipsBufferThread>() - 8usize];
    ["Offset of field: VipsBufferThread::hash"]
        [::std::mem::offset_of!(VipsBufferThread, hash) - 0usize];
    ["Offset of field: VipsBufferThread::thread"]
        [::std::mem::offset_of!(VipsBufferThread, thread) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBufferCache {
    pub buffers: *mut GSList,
    pub thread: *mut GThread,
    pub im: *mut _VipsImage,
    pub buffer_thread: *mut VipsBufferThread,
    pub reserve: *mut GSList,
    pub n_reserve: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsBufferCache"][::std::mem::size_of::<_VipsBufferCache>() - 48usize];
    ["Alignment of _VipsBufferCache"][::std::mem::align_of::<_VipsBufferCache>() - 8usize];
    ["Offset of field: _VipsBufferCache::buffers"]
        [::std::mem::offset_of!(_VipsBufferCache, buffers) - 0usize];
    ["Offset of field: _VipsBufferCache::thread"]
        [::std::mem::offset_of!(_VipsBufferCache, thread) - 8usize];
    ["Offset of field: _VipsBufferCache::im"]
        [::std::mem::offset_of!(_VipsBufferCache, im) - 16usize];
    ["Offset of field: _VipsBufferCache::buffer_thread"]
        [::std::mem::offset_of!(_VipsBufferCache, buffer_thread) - 24usize];
    ["Offset of field: _VipsBufferCache::reserve"]
        [::std::mem::offset_of!(_VipsBufferCache, reserve) - 32usize];
    ["Offset of field: _VipsBufferCache::n_reserve"]
        [::std::mem::offset_of!(_VipsBufferCache, n_reserve) - 40usize];
};
pub type VipsBufferCache = _VipsBufferCache;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsBuffer {
    pub ref_count: ::std::os::raw::c_int,
    pub im: *mut _VipsImage,
    pub area: VipsRect,
    pub done: gboolean,
    pub cache: *mut VipsBufferCache,
    pub buf: *mut VipsPel,
    pub bsize: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsBuffer"][::std::mem::size_of::<_VipsBuffer>() - 64usize];
    ["Alignment of _VipsBuffer"][::std::mem::align_of::<_VipsBuffer>() - 8usize];
    ["Offset of field: _VipsBuffer::ref_count"]
        [::std::mem::offset_of!(_VipsBuffer, ref_count) - 0usize];
    ["Offset of field: _VipsBuffer::im"][::std::mem::offset_of!(_VipsBuffer, im) - 8usize];
    ["Offset of field: _VipsBuffer::area"][::std::mem::offset_of!(_VipsBuffer, area) - 16usize];
    ["Offset of field: _VipsBuffer::done"][::std::mem::offset_of!(_VipsBuffer, done) - 32usize];
    ["Offset of field: _VipsBuffer::cache"][::std::mem::offset_of!(_VipsBuffer, cache) - 40usize];
    ["Offset of field: _VipsBuffer::buf"][::std::mem::offset_of!(_VipsBuffer, buf) - 48usize];
    ["Offset of field: _VipsBuffer::bsize"][::std::mem::offset_of!(_VipsBuffer, bsize) - 56usize];
};
pub type VipsBuffer = _VipsBuffer;
unsafe extern "C" {
    pub fn vips_buffer_dump_all();
}
unsafe extern "C" {
    pub fn vips_buffer_done(buffer: *mut VipsBuffer);
}
unsafe extern "C" {
    pub fn vips_buffer_undone(buffer: *mut VipsBuffer);
}
unsafe extern "C" {
    pub fn vips_buffer_unref(buffer: *mut VipsBuffer);
}
unsafe extern "C" {
    pub fn vips_buffer_new(im: *mut _VipsImage, area: *mut VipsRect) -> *mut VipsBuffer;
}
unsafe extern "C" {
    pub fn vips_buffer_ref(im: *mut _VipsImage, area: *mut VipsRect) -> *mut VipsBuffer;
}
unsafe extern "C" {
    pub fn vips_buffer_unref_ref(
        buffer: *mut VipsBuffer,
        im: *mut _VipsImage,
        area: *mut VipsRect,
    ) -> *mut VipsBuffer;
}
unsafe extern "C" {
    pub fn vips_buffer_print(buffer: *mut VipsBuffer);
}
unsafe extern "C" {
    pub fn vips__render_shutdown();
}
pub const _RegionType_VIPS_REGION_NONE: _RegionType = 0;
pub const _RegionType_VIPS_REGION_BUFFER: _RegionType = 1;
pub const _RegionType_VIPS_REGION_OTHER_REGION: _RegionType = 2;
pub const _RegionType_VIPS_REGION_OTHER_IMAGE: _RegionType = 3;
pub const _RegionType_VIPS_REGION_WINDOW: _RegionType = 4;
pub type _RegionType = ::std::os::raw::c_uint;
pub use self::_RegionType as RegionType;
unsafe extern "C" {
    pub fn vips__region_take_ownership(reg: *mut _VipsRegion);
}
unsafe extern "C" {
    pub fn vips__region_check_ownership(reg: *mut _VipsRegion);
}
unsafe extern "C" {
    pub fn vips__region_no_ownership(reg: *mut _VipsRegion);
}
pub type VipsRegionFillFn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut _VipsRegion,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn vips_region_fill(
        reg: *mut _VipsRegion,
        r: *const VipsRect,
        fn_: VipsRegionFillFn,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__image_wio_output(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__image_pio_output(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__argument_get_instance(
        argument_class: *mut VipsArgumentClass,
        object: *mut VipsObject,
    ) -> *mut VipsArgumentInstance;
}
unsafe extern "C" {
    pub fn vips__argument_table_lookup(
        table: *mut VipsArgumentTable,
        pspec: *mut GParamSpec,
    ) -> *mut VipsArgument;
}
unsafe extern "C" {
    pub fn vips__demand_hint_array(
        image: *mut _VipsImage,
        hint: ::std::os::raw::c_int,
        in_: *mut *mut _VipsImage,
    );
}
unsafe extern "C" {
    pub fn vips__image_copy_fields_array(
        out: *mut _VipsImage,
        in_: *mut *mut _VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__region_count_pixels(
        region: *mut _VipsRegion,
        nickname: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn vips_region_dump_all();
}
unsafe extern "C" {
    pub fn vips_region_prepare_many(
        reg: *mut *mut _VipsRegion,
        r: *const VipsRect,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__view_image(image: *mut _VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub static mut _vips__argument_id: ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips__meta_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct im__INTMASK {
    pub xsize: ::std::os::raw::c_int,
    pub ysize: ::std::os::raw::c_int,
    pub scale: ::std::os::raw::c_int,
    pub offset: ::std::os::raw::c_int,
    pub coeff: *mut ::std::os::raw::c_int,
    pub filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of im__INTMASK"][::std::mem::size_of::<im__INTMASK>() - 32usize];
    ["Alignment of im__INTMASK"][::std::mem::align_of::<im__INTMASK>() - 8usize];
    ["Offset of field: im__INTMASK::xsize"][::std::mem::offset_of!(im__INTMASK, xsize) - 0usize];
    ["Offset of field: im__INTMASK::ysize"][::std::mem::offset_of!(im__INTMASK, ysize) - 4usize];
    ["Offset of field: im__INTMASK::scale"][::std::mem::offset_of!(im__INTMASK, scale) - 8usize];
    ["Offset of field: im__INTMASK::offset"][::std::mem::offset_of!(im__INTMASK, offset) - 12usize];
    ["Offset of field: im__INTMASK::coeff"][::std::mem::offset_of!(im__INTMASK, coeff) - 16usize];
    ["Offset of field: im__INTMASK::filename"]
        [::std::mem::offset_of!(im__INTMASK, filename) - 24usize];
};
pub type INTMASK = im__INTMASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct im__DOUBLEMASK {
    pub xsize: ::std::os::raw::c_int,
    pub ysize: ::std::os::raw::c_int,
    pub scale: f64,
    pub offset: f64,
    pub coeff: *mut f64,
    pub filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of im__DOUBLEMASK"][::std::mem::size_of::<im__DOUBLEMASK>() - 40usize];
    ["Alignment of im__DOUBLEMASK"][::std::mem::align_of::<im__DOUBLEMASK>() - 8usize];
    ["Offset of field: im__DOUBLEMASK::xsize"]
        [::std::mem::offset_of!(im__DOUBLEMASK, xsize) - 0usize];
    ["Offset of field: im__DOUBLEMASK::ysize"]
        [::std::mem::offset_of!(im__DOUBLEMASK, ysize) - 4usize];
    ["Offset of field: im__DOUBLEMASK::scale"]
        [::std::mem::offset_of!(im__DOUBLEMASK, scale) - 8usize];
    ["Offset of field: im__DOUBLEMASK::offset"]
        [::std::mem::offset_of!(im__DOUBLEMASK, offset) - 16usize];
    ["Offset of field: im__DOUBLEMASK::coeff"]
        [::std::mem::offset_of!(im__DOUBLEMASK, coeff) - 24usize];
    ["Offset of field: im__DOUBLEMASK::filename"]
        [::std::mem::offset_of!(im__DOUBLEMASK, filename) - 32usize];
};
pub type DOUBLEMASK = im__DOUBLEMASK;
unsafe extern "C" {
    pub fn im_create_imask(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_create_imaskv(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        ...
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_create_dmask(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_create_dmaskv(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        ...
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_read_imask(filename: *const ::std::os::raw::c_char) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_read_dmask(filename: *const ::std::os::raw::c_char) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_print_imask(in_: *mut INTMASK);
}
unsafe extern "C" {
    pub fn im_print_dmask(in_: *mut DOUBLEMASK);
}
unsafe extern "C" {
    pub fn im_write_imask(in_: *mut INTMASK) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_write_dmask(in_: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_write_imask_name(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_write_dmask_name(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_free_imask(in_: *mut INTMASK) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_free_dmask(in_: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_log_imask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_log_dmask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_gauss_imask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_gauss_imask_sep(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_gauss_dmask(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_gauss_dmask_sep(
        filename: *const ::std::os::raw::c_char,
        sigma: f64,
        min_ampl: f64,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_dup_imask(in_: *mut INTMASK, filename: *const ::std::os::raw::c_char)
        -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_dup_dmask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_scale_dmask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_norm_dmask(mask: *mut DOUBLEMASK);
}
unsafe extern "C" {
    pub fn im_imask2dmask(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_dmask2imask(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_rotate_imask90(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_rotate_imask45(
        in_: *mut INTMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut INTMASK;
}
unsafe extern "C" {
    pub fn im_rotate_dmask90(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_rotate_dmask45(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_mattrn(
        in_: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_matcat(
        top: *mut DOUBLEMASK,
        bottom: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_matmul(
        in1: *mut DOUBLEMASK,
        in2: *mut DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_lu_decomp(
        mat: *const DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_lu_solve(lu: *const DOUBLEMASK, vec: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_matinv(
        mat: *const DOUBLEMASK,
        filename: *const ::std::os::raw::c_char,
    ) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_matinv_inplace(mat: *mut DOUBLEMASK) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_local_dmask(out: *mut _VipsImage, mask: *mut DOUBLEMASK) -> *mut DOUBLEMASK;
}
unsafe extern "C" {
    pub fn im_local_imask(out: *mut _VipsImage, mask: *mut INTMASK) -> *mut INTMASK;
}
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MEAN: VipsRegionShrink = 0;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MEDIAN: VipsRegionShrink = 1;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MODE: VipsRegionShrink = 2;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MAX: VipsRegionShrink = 3;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_MIN: VipsRegionShrink = 4;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_NEAREST: VipsRegionShrink = 5;
pub const VipsRegionShrink_VIPS_REGION_SHRINK_LAST: VipsRegionShrink = 6;
pub type VipsRegionShrink = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRegion {
    pub parent_object: VipsObject,
    pub im: *mut VipsImage,
    pub valid: VipsRect,
    pub type_: RegionType,
    pub data: *mut VipsPel,
    pub bpl: ::std::os::raw::c_int,
    pub seq: *mut ::std::os::raw::c_void,
    pub thread: *mut GThread,
    pub window: *mut VipsWindow,
    pub buffer: *mut VipsBuffer,
    pub invalid: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsRegion"][::std::mem::size_of::<_VipsRegion>() - 168usize];
    ["Alignment of _VipsRegion"][::std::mem::align_of::<_VipsRegion>() - 8usize];
    ["Offset of field: _VipsRegion::parent_object"]
        [::std::mem::offset_of!(_VipsRegion, parent_object) - 0usize];
    ["Offset of field: _VipsRegion::im"][::std::mem::offset_of!(_VipsRegion, im) - 80usize];
    ["Offset of field: _VipsRegion::valid"][::std::mem::offset_of!(_VipsRegion, valid) - 88usize];
    ["Offset of field: _VipsRegion::type_"][::std::mem::offset_of!(_VipsRegion, type_) - 104usize];
    ["Offset of field: _VipsRegion::data"][::std::mem::offset_of!(_VipsRegion, data) - 112usize];
    ["Offset of field: _VipsRegion::bpl"][::std::mem::offset_of!(_VipsRegion, bpl) - 120usize];
    ["Offset of field: _VipsRegion::seq"][::std::mem::offset_of!(_VipsRegion, seq) - 128usize];
    ["Offset of field: _VipsRegion::thread"]
        [::std::mem::offset_of!(_VipsRegion, thread) - 136usize];
    ["Offset of field: _VipsRegion::window"]
        [::std::mem::offset_of!(_VipsRegion, window) - 144usize];
    ["Offset of field: _VipsRegion::buffer"]
        [::std::mem::offset_of!(_VipsRegion, buffer) - 152usize];
    ["Offset of field: _VipsRegion::invalid"]
        [::std::mem::offset_of!(_VipsRegion, invalid) - 160usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsRegionClass {
    pub parent_class: VipsObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsRegionClass"][::std::mem::size_of::<_VipsRegionClass>() - 328usize];
    ["Alignment of _VipsRegionClass"][::std::mem::align_of::<_VipsRegionClass>() - 8usize];
    ["Offset of field: _VipsRegionClass::parent_class"]
        [::std::mem::offset_of!(_VipsRegionClass, parent_class) - 0usize];
};
pub type VipsRegionClass = _VipsRegionClass;
unsafe extern "C" {
    pub fn vips_region_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_region_new(image: *mut VipsImage) -> *mut VipsRegion;
}
unsafe extern "C" {
    pub fn vips_region_buffer(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_image(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_region(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_equalsregion(
        reg1: *mut VipsRegion,
        reg2: *mut VipsRegion,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_position(
        reg: *mut VipsRegion,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_paint(
        reg: *mut VipsRegion,
        r: *const VipsRect,
        value: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_region_paint_pel(reg: *mut VipsRegion, r: *const VipsRect, ink: *const VipsPel);
}
unsafe extern "C" {
    pub fn vips_region_black(reg: *mut VipsRegion);
}
unsafe extern "C" {
    pub fn vips_region_copy(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_region_shrink_method(
        from: *mut VipsRegion,
        to: *mut VipsRegion,
        target: *const VipsRect,
        method: VipsRegionShrink,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_shrink(
        from: *mut VipsRegion,
        to: *mut VipsRegion,
        target: *const VipsRect,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_prepare(reg: *mut VipsRegion, r: *const VipsRect) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_prepare_to(
        reg: *mut VipsRegion,
        dest: *mut VipsRegion,
        r: *const VipsRect,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_fetch(
        region: *mut VipsRegion,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        len: *mut usize,
    ) -> *mut VipsPel;
}
unsafe extern "C" {
    pub fn vips_region_width(region: *mut VipsRegion) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_height(region: *mut VipsRegion) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_region_invalidate(reg: *mut VipsRegion);
}
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_ERROR: VipsDemandStyle = -1;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_SMALLTILE: VipsDemandStyle = 0;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_FATSTRIP: VipsDemandStyle = 1;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_THINSTRIP: VipsDemandStyle = 2;
pub const VipsDemandStyle_VIPS_DEMAND_STYLE_ANY: VipsDemandStyle = 3;
pub type VipsDemandStyle = ::std::os::raw::c_int;
pub const VipsImageType_VIPS_IMAGE_ERROR: VipsImageType = -1;
pub const VipsImageType_VIPS_IMAGE_NONE: VipsImageType = 0;
pub const VipsImageType_VIPS_IMAGE_SETBUF: VipsImageType = 1;
pub const VipsImageType_VIPS_IMAGE_SETBUF_FOREIGN: VipsImageType = 2;
pub const VipsImageType_VIPS_IMAGE_OPENIN: VipsImageType = 3;
pub const VipsImageType_VIPS_IMAGE_MMAPIN: VipsImageType = 4;
pub const VipsImageType_VIPS_IMAGE_MMAPINRW: VipsImageType = 5;
pub const VipsImageType_VIPS_IMAGE_OPENOUT: VipsImageType = 6;
pub const VipsImageType_VIPS_IMAGE_PARTIAL: VipsImageType = 7;
pub type VipsImageType = ::std::os::raw::c_int;
pub const VipsInterpretation_VIPS_INTERPRETATION_ERROR: VipsInterpretation = -1;
pub const VipsInterpretation_VIPS_INTERPRETATION_MULTIBAND: VipsInterpretation = 0;
pub const VipsInterpretation_VIPS_INTERPRETATION_B_W: VipsInterpretation = 1;
pub const VipsInterpretation_VIPS_INTERPRETATION_HISTOGRAM: VipsInterpretation = 10;
pub const VipsInterpretation_VIPS_INTERPRETATION_XYZ: VipsInterpretation = 12;
pub const VipsInterpretation_VIPS_INTERPRETATION_LAB: VipsInterpretation = 13;
pub const VipsInterpretation_VIPS_INTERPRETATION_CMYK: VipsInterpretation = 15;
pub const VipsInterpretation_VIPS_INTERPRETATION_LABQ: VipsInterpretation = 16;
pub const VipsInterpretation_VIPS_INTERPRETATION_RGB: VipsInterpretation = 17;
pub const VipsInterpretation_VIPS_INTERPRETATION_CMC: VipsInterpretation = 18;
pub const VipsInterpretation_VIPS_INTERPRETATION_LCH: VipsInterpretation = 19;
pub const VipsInterpretation_VIPS_INTERPRETATION_LABS: VipsInterpretation = 21;
pub const VipsInterpretation_VIPS_INTERPRETATION_sRGB: VipsInterpretation = 22;
pub const VipsInterpretation_VIPS_INTERPRETATION_YXY: VipsInterpretation = 23;
pub const VipsInterpretation_VIPS_INTERPRETATION_FOURIER: VipsInterpretation = 24;
pub const VipsInterpretation_VIPS_INTERPRETATION_RGB16: VipsInterpretation = 25;
pub const VipsInterpretation_VIPS_INTERPRETATION_GREY16: VipsInterpretation = 26;
pub const VipsInterpretation_VIPS_INTERPRETATION_MATRIX: VipsInterpretation = 27;
pub const VipsInterpretation_VIPS_INTERPRETATION_scRGB: VipsInterpretation = 28;
pub const VipsInterpretation_VIPS_INTERPRETATION_HSV: VipsInterpretation = 29;
pub const VipsInterpretation_VIPS_INTERPRETATION_LAST: VipsInterpretation = 30;
pub type VipsInterpretation = ::std::os::raw::c_int;
pub const VipsBandFormat_VIPS_FORMAT_NOTSET: VipsBandFormat = -1;
pub const VipsBandFormat_VIPS_FORMAT_UCHAR: VipsBandFormat = 0;
pub const VipsBandFormat_VIPS_FORMAT_CHAR: VipsBandFormat = 1;
pub const VipsBandFormat_VIPS_FORMAT_USHORT: VipsBandFormat = 2;
pub const VipsBandFormat_VIPS_FORMAT_SHORT: VipsBandFormat = 3;
pub const VipsBandFormat_VIPS_FORMAT_UINT: VipsBandFormat = 4;
pub const VipsBandFormat_VIPS_FORMAT_INT: VipsBandFormat = 5;
pub const VipsBandFormat_VIPS_FORMAT_FLOAT: VipsBandFormat = 6;
pub const VipsBandFormat_VIPS_FORMAT_COMPLEX: VipsBandFormat = 7;
pub const VipsBandFormat_VIPS_FORMAT_DOUBLE: VipsBandFormat = 8;
pub const VipsBandFormat_VIPS_FORMAT_DPCOMPLEX: VipsBandFormat = 9;
pub const VipsBandFormat_VIPS_FORMAT_LAST: VipsBandFormat = 10;
pub type VipsBandFormat = ::std::os::raw::c_int;
pub const VipsCoding_VIPS_CODING_ERROR: VipsCoding = -1;
pub const VipsCoding_VIPS_CODING_NONE: VipsCoding = 0;
pub const VipsCoding_VIPS_CODING_LABQ: VipsCoding = 2;
pub const VipsCoding_VIPS_CODING_RAD: VipsCoding = 6;
pub const VipsCoding_VIPS_CODING_LAST: VipsCoding = 7;
pub type VipsCoding = ::std::os::raw::c_int;
pub const VipsAccess_VIPS_ACCESS_RANDOM: VipsAccess = 0;
pub const VipsAccess_VIPS_ACCESS_SEQUENTIAL: VipsAccess = 1;
pub const VipsAccess_VIPS_ACCESS_SEQUENTIAL_UNBUFFERED: VipsAccess = 2;
pub const VipsAccess_VIPS_ACCESS_LAST: VipsAccess = 3;
pub type VipsAccess = ::std::os::raw::c_uint;
pub type VipsStartFn = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VipsGenerateFn = ::std::option::Option<
    unsafe extern "C" fn(
        out: *mut VipsRegion,
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
        stop: *mut gboolean,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsStopFn = ::std::option::Option<
    unsafe extern "C" fn(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsProgress {
    pub im: *mut VipsImage,
    pub run: ::std::os::raw::c_int,
    pub eta: ::std::os::raw::c_int,
    pub tpels: gint64,
    pub npels: gint64,
    pub percent: ::std::os::raw::c_int,
    pub start: *mut GTimer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsProgress"][::std::mem::size_of::<_VipsProgress>() - 48usize];
    ["Alignment of _VipsProgress"][::std::mem::align_of::<_VipsProgress>() - 8usize];
    ["Offset of field: _VipsProgress::im"][::std::mem::offset_of!(_VipsProgress, im) - 0usize];
    ["Offset of field: _VipsProgress::run"][::std::mem::offset_of!(_VipsProgress, run) - 8usize];
    ["Offset of field: _VipsProgress::eta"][::std::mem::offset_of!(_VipsProgress, eta) - 12usize];
    ["Offset of field: _VipsProgress::tpels"]
        [::std::mem::offset_of!(_VipsProgress, tpels) - 16usize];
    ["Offset of field: _VipsProgress::npels"]
        [::std::mem::offset_of!(_VipsProgress, npels) - 24usize];
    ["Offset of field: _VipsProgress::percent"]
        [::std::mem::offset_of!(_VipsProgress, percent) - 32usize];
    ["Offset of field: _VipsProgress::start"]
        [::std::mem::offset_of!(_VipsProgress, start) - 40usize];
};
pub type VipsProgress = _VipsProgress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsImage {
    pub parent_instance: VipsObject,
    pub Xsize: ::std::os::raw::c_int,
    pub Ysize: ::std::os::raw::c_int,
    pub Bands: ::std::os::raw::c_int,
    pub BandFmt: VipsBandFormat,
    pub Coding: VipsCoding,
    pub Type: VipsInterpretation,
    pub Xres: f64,
    pub Yres: f64,
    pub Xoffset: ::std::os::raw::c_int,
    pub Yoffset: ::std::os::raw::c_int,
    pub Length: ::std::os::raw::c_int,
    pub Compression: ::std::os::raw::c_short,
    pub Level: ::std::os::raw::c_short,
    pub Bbits: ::std::os::raw::c_int,
    pub time: *mut VipsProgress,
    pub Hist: *mut ::std::os::raw::c_char,
    pub filename: *mut ::std::os::raw::c_char,
    pub data: *mut VipsPel,
    pub kill: ::std::os::raw::c_int,
    pub Xres_float: f32,
    pub Yres_float: f32,
    pub mode: *mut ::std::os::raw::c_char,
    pub dtype: VipsImageType,
    pub fd: ::std::os::raw::c_int,
    pub baseaddr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub magic: guint32,
    pub start_fn: VipsStartFn,
    pub generate_fn: VipsGenerateFn,
    pub stop_fn: VipsStopFn,
    pub client1: *mut ::std::os::raw::c_void,
    pub client2: *mut ::std::os::raw::c_void,
    pub sslock: *mut GMutex,
    pub regions: *mut GSList,
    pub dhint: VipsDemandStyle,
    pub meta: *mut GHashTable,
    pub meta_traverse: *mut GSList,
    pub sizeof_header: gint64,
    pub windows: *mut GSList,
    pub upstream: *mut GSList,
    pub downstream: *mut GSList,
    pub serial: ::std::os::raw::c_int,
    pub history_list: *mut GSList,
    pub progress_signal: *mut VipsImage,
    pub file_length: gint64,
    pub hint_set: gboolean,
    pub delete_on_close: gboolean,
    pub delete_on_close_filename: *mut ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsImage"][::std::mem::size_of::<_VipsImage>() - 392usize];
    ["Alignment of _VipsImage"][::std::mem::align_of::<_VipsImage>() - 8usize];
    ["Offset of field: _VipsImage::parent_instance"]
        [::std::mem::offset_of!(_VipsImage, parent_instance) - 0usize];
    ["Offset of field: _VipsImage::Xsize"][::std::mem::offset_of!(_VipsImage, Xsize) - 80usize];
    ["Offset of field: _VipsImage::Ysize"][::std::mem::offset_of!(_VipsImage, Ysize) - 84usize];
    ["Offset of field: _VipsImage::Bands"][::std::mem::offset_of!(_VipsImage, Bands) - 88usize];
    ["Offset of field: _VipsImage::BandFmt"][::std::mem::offset_of!(_VipsImage, BandFmt) - 92usize];
    ["Offset of field: _VipsImage::Coding"][::std::mem::offset_of!(_VipsImage, Coding) - 96usize];
    ["Offset of field: _VipsImage::Type"][::std::mem::offset_of!(_VipsImage, Type) - 100usize];
    ["Offset of field: _VipsImage::Xres"][::std::mem::offset_of!(_VipsImage, Xres) - 104usize];
    ["Offset of field: _VipsImage::Yres"][::std::mem::offset_of!(_VipsImage, Yres) - 112usize];
    ["Offset of field: _VipsImage::Xoffset"]
        [::std::mem::offset_of!(_VipsImage, Xoffset) - 120usize];
    ["Offset of field: _VipsImage::Yoffset"]
        [::std::mem::offset_of!(_VipsImage, Yoffset) - 124usize];
    ["Offset of field: _VipsImage::Length"][::std::mem::offset_of!(_VipsImage, Length) - 128usize];
    ["Offset of field: _VipsImage::Compression"]
        [::std::mem::offset_of!(_VipsImage, Compression) - 132usize];
    ["Offset of field: _VipsImage::Level"][::std::mem::offset_of!(_VipsImage, Level) - 134usize];
    ["Offset of field: _VipsImage::Bbits"][::std::mem::offset_of!(_VipsImage, Bbits) - 136usize];
    ["Offset of field: _VipsImage::time"][::std::mem::offset_of!(_VipsImage, time) - 144usize];
    ["Offset of field: _VipsImage::Hist"][::std::mem::offset_of!(_VipsImage, Hist) - 152usize];
    ["Offset of field: _VipsImage::filename"]
        [::std::mem::offset_of!(_VipsImage, filename) - 160usize];
    ["Offset of field: _VipsImage::data"][::std::mem::offset_of!(_VipsImage, data) - 168usize];
    ["Offset of field: _VipsImage::kill"][::std::mem::offset_of!(_VipsImage, kill) - 176usize];
    ["Offset of field: _VipsImage::Xres_float"]
        [::std::mem::offset_of!(_VipsImage, Xres_float) - 180usize];
    ["Offset of field: _VipsImage::Yres_float"]
        [::std::mem::offset_of!(_VipsImage, Yres_float) - 184usize];
    ["Offset of field: _VipsImage::mode"][::std::mem::offset_of!(_VipsImage, mode) - 192usize];
    ["Offset of field: _VipsImage::dtype"][::std::mem::offset_of!(_VipsImage, dtype) - 200usize];
    ["Offset of field: _VipsImage::fd"][::std::mem::offset_of!(_VipsImage, fd) - 204usize];
    ["Offset of field: _VipsImage::baseaddr"]
        [::std::mem::offset_of!(_VipsImage, baseaddr) - 208usize];
    ["Offset of field: _VipsImage::length"][::std::mem::offset_of!(_VipsImage, length) - 216usize];
    ["Offset of field: _VipsImage::magic"][::std::mem::offset_of!(_VipsImage, magic) - 224usize];
    ["Offset of field: _VipsImage::start_fn"]
        [::std::mem::offset_of!(_VipsImage, start_fn) - 232usize];
    ["Offset of field: _VipsImage::generate_fn"]
        [::std::mem::offset_of!(_VipsImage, generate_fn) - 240usize];
    ["Offset of field: _VipsImage::stop_fn"]
        [::std::mem::offset_of!(_VipsImage, stop_fn) - 248usize];
    ["Offset of field: _VipsImage::client1"]
        [::std::mem::offset_of!(_VipsImage, client1) - 256usize];
    ["Offset of field: _VipsImage::client2"]
        [::std::mem::offset_of!(_VipsImage, client2) - 264usize];
    ["Offset of field: _VipsImage::sslock"][::std::mem::offset_of!(_VipsImage, sslock) - 272usize];
    ["Offset of field: _VipsImage::regions"]
        [::std::mem::offset_of!(_VipsImage, regions) - 280usize];
    ["Offset of field: _VipsImage::dhint"][::std::mem::offset_of!(_VipsImage, dhint) - 288usize];
    ["Offset of field: _VipsImage::meta"][::std::mem::offset_of!(_VipsImage, meta) - 296usize];
    ["Offset of field: _VipsImage::meta_traverse"]
        [::std::mem::offset_of!(_VipsImage, meta_traverse) - 304usize];
    ["Offset of field: _VipsImage::sizeof_header"]
        [::std::mem::offset_of!(_VipsImage, sizeof_header) - 312usize];
    ["Offset of field: _VipsImage::windows"]
        [::std::mem::offset_of!(_VipsImage, windows) - 320usize];
    ["Offset of field: _VipsImage::upstream"]
        [::std::mem::offset_of!(_VipsImage, upstream) - 328usize];
    ["Offset of field: _VipsImage::downstream"]
        [::std::mem::offset_of!(_VipsImage, downstream) - 336usize];
    ["Offset of field: _VipsImage::serial"][::std::mem::offset_of!(_VipsImage, serial) - 344usize];
    ["Offset of field: _VipsImage::history_list"]
        [::std::mem::offset_of!(_VipsImage, history_list) - 352usize];
    ["Offset of field: _VipsImage::progress_signal"]
        [::std::mem::offset_of!(_VipsImage, progress_signal) - 360usize];
    ["Offset of field: _VipsImage::file_length"]
        [::std::mem::offset_of!(_VipsImage, file_length) - 368usize];
    ["Offset of field: _VipsImage::hint_set"]
        [::std::mem::offset_of!(_VipsImage, hint_set) - 376usize];
    ["Offset of field: _VipsImage::delete_on_close"]
        [::std::mem::offset_of!(_VipsImage, delete_on_close) - 380usize];
    ["Offset of field: _VipsImage::delete_on_close_filename"]
        [::std::mem::offset_of!(_VipsImage, delete_on_close_filename) - 384usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsImageClass {
    pub parent_class: VipsObjectClass,
    pub preeval: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            progress: *mut VipsProgress,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub eval: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            progress: *mut VipsProgress,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub posteval: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            progress: *mut VipsProgress,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub written: ::std::option::Option<
        unsafe extern "C" fn(
            image: *mut VipsImage,
            result: *mut ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    pub invalidate: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, data: *mut ::std::os::raw::c_void),
    >,
    pub minimise: ::std::option::Option<
        unsafe extern "C" fn(image: *mut VipsImage, data: *mut ::std::os::raw::c_void),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsImageClass"][::std::mem::size_of::<_VipsImageClass>() - 376usize];
    ["Alignment of _VipsImageClass"][::std::mem::align_of::<_VipsImageClass>() - 8usize];
    ["Offset of field: _VipsImageClass::parent_class"]
        [::std::mem::offset_of!(_VipsImageClass, parent_class) - 0usize];
    ["Offset of field: _VipsImageClass::preeval"]
        [::std::mem::offset_of!(_VipsImageClass, preeval) - 328usize];
    ["Offset of field: _VipsImageClass::eval"]
        [::std::mem::offset_of!(_VipsImageClass, eval) - 336usize];
    ["Offset of field: _VipsImageClass::posteval"]
        [::std::mem::offset_of!(_VipsImageClass, posteval) - 344usize];
    ["Offset of field: _VipsImageClass::written"]
        [::std::mem::offset_of!(_VipsImageClass, written) - 352usize];
    ["Offset of field: _VipsImageClass::invalidate"]
        [::std::mem::offset_of!(_VipsImageClass, invalidate) - 360usize];
    ["Offset of field: _VipsImageClass::minimise"]
        [::std::mem::offset_of!(_VipsImageClass, minimise) - 368usize];
};
pub type VipsImageClass = _VipsImageClass;
unsafe extern "C" {
    pub fn vips_image_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_progress_set(progress: gboolean);
}
unsafe extern "C" {
    pub fn vips_image_invalidate_all(image: *mut VipsImage);
}
unsafe extern "C" {
    pub fn vips_image_minimise_all(image: *mut VipsImage);
}
unsafe extern "C" {
    pub fn vips_image_is_sequential(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_set_progress(image: *mut VipsImage, progress: gboolean);
}
unsafe extern "C" {
    pub fn vips_image_iskilled(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_set_kill(image: *mut VipsImage, kill: gboolean);
}
unsafe extern "C" {
    pub fn vips_filename_get_filename(
        vips_filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_filename_get_options(
        vips_filename: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_image_new() -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_memory() -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_memory() -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_file(name: *const ::std::os::raw::c_char, ...) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_file_RW(filename: *const ::std::os::raw::c_char) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_file_raw(
        filename: *const ::std::os::raw::c_char,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        offset: guint64,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_memory(
        data: *const ::std::os::raw::c_void,
        size: usize,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_memory_copy(
        data: *const ::std::os::raw::c_void,
        size: usize,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_buffer(
        buf: *const ::std::os::raw::c_void,
        len: usize,
        option_string: *const ::std::os::raw::c_char,
        ...
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_source(
        source: *mut VipsSource,
        option_string: *const ::std::os::raw::c_char,
        ...
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_matrix(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_matrixv(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_matrix_from_array(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        array: *const f64,
        size: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_matrix_from_array(
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        array: *const f64,
        size: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_image(
        image: *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_new_from_image1(image: *mut VipsImage, c: f64) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_set_delete_on_close(image: *mut VipsImage, delete_on_close: gboolean);
}
unsafe extern "C" {
    pub fn vips_get_disc_threshold() -> guint64;
}
unsafe extern "C" {
    pub fn vips_image_new_temp_file(format: *const ::std::os::raw::c_char) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_write(image: *mut VipsImage, out: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_write_to_file(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_write_to_buffer(
        in_: *mut VipsImage,
        suffix: *const ::std::os::raw::c_char,
        buf: *mut *mut ::std::os::raw::c_void,
        size: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_write_to_target(
        in_: *mut VipsImage,
        suffix: *const ::std::os::raw::c_char,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_write_to_memory(
        in_: *mut VipsImage,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_image_decode_predict(
        in_: *mut VipsImage,
        bands: *mut ::std::os::raw::c_int,
        format: *mut VipsBandFormat,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_decode(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_encode(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        coding: VipsCoding,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_isMSBfirst(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_isfile(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_ispartial(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_hasalpha(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_copy_memory(image: *mut VipsImage) -> *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_wio_input(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_pio_input(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_pio_output(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_inplace(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_write_prepare(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_write_line(
        image: *mut VipsImage,
        ypos: ::std::os::raw::c_int,
        linebuffer: *mut VipsPel,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_band_format_isint(format: VipsBandFormat) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_band_format_isuint(format: VipsBandFormat) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_band_format_is8bit(format: VipsBandFormat) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_band_format_isfloat(format: VipsBandFormat) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_band_format_iscomplex(format: VipsBandFormat) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_system(cmd_format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_array_image_new(
        array: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
    ) -> *mut VipsArrayImage;
}
unsafe extern "C" {
    pub fn vips_array_image_newv(n: ::std::os::raw::c_int, ...) -> *mut VipsArrayImage;
}
unsafe extern "C" {
    pub fn vips_array_image_new_from_string(
        string: *const ::std::os::raw::c_char,
        flags: VipsAccess,
    ) -> *mut VipsArrayImage;
}
unsafe extern "C" {
    pub fn vips_array_image_empty() -> *mut VipsArrayImage;
}
unsafe extern "C" {
    pub fn vips_array_image_append(
        array: *mut VipsArrayImage,
        image: *mut VipsImage,
    ) -> *mut VipsArrayImage;
}
unsafe extern "C" {
    pub fn vips_array_image_get(
        array: *mut VipsArrayImage,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_value_get_array_image(
        value: *const GValue,
        n: *mut ::std::os::raw::c_int,
    ) -> *mut *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_value_set_array_image(value: *mut GValue, n: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_reorder_prepare_many(
        image: *mut VipsImage,
        regions: *mut *mut VipsRegion,
        r: *mut VipsRect,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_reorder_margin_hint(image: *mut VipsImage, margin: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_image_free_buffer(image: *mut VipsImage, buffer: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vips_malloc(object: *mut VipsObject, size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_strdup(
        object: *mut VipsObject,
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_tracked_free(s: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vips_tracked_aligned_free(s: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    pub fn vips_tracked_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_tracked_aligned_alloc(size: usize, align: usize) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_tracked_get_mem() -> usize;
}
unsafe extern "C" {
    pub fn vips_tracked_get_mem_highwater() -> usize;
}
unsafe extern "C" {
    pub fn vips_tracked_get_allocs() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tracked_open(
        pathname: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_int,
        mode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tracked_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tracked_get_files() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_error_buffer() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_error_buffer_copy() -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_error_clear();
}
unsafe extern "C" {
    pub fn vips_error_freeze();
}
unsafe extern "C" {
    pub fn vips_error_thaw();
}
unsafe extern "C" {
    pub fn vips_error(
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn vips_verror(
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn vips_error_system(
        err: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn vips_verror_system(
        err: ::std::os::raw::c_int,
        domain: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    pub fn vips_error_g(error: *mut *mut GError);
}
unsafe extern "C" {
    pub fn vips_g_error(error: *mut *mut GError);
}
unsafe extern "C" {
    pub fn vips_error_exit(fmt: *const ::std::os::raw::c_char, ...) -> !;
}
unsafe extern "C" {
    pub fn vips_check_uncoded(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_coding(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        coding: VipsCoding,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_coding_known(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_coding_noneorlabq(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_coding_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_mono(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bands(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bands_1or3(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bands_atleast(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bands: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bands_1orn(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bands_1orn_unary(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bands_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_bandno(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        bandno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_int(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_uint(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_uintorf(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_noncomplex(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_complex(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_twocomponents(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_format(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        fmt: VipsBandFormat,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_u8or16(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_8or16(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_u8or16orf(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_format_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_size_same(
        domain: *const ::std::os::raw::c_char,
        im1: *mut VipsImage,
        im2: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_oddsquare(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_vector_length(
        domain: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_vector(
        domain: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_int,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_hist(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_matrix(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_separable(
        domain: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_check_precision_intfloat(
        domain: *const ::std::os::raw::c_char,
        precision: VipsPrecision,
    ) -> ::std::os::raw::c_int;
}
pub const VipsFormatFlags_VIPS_FORMAT_NONE: VipsFormatFlags = 0;
pub const VipsFormatFlags_VIPS_FORMAT_PARTIAL: VipsFormatFlags = 1;
pub const VipsFormatFlags_VIPS_FORMAT_BIGENDIAN: VipsFormatFlags = 2;
pub type VipsFormatFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsFormat {
    pub parent_object: VipsObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsFormat"][::std::mem::size_of::<_VipsFormat>() - 80usize];
    ["Alignment of _VipsFormat"][::std::mem::align_of::<_VipsFormat>() - 8usize];
    ["Offset of field: _VipsFormat::parent_object"]
        [::std::mem::offset_of!(_VipsFormat, parent_object) - 0usize];
};
pub type VipsFormat = _VipsFormat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsFormatClass {
    pub parent_class: VipsObjectClass,
    pub is_a: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> gboolean,
    >,
    pub header: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut VipsImage,
        ) -> ::std::os::raw::c_int,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *const ::std::os::raw::c_char,
            arg2: *mut VipsImage,
        ) -> ::std::os::raw::c_int,
    >,
    pub save: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut VipsImage,
            arg2: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char) -> VipsFormatFlags,
    >,
    pub priority: ::std::os::raw::c_int,
    pub suffs: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsFormatClass"][::std::mem::size_of::<_VipsFormatClass>() - 384usize];
    ["Alignment of _VipsFormatClass"][::std::mem::align_of::<_VipsFormatClass>() - 8usize];
    ["Offset of field: _VipsFormatClass::parent_class"]
        [::std::mem::offset_of!(_VipsFormatClass, parent_class) - 0usize];
    ["Offset of field: _VipsFormatClass::is_a"]
        [::std::mem::offset_of!(_VipsFormatClass, is_a) - 328usize];
    ["Offset of field: _VipsFormatClass::header"]
        [::std::mem::offset_of!(_VipsFormatClass, header) - 336usize];
    ["Offset of field: _VipsFormatClass::load"]
        [::std::mem::offset_of!(_VipsFormatClass, load) - 344usize];
    ["Offset of field: _VipsFormatClass::save"]
        [::std::mem::offset_of!(_VipsFormatClass, save) - 352usize];
    ["Offset of field: _VipsFormatClass::get_flags"]
        [::std::mem::offset_of!(_VipsFormatClass, get_flags) - 360usize];
    ["Offset of field: _VipsFormatClass::priority"]
        [::std::mem::offset_of!(_VipsFormatClass, priority) - 368usize];
    ["Offset of field: _VipsFormatClass::suffs"]
        [::std::mem::offset_of!(_VipsFormatClass, suffs) - 376usize];
};
pub type VipsFormatClass = _VipsFormatClass;
unsafe extern "C" {
    pub fn vips_format_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_format_map(
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_format_for_file(filename: *const ::std::os::raw::c_char) -> *mut VipsFormatClass;
}
unsafe extern "C" {
    pub fn vips_format_for_name(filename: *const ::std::os::raw::c_char) -> *mut VipsFormatClass;
}
unsafe extern "C" {
    pub fn vips_format_get_flags(
        format: *mut VipsFormatClass,
        filename: *const ::std::os::raw::c_char,
    ) -> VipsFormatFlags;
}
unsafe extern "C" {
    pub fn vips_format_read(
        filename: *const ::std::os::raw::c_char,
        out: *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_format_write(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
pub type VipsRegionWrite = ::std::option::Option<
    unsafe extern "C" fn(
        region: *mut VipsRegion,
        area: *mut VipsRect,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn vips_sink_disc(
        im: *mut VipsImage,
        write_fn: VipsRegionWrite,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sink(
        im: *mut VipsImage,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sink_tile(
        im: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type VipsSinkNotify = ::std::option::Option<
    unsafe extern "C" fn(im: *mut VipsImage, rect: *mut VipsRect, a: *mut ::std::os::raw::c_void),
>;
unsafe extern "C" {
    pub fn vips_sink_screen(
        in_: *mut VipsImage,
        out: *mut VipsImage,
        mask: *mut VipsImage,
        tile_width: ::std::os::raw::c_int,
        tile_height: ::std::os::raw::c_int,
        max_tiles: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
        notify_fn: VipsSinkNotify,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sink_memory(im: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_start_one(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_stop_one(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_start_many(
        out: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_stop_many(
        seq: *mut ::std::os::raw::c_void,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_allocate_input_array(out: *mut VipsImage, ...) -> *mut *mut VipsImage;
}
unsafe extern "C" {
    pub fn vips_image_generate(
        image: *mut VipsImage,
        start_fn: VipsStartFn,
        generate_fn: VipsGenerateFn,
        stop_fn: VipsStopFn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_pipeline_array(
        image: *mut VipsImage,
        hint: VipsDemandStyle,
        in_: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_pipelinev(
        image: *mut VipsImage,
        hint: VipsDemandStyle,
        ...
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsInterpolate {
    pub parent_object: VipsObject,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsInterpolate"][::std::mem::size_of::<_VipsInterpolate>() - 80usize];
    ["Alignment of _VipsInterpolate"][::std::mem::align_of::<_VipsInterpolate>() - 8usize];
    ["Offset of field: _VipsInterpolate::parent_object"]
        [::std::mem::offset_of!(_VipsInterpolate, parent_object) - 0usize];
};
pub type VipsInterpolate = _VipsInterpolate;
pub type VipsInterpolateMethod = ::std::option::Option<
    unsafe extern "C" fn(
        interpolate: *mut VipsInterpolate,
        out: *mut ::std::os::raw::c_void,
        in_: *mut VipsRegion,
        x: f64,
        y: f64,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsInterpolateClass {
    pub parent_class: VipsObjectClass,
    pub interpolate: VipsInterpolateMethod,
    pub get_window_size: ::std::option::Option<
        unsafe extern "C" fn(interpolate: *mut VipsInterpolate) -> ::std::os::raw::c_int,
    >,
    pub window_size: ::std::os::raw::c_int,
    pub get_window_offset: ::std::option::Option<
        unsafe extern "C" fn(interpolate: *mut VipsInterpolate) -> ::std::os::raw::c_int,
    >,
    pub window_offset: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsInterpolateClass"][::std::mem::size_of::<_VipsInterpolateClass>() - 368usize];
    ["Alignment of _VipsInterpolateClass"]
        [::std::mem::align_of::<_VipsInterpolateClass>() - 8usize];
    ["Offset of field: _VipsInterpolateClass::parent_class"]
        [::std::mem::offset_of!(_VipsInterpolateClass, parent_class) - 0usize];
    ["Offset of field: _VipsInterpolateClass::interpolate"]
        [::std::mem::offset_of!(_VipsInterpolateClass, interpolate) - 328usize];
    ["Offset of field: _VipsInterpolateClass::get_window_size"]
        [::std::mem::offset_of!(_VipsInterpolateClass, get_window_size) - 336usize];
    ["Offset of field: _VipsInterpolateClass::window_size"]
        [::std::mem::offset_of!(_VipsInterpolateClass, window_size) - 344usize];
    ["Offset of field: _VipsInterpolateClass::get_window_offset"]
        [::std::mem::offset_of!(_VipsInterpolateClass, get_window_offset) - 352usize];
    ["Offset of field: _VipsInterpolateClass::window_offset"]
        [::std::mem::offset_of!(_VipsInterpolateClass, window_offset) - 360usize];
};
pub type VipsInterpolateClass = _VipsInterpolateClass;
unsafe extern "C" {
    pub fn vips_interpolate_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_interpolate(
        interpolate: *mut VipsInterpolate,
        out: *mut ::std::os::raw::c_void,
        in_: *mut VipsRegion,
        x: f64,
        y: f64,
    );
}
unsafe extern "C" {
    pub fn vips_interpolate_get_method(interpolate: *mut VipsInterpolate) -> VipsInterpolateMethod;
}
unsafe extern "C" {
    pub fn vips_interpolate_get_window_size(
        interpolate: *mut VipsInterpolate,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_interpolate_get_window_offset(
        interpolate: *mut VipsInterpolate,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_interpolate_nearest_static() -> *mut VipsInterpolate;
}
unsafe extern "C" {
    pub fn vips_interpolate_bilinear_static() -> *mut VipsInterpolate;
}
unsafe extern "C" {
    pub fn vips_interpolate_new(nickname: *const ::std::os::raw::c_char) -> *mut VipsInterpolate;
}
unsafe extern "C" {
    pub fn vips_g_mutex_new() -> *mut GMutex;
}
unsafe extern "C" {
    pub fn vips_g_mutex_free(arg1: *mut GMutex);
}
unsafe extern "C" {
    pub fn vips_g_cond_new() -> *mut GCond;
}
unsafe extern "C" {
    pub fn vips_g_cond_free(arg1: *mut GCond);
}
unsafe extern "C" {
    pub fn vips_g_thread_new(
        arg1: *const ::std::os::raw::c_char,
        arg2: GThreadFunc,
        arg3: gpointer,
    ) -> *mut GThread;
}
unsafe extern "C" {
    pub fn vips_thread_isvips() -> gboolean;
}
unsafe extern "C" {
    pub fn vips_thread_execute(
        domain: *const ::std::os::raw::c_char,
        func: GFunc,
        data: gpointer,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThreadset {
    _unused: [u8; 0],
}
pub type VipsThreadset = _VipsThreadset;
unsafe extern "C" {
    pub fn vips_threadset_new(max_threads: ::std::os::raw::c_int) -> *mut VipsThreadset;
}
unsafe extern "C" {
    pub fn vips_threadset_run(
        set: *mut VipsThreadset,
        domain: *const ::std::os::raw::c_char,
        func: GFunc,
        data: gpointer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_threadset_free(set: *mut VipsThreadset);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VipsSemaphore {
    pub name: *mut ::std::os::raw::c_char,
    pub v: ::std::os::raw::c_int,
    pub mutex: *mut GMutex,
    pub cond: *mut GCond,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of VipsSemaphore"][::std::mem::size_of::<VipsSemaphore>() - 32usize];
    ["Alignment of VipsSemaphore"][::std::mem::align_of::<VipsSemaphore>() - 8usize];
    ["Offset of field: VipsSemaphore::name"][::std::mem::offset_of!(VipsSemaphore, name) - 0usize];
    ["Offset of field: VipsSemaphore::v"][::std::mem::offset_of!(VipsSemaphore, v) - 8usize];
    ["Offset of field: VipsSemaphore::mutex"]
        [::std::mem::offset_of!(VipsSemaphore, mutex) - 16usize];
    ["Offset of field: VipsSemaphore::cond"][::std::mem::offset_of!(VipsSemaphore, cond) - 24usize];
};
unsafe extern "C" {
    pub fn vips_semaphore_up(s: *mut VipsSemaphore) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_semaphore_upn(
        s: *mut VipsSemaphore,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_semaphore_down(s: *mut VipsSemaphore) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_semaphore_downn(
        s: *mut VipsSemaphore,
        n: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_semaphore_down_timeout(
        s: *mut VipsSemaphore,
        timeout: gint64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_semaphore_destroy(s: *mut VipsSemaphore);
}
unsafe extern "C" {
    pub fn vips_semaphore_init(
        s: *mut VipsSemaphore,
        v: ::std::os::raw::c_int,
        name: *mut ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThreadState {
    pub parent_object: VipsObject,
    pub im: *mut VipsImage,
    pub reg: *mut VipsRegion,
    pub pos: VipsRect,
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub stop: gboolean,
    pub a: *mut ::std::os::raw::c_void,
    pub stall: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsThreadState"][::std::mem::size_of::<_VipsThreadState>() - 144usize];
    ["Alignment of _VipsThreadState"][::std::mem::align_of::<_VipsThreadState>() - 8usize];
    ["Offset of field: _VipsThreadState::parent_object"]
        [::std::mem::offset_of!(_VipsThreadState, parent_object) - 0usize];
    ["Offset of field: _VipsThreadState::im"]
        [::std::mem::offset_of!(_VipsThreadState, im) - 80usize];
    ["Offset of field: _VipsThreadState::reg"]
        [::std::mem::offset_of!(_VipsThreadState, reg) - 88usize];
    ["Offset of field: _VipsThreadState::pos"]
        [::std::mem::offset_of!(_VipsThreadState, pos) - 96usize];
    ["Offset of field: _VipsThreadState::x"]
        [::std::mem::offset_of!(_VipsThreadState, x) - 112usize];
    ["Offset of field: _VipsThreadState::y"]
        [::std::mem::offset_of!(_VipsThreadState, y) - 116usize];
    ["Offset of field: _VipsThreadState::stop"]
        [::std::mem::offset_of!(_VipsThreadState, stop) - 120usize];
    ["Offset of field: _VipsThreadState::a"]
        [::std::mem::offset_of!(_VipsThreadState, a) - 128usize];
    ["Offset of field: _VipsThreadState::stall"]
        [::std::mem::offset_of!(_VipsThreadState, stall) - 136usize];
};
pub type VipsThreadState = _VipsThreadState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsThreadStateClass {
    pub parent_class: VipsObjectClass,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsThreadStateClass"][::std::mem::size_of::<_VipsThreadStateClass>() - 328usize];
    ["Alignment of _VipsThreadStateClass"]
        [::std::mem::align_of::<_VipsThreadStateClass>() - 8usize];
    ["Offset of field: _VipsThreadStateClass::parent_class"]
        [::std::mem::offset_of!(_VipsThreadStateClass, parent_class) - 0usize];
};
pub type VipsThreadStateClass = _VipsThreadStateClass;
unsafe extern "C" {
    pub fn vips_thread_state_set(
        object: *mut VipsObject,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_thread_state_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_thread_state_new(
        im: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut VipsThreadState;
}
pub type VipsThreadStartFn = ::std::option::Option<
    unsafe extern "C" fn(
        im: *mut VipsImage,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut VipsThreadState,
>;
pub type VipsThreadpoolAllocateFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VipsThreadState,
        a: *mut ::std::os::raw::c_void,
        stop: *mut gboolean,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsThreadpoolWorkFn = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VipsThreadState,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type VipsThreadpoolProgressFn = ::std::option::Option<
    unsafe extern "C" fn(a: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    pub fn vips_threadpool_run(
        im: *mut VipsImage,
        start: VipsThreadStartFn,
        allocate: VipsThreadpoolAllocateFn,
        work: VipsThreadpoolWorkFn,
        progress: VipsThreadpoolProgressFn,
        a: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_get_tile_size(
        im: *mut VipsImage,
        tile_width: *mut ::std::os::raw::c_int,
        tile_height: *mut ::std::os::raw::c_int,
        n_lines: *mut ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_format_sizeof(format: VipsBandFormat) -> guint64;
}
unsafe extern "C" {
    pub fn vips_format_sizeof_unsafe(format: VipsBandFormat) -> guint64;
}
unsafe extern "C" {
    pub fn vips_interpretation_max_alpha(interpretation: VipsInterpretation) -> f64;
}
unsafe extern "C" {
    pub fn vips_image_get_width(image: *const VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_height(image: *const VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_bands(image: *const VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_format(image: *const VipsImage) -> VipsBandFormat;
}
unsafe extern "C" {
    pub fn vips_image_get_format_max(format: VipsBandFormat) -> f64;
}
unsafe extern "C" {
    pub fn vips_image_guess_format(image: *const VipsImage) -> VipsBandFormat;
}
unsafe extern "C" {
    pub fn vips_image_get_coding(image: *const VipsImage) -> VipsCoding;
}
unsafe extern "C" {
    pub fn vips_image_get_interpretation(image: *const VipsImage) -> VipsInterpretation;
}
unsafe extern "C" {
    pub fn vips_image_guess_interpretation(image: *const VipsImage) -> VipsInterpretation;
}
unsafe extern "C" {
    pub fn vips_image_get_xres(image: *const VipsImage) -> f64;
}
unsafe extern "C" {
    pub fn vips_image_get_yres(image: *const VipsImage) -> f64;
}
unsafe extern "C" {
    pub fn vips_image_get_xoffset(image: *const VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_yoffset(image: *const VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_filename(image: *const VipsImage) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_image_get_mode(image: *const VipsImage) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_image_get_scale(image: *const VipsImage) -> f64;
}
unsafe extern "C" {
    pub fn vips_image_get_offset(image: *const VipsImage) -> f64;
}
unsafe extern "C" {
    pub fn vips_image_get_page_height(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_n_pages(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_n_subifds(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_orientation(image: *mut VipsImage) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_orientation_swap(image: *mut VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_image_get_concurrency(
        image: *mut VipsImage,
        default_concurrency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_data(image: *mut VipsImage) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_image_init_fields(
        image: *mut VipsImage,
        xsize: ::std::os::raw::c_int,
        ysize: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        format: VipsBandFormat,
        coding: VipsCoding,
        interpretation: VipsInterpretation,
        xres: f64,
        yres: f64,
    );
}
unsafe extern "C" {
    pub fn vips_image_set(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        value: *mut GValue,
    );
}
unsafe extern "C" {
    pub fn vips_image_get(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        value_copy: *mut GValue,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_as_string(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_typeof(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
    ) -> GType;
}
unsafe extern "C" {
    pub fn vips_image_remove(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
pub type VipsImageMapFn = ::std::option::Option<
    unsafe extern "C" fn(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        value: *mut GValue,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
unsafe extern "C" {
    pub fn vips_image_map(
        image: *mut VipsImage,
        fn_: VipsImageMapFn,
        a: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn vips_image_get_fields(image: *mut VipsImage) -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn vips_image_set_area(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        free_fn: VipsCallbackFn,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn vips_image_get_area(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_set_blob(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        free_fn: VipsCallbackFn,
        data: *const ::std::os::raw::c_void,
        length: usize,
    );
}
unsafe extern "C" {
    pub fn vips_image_set_blob_copy(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        length: usize,
    );
}
unsafe extern "C" {
    pub fn vips_image_get_blob(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        data: *mut *const ::std::os::raw::c_void,
        length: *mut usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_int(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_set_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        i: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_image_get_double(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_set_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        d: f64,
    );
}
unsafe extern "C" {
    pub fn vips_image_get_string(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_set_string(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn vips_image_print_field(image: *const VipsImage, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn vips_image_get_image(
        image: *const VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_set_image(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        im: *mut VipsImage,
    );
}
unsafe extern "C" {
    pub fn vips_image_set_array_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        array: *const ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_image_get_array_int(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut ::std::os::raw::c_int,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_array_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        out: *mut *mut f64,
        n: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_set_array_double(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        array: *const f64,
        n: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    pub fn vips_image_history_printf(
        image: *mut VipsImage,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_history_args(
        image: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_image_get_history(image: *mut VipsImage) -> *const ::std::os::raw::c_char;
}
pub const VipsOperationFlags_VIPS_OPERATION_NONE: VipsOperationFlags = 0;
pub const VipsOperationFlags_VIPS_OPERATION_SEQUENTIAL: VipsOperationFlags = 1;
pub const VipsOperationFlags_VIPS_OPERATION_SEQUENTIAL_UNBUFFERED: VipsOperationFlags = 2;
pub const VipsOperationFlags_VIPS_OPERATION_NOCACHE: VipsOperationFlags = 4;
pub const VipsOperationFlags_VIPS_OPERATION_DEPRECATED: VipsOperationFlags = 8;
pub const VipsOperationFlags_VIPS_OPERATION_UNTRUSTED: VipsOperationFlags = 16;
pub const VipsOperationFlags_VIPS_OPERATION_BLOCKED: VipsOperationFlags = 32;
pub const VipsOperationFlags_VIPS_OPERATION_REVALIDATE: VipsOperationFlags = 64;
pub type VipsOperationFlags = ::std::os::raw::c_uint;
pub type VipsOperationBuildFn =
    ::std::option::Option<unsafe extern "C" fn(object: *mut VipsObject) -> gboolean>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsOperation {
    pub parent_instance: VipsObject,
    pub hash: guint,
    pub found_hash: gboolean,
    pub pixels: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsOperation"][::std::mem::size_of::<_VipsOperation>() - 96usize];
    ["Alignment of _VipsOperation"][::std::mem::align_of::<_VipsOperation>() - 8usize];
    ["Offset of field: _VipsOperation::parent_instance"]
        [::std::mem::offset_of!(_VipsOperation, parent_instance) - 0usize];
    ["Offset of field: _VipsOperation::hash"]
        [::std::mem::offset_of!(_VipsOperation, hash) - 80usize];
    ["Offset of field: _VipsOperation::found_hash"]
        [::std::mem::offset_of!(_VipsOperation, found_hash) - 84usize];
    ["Offset of field: _VipsOperation::pixels"]
        [::std::mem::offset_of!(_VipsOperation, pixels) - 88usize];
};
pub type VipsOperation = _VipsOperation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsOperationClass {
    pub parent_class: VipsObjectClass,
    pub usage: ::std::option::Option<
        unsafe extern "C" fn(cls: *mut _VipsOperationClass, buf: *mut VipsBuf),
    >,
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(operation: *mut VipsOperation) -> VipsOperationFlags,
    >,
    pub flags: VipsOperationFlags,
    pub invalidate: ::std::option::Option<unsafe extern "C" fn(operation: *mut VipsOperation)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsOperationClass"][::std::mem::size_of::<_VipsOperationClass>() - 360usize];
    ["Alignment of _VipsOperationClass"][::std::mem::align_of::<_VipsOperationClass>() - 8usize];
    ["Offset of field: _VipsOperationClass::parent_class"]
        [::std::mem::offset_of!(_VipsOperationClass, parent_class) - 0usize];
    ["Offset of field: _VipsOperationClass::usage"]
        [::std::mem::offset_of!(_VipsOperationClass, usage) - 328usize];
    ["Offset of field: _VipsOperationClass::get_flags"]
        [::std::mem::offset_of!(_VipsOperationClass, get_flags) - 336usize];
    ["Offset of field: _VipsOperationClass::flags"]
        [::std::mem::offset_of!(_VipsOperationClass, flags) - 344usize];
    ["Offset of field: _VipsOperationClass::invalidate"]
        [::std::mem::offset_of!(_VipsOperationClass, invalidate) - 352usize];
};
pub type VipsOperationClass = _VipsOperationClass;
unsafe extern "C" {
    pub fn vips_operation_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_get_flags(operation: *mut VipsOperation) -> VipsOperationFlags;
}
unsafe extern "C" {
    pub fn vips_operation_class_print_usage(operation_class: *mut VipsOperationClass);
}
unsafe extern "C" {
    pub fn vips_operation_invalidate(operation: *mut VipsOperation);
}
unsafe extern "C" {
    pub fn vips_operation_call_valist(
        operation: *mut VipsOperation,
        ap: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_operation_new(name: *const ::std::os::raw::c_char) -> *mut VipsOperation;
}
unsafe extern "C" {
    pub fn vips_call_required_optional(
        operation: *mut *mut VipsOperation,
        required: *mut __va_list_tag,
        optional: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_call(operation_name: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_call_split(
        operation_name: *const ::std::os::raw::c_char,
        optional: *mut __va_list_tag,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_call_split_option_string(
        operation_name: *const ::std::os::raw::c_char,
        option_string: *const ::std::os::raw::c_char,
        optional: *mut __va_list_tag,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_call_options(group: *mut GOptionGroup, operation: *mut VipsOperation);
}
unsafe extern "C" {
    pub fn vips_call_argv(
        operation: *mut VipsOperation,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cache_drop_all();
}
unsafe extern "C" {
    pub fn vips_cache_operation_lookup(operation: *mut VipsOperation) -> *mut VipsOperation;
}
unsafe extern "C" {
    pub fn vips_cache_operation_add(operation: *mut VipsOperation);
}
unsafe extern "C" {
    pub fn vips_cache_operation_buildp(operation: *mut *mut VipsOperation)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cache_operation_build(operation: *mut VipsOperation) -> *mut VipsOperation;
}
unsafe extern "C" {
    pub fn vips_cache_print();
}
unsafe extern "C" {
    pub fn vips_cache_set_max(max: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_cache_set_max_mem(max_mem: usize);
}
unsafe extern "C" {
    pub fn vips_cache_get_max() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cache_get_size() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cache_get_max_mem() -> usize;
}
unsafe extern "C" {
    pub fn vips_cache_get_max_files() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cache_set_max_files(max_files: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_cache_set_dump(dump: gboolean);
}
unsafe extern "C" {
    pub fn vips_cache_set_trace(trace: gboolean);
}
unsafe extern "C" {
    pub fn vips_concurrency_set(concurrency: ::std::os::raw::c_int);
}
unsafe extern "C" {
    pub fn vips_concurrency_get() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_operation_block_set(name: *const ::std::os::raw::c_char, state: gboolean);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeign {
    pub parent_object: VipsOperation,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsForeign"][::std::mem::size_of::<_VipsForeign>() - 96usize];
    ["Alignment of _VipsForeign"][::std::mem::align_of::<_VipsForeign>() - 8usize];
    ["Offset of field: _VipsForeign::parent_object"]
        [::std::mem::offset_of!(_VipsForeign, parent_object) - 0usize];
};
pub type VipsForeign = _VipsForeign;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignClass {
    pub parent_class: VipsOperationClass,
    pub priority: ::std::os::raw::c_int,
    pub suffs: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsForeignClass"][::std::mem::size_of::<_VipsForeignClass>() - 376usize];
    ["Alignment of _VipsForeignClass"][::std::mem::align_of::<_VipsForeignClass>() - 8usize];
    ["Offset of field: _VipsForeignClass::parent_class"]
        [::std::mem::offset_of!(_VipsForeignClass, parent_class) - 0usize];
    ["Offset of field: _VipsForeignClass::priority"]
        [::std::mem::offset_of!(_VipsForeignClass, priority) - 360usize];
    ["Offset of field: _VipsForeignClass::suffs"]
        [::std::mem::offset_of!(_VipsForeignClass, suffs) - 368usize];
};
pub type VipsForeignClass = _VipsForeignClass;
unsafe extern "C" {
    pub fn vips_foreign_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_map(
        base: *const ::std::os::raw::c_char,
        fn_: VipsSListMap2Fn,
        a: *mut ::std::os::raw::c_void,
        b: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
pub const VipsForeignFlags_VIPS_FOREIGN_NONE: VipsForeignFlags = 0;
pub const VipsForeignFlags_VIPS_FOREIGN_PARTIAL: VipsForeignFlags = 1;
pub const VipsForeignFlags_VIPS_FOREIGN_BIGENDIAN: VipsForeignFlags = 2;
pub const VipsForeignFlags_VIPS_FOREIGN_SEQUENTIAL: VipsForeignFlags = 4;
pub const VipsForeignFlags_VIPS_FOREIGN_ALL: VipsForeignFlags = 7;
pub type VipsForeignFlags = ::std::os::raw::c_uint;
pub const VipsFailOn_VIPS_FAIL_ON_NONE: VipsFailOn = 0;
pub const VipsFailOn_VIPS_FAIL_ON_TRUNCATED: VipsFailOn = 1;
pub const VipsFailOn_VIPS_FAIL_ON_ERROR: VipsFailOn = 2;
pub const VipsFailOn_VIPS_FAIL_ON_WARNING: VipsFailOn = 3;
pub const VipsFailOn_VIPS_FAIL_ON_LAST: VipsFailOn = 4;
pub type VipsFailOn = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignLoad {
    pub parent_object: VipsForeign,
    pub memory: gboolean,
    pub access: VipsAccess,
    pub flags: VipsForeignFlags,
    pub fail_on: VipsFailOn,
    pub fail: gboolean,
    pub sequential: gboolean,
    pub out: *mut VipsImage,
    pub real: *mut VipsImage,
    pub nocache: gboolean,
    pub disc: gboolean,
    pub error: gboolean,
    pub revalidate: gboolean,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsForeignLoad"][::std::mem::size_of::<_VipsForeignLoad>() - 152usize];
    ["Alignment of _VipsForeignLoad"][::std::mem::align_of::<_VipsForeignLoad>() - 8usize];
    ["Offset of field: _VipsForeignLoad::parent_object"]
        [::std::mem::offset_of!(_VipsForeignLoad, parent_object) - 0usize];
    ["Offset of field: _VipsForeignLoad::memory"]
        [::std::mem::offset_of!(_VipsForeignLoad, memory) - 96usize];
    ["Offset of field: _VipsForeignLoad::access"]
        [::std::mem::offset_of!(_VipsForeignLoad, access) - 100usize];
    ["Offset of field: _VipsForeignLoad::flags"]
        [::std::mem::offset_of!(_VipsForeignLoad, flags) - 104usize];
    ["Offset of field: _VipsForeignLoad::fail_on"]
        [::std::mem::offset_of!(_VipsForeignLoad, fail_on) - 108usize];
    ["Offset of field: _VipsForeignLoad::fail"]
        [::std::mem::offset_of!(_VipsForeignLoad, fail) - 112usize];
    ["Offset of field: _VipsForeignLoad::sequential"]
        [::std::mem::offset_of!(_VipsForeignLoad, sequential) - 116usize];
    ["Offset of field: _VipsForeignLoad::out"]
        [::std::mem::offset_of!(_VipsForeignLoad, out) - 120usize];
    ["Offset of field: _VipsForeignLoad::real"]
        [::std::mem::offset_of!(_VipsForeignLoad, real) - 128usize];
    ["Offset of field: _VipsForeignLoad::nocache"]
        [::std::mem::offset_of!(_VipsForeignLoad, nocache) - 136usize];
    ["Offset of field: _VipsForeignLoad::disc"]
        [::std::mem::offset_of!(_VipsForeignLoad, disc) - 140usize];
    ["Offset of field: _VipsForeignLoad::error"]
        [::std::mem::offset_of!(_VipsForeignLoad, error) - 144usize];
    ["Offset of field: _VipsForeignLoad::revalidate"]
        [::std::mem::offset_of!(_VipsForeignLoad, revalidate) - 148usize];
};
pub type VipsForeignLoad = _VipsForeignLoad;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignLoadClass {
    pub parent_class: VipsForeignClass,
    pub is_a: ::std::option::Option<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> gboolean,
    >,
    pub is_a_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *const ::std::os::raw::c_void, size: usize) -> gboolean,
    >,
    pub is_a_source:
        ::std::option::Option<unsafe extern "C" fn(source: *mut VipsSource) -> gboolean>,
    pub get_flags_filename: ::std::option::Option<
        unsafe extern "C" fn(filename: *const ::std::os::raw::c_char) -> VipsForeignFlags,
    >,
    pub get_flags:
        ::std::option::Option<unsafe extern "C" fn(load: *mut VipsForeignLoad) -> VipsForeignFlags>,
    pub header: ::std::option::Option<
        unsafe extern "C" fn(load: *mut VipsForeignLoad) -> ::std::os::raw::c_int,
    >,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(load: *mut VipsForeignLoad) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsForeignLoadClass"][::std::mem::size_of::<_VipsForeignLoadClass>() - 432usize];
    ["Alignment of _VipsForeignLoadClass"]
        [::std::mem::align_of::<_VipsForeignLoadClass>() - 8usize];
    ["Offset of field: _VipsForeignLoadClass::parent_class"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, parent_class) - 0usize];
    ["Offset of field: _VipsForeignLoadClass::is_a"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, is_a) - 376usize];
    ["Offset of field: _VipsForeignLoadClass::is_a_buffer"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, is_a_buffer) - 384usize];
    ["Offset of field: _VipsForeignLoadClass::is_a_source"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, is_a_source) - 392usize];
    ["Offset of field: _VipsForeignLoadClass::get_flags_filename"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, get_flags_filename) - 400usize];
    ["Offset of field: _VipsForeignLoadClass::get_flags"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, get_flags) - 408usize];
    ["Offset of field: _VipsForeignLoadClass::header"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, header) - 416usize];
    ["Offset of field: _VipsForeignLoadClass::load"]
        [::std::mem::offset_of!(_VipsForeignLoadClass, load) - 424usize];
};
pub type VipsForeignLoadClass = _VipsForeignLoadClass;
unsafe extern "C" {
    pub fn vips_foreign_load_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_find_load(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_foreign_find_load_buffer(
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_foreign_find_load_source(source: *mut VipsSource) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_foreign_flags(
        loader: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> VipsForeignFlags;
}
unsafe extern "C" {
    pub fn vips_foreign_is_a(
        loader: *const ::std::os::raw::c_char,
        filename: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_foreign_is_a_buffer(
        loader: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_foreign_is_a_source(
        loader: *const ::std::os::raw::c_char,
        source: *mut VipsSource,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_foreign_load_invalidate(image: *mut VipsImage);
}
pub const VipsSaveable_VIPS_SAVEABLE_MONO: VipsSaveable = 0;
pub const VipsSaveable_VIPS_SAVEABLE_RGB: VipsSaveable = 1;
pub const VipsSaveable_VIPS_SAVEABLE_RGBA: VipsSaveable = 2;
pub const VipsSaveable_VIPS_SAVEABLE_RGBA_ONLY: VipsSaveable = 3;
pub const VipsSaveable_VIPS_SAVEABLE_RGB_CMYK: VipsSaveable = 4;
pub const VipsSaveable_VIPS_SAVEABLE_ANY: VipsSaveable = 5;
pub const VipsSaveable_VIPS_SAVEABLE_LAST: VipsSaveable = 6;
pub type VipsSaveable = ::std::os::raw::c_uint;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_NONE: VipsForeignKeep = 0;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_EXIF: VipsForeignKeep = 1;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_XMP: VipsForeignKeep = 2;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_IPTC: VipsForeignKeep = 4;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_ICC: VipsForeignKeep = 8;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_OTHER: VipsForeignKeep = 16;
pub const VipsForeignKeep_VIPS_FOREIGN_KEEP_ALL: VipsForeignKeep = 31;
pub type VipsForeignKeep = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignSave {
    pub parent_object: VipsForeign,
    pub strip: gboolean,
    pub keep: VipsForeignKeep,
    pub profile: *mut ::std::os::raw::c_char,
    pub background: *mut VipsArrayDouble,
    pub page_height: ::std::os::raw::c_int,
    pub in_: *mut VipsImage,
    pub ready: *mut VipsImage,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsForeignSave"][::std::mem::size_of::<_VipsForeignSave>() - 144usize];
    ["Alignment of _VipsForeignSave"][::std::mem::align_of::<_VipsForeignSave>() - 8usize];
    ["Offset of field: _VipsForeignSave::parent_object"]
        [::std::mem::offset_of!(_VipsForeignSave, parent_object) - 0usize];
    ["Offset of field: _VipsForeignSave::strip"]
        [::std::mem::offset_of!(_VipsForeignSave, strip) - 96usize];
    ["Offset of field: _VipsForeignSave::keep"]
        [::std::mem::offset_of!(_VipsForeignSave, keep) - 100usize];
    ["Offset of field: _VipsForeignSave::profile"]
        [::std::mem::offset_of!(_VipsForeignSave, profile) - 104usize];
    ["Offset of field: _VipsForeignSave::background"]
        [::std::mem::offset_of!(_VipsForeignSave, background) - 112usize];
    ["Offset of field: _VipsForeignSave::page_height"]
        [::std::mem::offset_of!(_VipsForeignSave, page_height) - 120usize];
    ["Offset of field: _VipsForeignSave::in_"]
        [::std::mem::offset_of!(_VipsForeignSave, in_) - 128usize];
    ["Offset of field: _VipsForeignSave::ready"]
        [::std::mem::offset_of!(_VipsForeignSave, ready) - 136usize];
};
pub type VipsForeignSave = _VipsForeignSave;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VipsForeignSaveClass {
    pub parent_class: VipsForeignClass,
    pub saveable: VipsSaveable,
    pub format_table: *mut VipsBandFormat,
    pub coding: [gboolean; 7usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _VipsForeignSaveClass"][::std::mem::size_of::<_VipsForeignSaveClass>() - 424usize];
    ["Alignment of _VipsForeignSaveClass"]
        [::std::mem::align_of::<_VipsForeignSaveClass>() - 8usize];
    ["Offset of field: _VipsForeignSaveClass::parent_class"]
        [::std::mem::offset_of!(_VipsForeignSaveClass, parent_class) - 0usize];
    ["Offset of field: _VipsForeignSaveClass::saveable"]
        [::std::mem::offset_of!(_VipsForeignSaveClass, saveable) - 376usize];
    ["Offset of field: _VipsForeignSaveClass::format_table"]
        [::std::mem::offset_of!(_VipsForeignSaveClass, format_table) - 384usize];
    ["Offset of field: _VipsForeignSaveClass::coding"]
        [::std::mem::offset_of!(_VipsForeignSaveClass, coding) - 392usize];
};
pub type VipsForeignSaveClass = _VipsForeignSaveClass;
unsafe extern "C" {
    pub fn vips_foreign_save_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_find_save(
        filename: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_foreign_get_suffixes() -> *mut *mut gchar;
}
unsafe extern "C" {
    pub fn vips_foreign_find_save_buffer(
        suffix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_foreign_find_save_target(
        suffix: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_vipsload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_vipsload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_vipssave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_vipssave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_openslideload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_openslideload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_AUTO: VipsForeignSubsample = 0;
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_ON: VipsForeignSubsample = 1;
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_OFF: VipsForeignSubsample = 2;
pub const VipsForeignSubsample_VIPS_FOREIGN_SUBSAMPLE_LAST: VipsForeignSubsample = 3;
pub type VipsForeignSubsample = ::std::os::raw::c_uint;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_AUTO: VipsForeignJpegSubsample = 0;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_ON: VipsForeignJpegSubsample = 1;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_OFF: VipsForeignJpegSubsample = 2;
pub const VipsForeignJpegSubsample_VIPS_FOREIGN_JPEG_SUBSAMPLE_LAST: VipsForeignJpegSubsample = 3;
pub type VipsForeignJpegSubsample = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_jpegload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jpegload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jpegload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jpegsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jpegsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jpegsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jpegsave_mime(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_DEFAULT: VipsForeignWebpPreset = 0;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_PICTURE: VipsForeignWebpPreset = 1;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_PHOTO: VipsForeignWebpPreset = 2;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_DRAWING: VipsForeignWebpPreset = 3;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_ICON: VipsForeignWebpPreset = 4;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_TEXT: VipsForeignWebpPreset = 5;
pub const VipsForeignWebpPreset_VIPS_FOREIGN_WEBP_PRESET_LAST: VipsForeignWebpPreset = 6;
pub type VipsForeignWebpPreset = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_webpload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_webpload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_webpload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_webpsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_webpsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_webpsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_webpsave_mime(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_NONE:
    VipsForeignTiffCompression = 0;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_JPEG:
    VipsForeignTiffCompression = 1;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_DEFLATE:
    VipsForeignTiffCompression = 2;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_PACKBITS:
    VipsForeignTiffCompression = 3;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_CCITTFAX4:
    VipsForeignTiffCompression = 4;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_LZW: VipsForeignTiffCompression =
    5;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_WEBP:
    VipsForeignTiffCompression = 6;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_ZSTD:
    VipsForeignTiffCompression = 7;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_JP2K:
    VipsForeignTiffCompression = 8;
pub const VipsForeignTiffCompression_VIPS_FOREIGN_TIFF_COMPRESSION_LAST:
    VipsForeignTiffCompression = 9;
pub type VipsForeignTiffCompression = ::std::os::raw::c_uint;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_NONE: VipsForeignTiffPredictor = 1;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_HORIZONTAL:
    VipsForeignTiffPredictor = 2;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT: VipsForeignTiffPredictor = 3;
pub const VipsForeignTiffPredictor_VIPS_FOREIGN_TIFF_PREDICTOR_LAST: VipsForeignTiffPredictor = 4;
pub type VipsForeignTiffPredictor = ::std::os::raw::c_uint;
pub const VipsForeignTiffResunit_VIPS_FOREIGN_TIFF_RESUNIT_CM: VipsForeignTiffResunit = 0;
pub const VipsForeignTiffResunit_VIPS_FOREIGN_TIFF_RESUNIT_INCH: VipsForeignTiffResunit = 1;
pub const VipsForeignTiffResunit_VIPS_FOREIGN_TIFF_RESUNIT_LAST: VipsForeignTiffResunit = 2;
pub type VipsForeignTiffResunit = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_tiffload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tiffload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tiffload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tiffsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tiffsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tiffsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_openexrload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_fitsload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_fitssave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_analyzeload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rawload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        bands: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rawsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rawsave_fd(
        in_: *mut VipsImage,
        fd: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_csvload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_csvload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_csvsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_csvsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matrixload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matrixload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matrixsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matrixsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matrixprint(in_: *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_magickload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_magickload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_magicksave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_magicksave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_NONE: VipsForeignPngFilter = 8;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_SUB: VipsForeignPngFilter = 16;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_UP: VipsForeignPngFilter = 32;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_AVG: VipsForeignPngFilter = 64;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_PAETH: VipsForeignPngFilter = 128;
pub const VipsForeignPngFilter_VIPS_FOREIGN_PNG_FILTER_ALL: VipsForeignPngFilter = 248;
pub type VipsForeignPngFilter = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_pngload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pngload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pngload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pngsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pngsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pngsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PBM: VipsForeignPpmFormat = 0;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PGM: VipsForeignPpmFormat = 1;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PPM: VipsForeignPpmFormat = 2;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PFM: VipsForeignPpmFormat = 3;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_PNM: VipsForeignPpmFormat = 4;
pub const VipsForeignPpmFormat_VIPS_FOREIGN_PPM_FORMAT_LAST: VipsForeignPpmFormat = 5;
pub type VipsForeignPpmFormat = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_ppmload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_ppmload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_ppmsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_ppmsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_radload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_radload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_radload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_radsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_radsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_radsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pdfload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pdfload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pdfload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_svgload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_svgload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_svgload_string(
        str_: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_svgload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gifload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gifload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gifload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gifsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gifsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gifsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_heifload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_heifload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_heifload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_heifsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_heifsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_heifsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_niftiload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_niftiload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_niftisave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jp2kload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jp2kload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jp2kload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jp2ksave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jp2ksave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jp2ksave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jxlload_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jxlload_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jxlload(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jxlsave(
        in_: *mut VipsImage,
        filename: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jxlsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_jxlsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_DZ: VipsForeignDzLayout = 0;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_ZOOMIFY: VipsForeignDzLayout = 1;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_GOOGLE: VipsForeignDzLayout = 2;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_IIIF: VipsForeignDzLayout = 3;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_IIIF3: VipsForeignDzLayout = 4;
pub const VipsForeignDzLayout_VIPS_FOREIGN_DZ_LAYOUT_LAST: VipsForeignDzLayout = 5;
pub type VipsForeignDzLayout = ::std::os::raw::c_uint;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL: VipsForeignDzDepth = 0;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_ONETILE: VipsForeignDzDepth = 1;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_ONE: VipsForeignDzDepth = 2;
pub const VipsForeignDzDepth_VIPS_FOREIGN_DZ_DEPTH_LAST: VipsForeignDzDepth = 3;
pub type VipsForeignDzDepth = ::std::os::raw::c_uint;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_FS: VipsForeignDzContainer = 0;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_ZIP: VipsForeignDzContainer = 1;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_SZI: VipsForeignDzContainer = 2;
pub const VipsForeignDzContainer_VIPS_FOREIGN_DZ_CONTAINER_LAST: VipsForeignDzContainer = 3;
pub type VipsForeignDzContainer = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_dzsave(
        in_: *mut VipsImage,
        name: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_dzsave_buffer(
        in_: *mut VipsImage,
        buf: *mut *mut ::std::os::raw::c_void,
        len: *mut usize,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_dzsave_target(
        in_: *mut VipsImage,
        target: *mut VipsTarget,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_HEVC:
    VipsForeignHeifCompression = 1;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_AVC: VipsForeignHeifCompression =
    2;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_JPEG:
    VipsForeignHeifCompression = 3;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_AV1: VipsForeignHeifCompression =
    4;
pub const VipsForeignHeifCompression_VIPS_FOREIGN_HEIF_COMPRESSION_LAST:
    VipsForeignHeifCompression = 5;
pub type VipsForeignHeifCompression = ::std::os::raw::c_uint;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_AUTO: VipsForeignHeifEncoder = 0;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_AOM: VipsForeignHeifEncoder = 1;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_RAV1E: VipsForeignHeifEncoder = 2;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_SVT: VipsForeignHeifEncoder = 3;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_X265: VipsForeignHeifEncoder = 4;
pub const VipsForeignHeifEncoder_VIPS_FOREIGN_HEIF_ENCODER_LAST: VipsForeignHeifEncoder = 5;
pub type VipsForeignHeifEncoder = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_operation_math_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_math2_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_round_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_relational_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_boolean_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_complex_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_complex2_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_complexget_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_precision_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_intent_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_pcs_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_extend_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_compass_direction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_direction_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_align_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_angle_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_angle45_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_interesting_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_blend_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_combine_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_text_wrap_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_combine_mode_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_fail_on_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_saveable_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_keep_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_subsample_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_jpeg_subsample_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_webp_preset_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_tiff_compression_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_tiff_predictor_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_tiff_resunit_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_png_filter_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_ppm_format_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_dz_layout_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_dz_depth_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_dz_container_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_heif_compression_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_foreign_heif_encoder_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_demand_style_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_image_type_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_interpretation_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_band_format_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_coding_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_access_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_morphology_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_argument_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_operation_flags_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_region_shrink_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_kernel_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_size_get_type() -> GType;
}
unsafe extern "C" {
    pub fn vips_token_get_type() -> GType;
}
pub const VipsOperationMath_VIPS_OPERATION_MATH_SIN: VipsOperationMath = 0;
pub const VipsOperationMath_VIPS_OPERATION_MATH_COS: VipsOperationMath = 1;
pub const VipsOperationMath_VIPS_OPERATION_MATH_TAN: VipsOperationMath = 2;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ASIN: VipsOperationMath = 3;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ACOS: VipsOperationMath = 4;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ATAN: VipsOperationMath = 5;
pub const VipsOperationMath_VIPS_OPERATION_MATH_LOG: VipsOperationMath = 6;
pub const VipsOperationMath_VIPS_OPERATION_MATH_LOG10: VipsOperationMath = 7;
pub const VipsOperationMath_VIPS_OPERATION_MATH_EXP: VipsOperationMath = 8;
pub const VipsOperationMath_VIPS_OPERATION_MATH_EXP10: VipsOperationMath = 9;
pub const VipsOperationMath_VIPS_OPERATION_MATH_SINH: VipsOperationMath = 10;
pub const VipsOperationMath_VIPS_OPERATION_MATH_COSH: VipsOperationMath = 11;
pub const VipsOperationMath_VIPS_OPERATION_MATH_TANH: VipsOperationMath = 12;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ASINH: VipsOperationMath = 13;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ACOSH: VipsOperationMath = 14;
pub const VipsOperationMath_VIPS_OPERATION_MATH_ATANH: VipsOperationMath = 15;
pub const VipsOperationMath_VIPS_OPERATION_MATH_LAST: VipsOperationMath = 16;
pub type VipsOperationMath = ::std::os::raw::c_uint;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_POW: VipsOperationMath2 = 0;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_WOP: VipsOperationMath2 = 1;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_ATAN2: VipsOperationMath2 = 2;
pub const VipsOperationMath2_VIPS_OPERATION_MATH2_LAST: VipsOperationMath2 = 3;
pub type VipsOperationMath2 = ::std::os::raw::c_uint;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_RINT: VipsOperationRound = 0;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_CEIL: VipsOperationRound = 1;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_FLOOR: VipsOperationRound = 2;
pub const VipsOperationRound_VIPS_OPERATION_ROUND_LAST: VipsOperationRound = 3;
pub type VipsOperationRound = ::std::os::raw::c_uint;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_EQUAL: VipsOperationRelational = 0;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_NOTEQ: VipsOperationRelational = 1;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_LESS: VipsOperationRelational = 2;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_LESSEQ: VipsOperationRelational = 3;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_MORE: VipsOperationRelational = 4;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_MOREEQ: VipsOperationRelational = 5;
pub const VipsOperationRelational_VIPS_OPERATION_RELATIONAL_LAST: VipsOperationRelational = 6;
pub type VipsOperationRelational = ::std::os::raw::c_uint;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_AND: VipsOperationBoolean = 0;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_OR: VipsOperationBoolean = 1;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_EOR: VipsOperationBoolean = 2;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_LSHIFT: VipsOperationBoolean = 3;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_RSHIFT: VipsOperationBoolean = 4;
pub const VipsOperationBoolean_VIPS_OPERATION_BOOLEAN_LAST: VipsOperationBoolean = 5;
pub type VipsOperationBoolean = ::std::os::raw::c_uint;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_POLAR: VipsOperationComplex = 0;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_RECT: VipsOperationComplex = 1;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_CONJ: VipsOperationComplex = 2;
pub const VipsOperationComplex_VIPS_OPERATION_COMPLEX_LAST: VipsOperationComplex = 3;
pub type VipsOperationComplex = ::std::os::raw::c_uint;
pub const VipsOperationComplex2_VIPS_OPERATION_COMPLEX2_CROSS_PHASE: VipsOperationComplex2 = 0;
pub const VipsOperationComplex2_VIPS_OPERATION_COMPLEX2_LAST: VipsOperationComplex2 = 1;
pub type VipsOperationComplex2 = ::std::os::raw::c_uint;
pub const VipsOperationComplexget_VIPS_OPERATION_COMPLEXGET_REAL: VipsOperationComplexget = 0;
pub const VipsOperationComplexget_VIPS_OPERATION_COMPLEXGET_IMAG: VipsOperationComplexget = 1;
pub const VipsOperationComplexget_VIPS_OPERATION_COMPLEXGET_LAST: VipsOperationComplexget = 2;
pub type VipsOperationComplexget = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_add(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sum(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_subtract(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_multiply(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_divide(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_linear(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: *const f64,
        b: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_linear1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: f64,
        b: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_remainder(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_remainder_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_remainder_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_invert(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_abs(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sign(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_round(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        round: VipsOperationRound,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_floor(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_ceil(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rint(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_math(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math: VipsOperationMath,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sin(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cos(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tan(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_asin(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_acos(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_atan(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_exp(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_exp10(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_log(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_log10(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sinh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cosh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tanh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_asinh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_acosh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_atanh(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_complex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        cmplx: VipsOperationComplex,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_polar(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rect(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_conj(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_complex2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        cmplx: VipsOperationComplex2,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cross_phase(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_complexget(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        get: VipsOperationComplexget,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_real(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_imag(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_complexform(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_relational(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_equal(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_notequal(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_less(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_lesseq(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_more(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_moreeq(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_relational_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_equal_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_notequal_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_less_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_lesseq_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_more_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_moreeq_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_relational_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        relational: VipsOperationRelational,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_equal_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_notequal_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_less_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_lesseq_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_more_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_moreeq_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_boolean(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_andimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_orimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_eorimage(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_lshift(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rshift(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_boolean_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_andimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_orimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_eorimage_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_lshift_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rshift_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_boolean_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_andimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_orimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_eorimage_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_lshift_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rshift_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_math2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pow(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_wop(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_atan2(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_math2_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pow_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_wop_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_atan2_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *const f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_math2_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        math2: VipsOperationMath2,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pow_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_wop_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_atan2_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_avg(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_deviate(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_min(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_max(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_stats(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_measure(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        h: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_find_trim(
        in_: *mut VipsImage,
        left: *mut ::std::os::raw::c_int,
        top: *mut ::std::os::raw::c_int,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_getpoint(
        in_: *mut VipsImage,
        vector: *mut *mut f64,
        n: *mut ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_find(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_find_ndim(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_find_indexed(
        in_: *mut VipsImage,
        index: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hough_line(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hough_circle(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_project(
        in_: *mut VipsImage,
        columns: *mut *mut VipsImage,
        rows: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_profile(
        in_: *mut VipsImage,
        columns: *mut *mut VipsImage,
        rows: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsExtend_VIPS_EXTEND_BLACK: VipsExtend = 0;
pub const VipsExtend_VIPS_EXTEND_COPY: VipsExtend = 1;
pub const VipsExtend_VIPS_EXTEND_REPEAT: VipsExtend = 2;
pub const VipsExtend_VIPS_EXTEND_MIRROR: VipsExtend = 3;
pub const VipsExtend_VIPS_EXTEND_WHITE: VipsExtend = 4;
pub const VipsExtend_VIPS_EXTEND_BACKGROUND: VipsExtend = 5;
pub const VipsExtend_VIPS_EXTEND_LAST: VipsExtend = 6;
pub type VipsExtend = ::std::os::raw::c_uint;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_CENTRE: VipsCompassDirection = 0;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_NORTH: VipsCompassDirection = 1;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_EAST: VipsCompassDirection = 2;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_SOUTH: VipsCompassDirection = 3;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_WEST: VipsCompassDirection = 4;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_NORTH_EAST: VipsCompassDirection = 5;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_SOUTH_EAST: VipsCompassDirection = 6;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_SOUTH_WEST: VipsCompassDirection = 7;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_NORTH_WEST: VipsCompassDirection = 8;
pub const VipsCompassDirection_VIPS_COMPASS_DIRECTION_LAST: VipsCompassDirection = 9;
pub type VipsCompassDirection = ::std::os::raw::c_uint;
pub const VipsDirection_VIPS_DIRECTION_HORIZONTAL: VipsDirection = 0;
pub const VipsDirection_VIPS_DIRECTION_VERTICAL: VipsDirection = 1;
pub const VipsDirection_VIPS_DIRECTION_LAST: VipsDirection = 2;
pub type VipsDirection = ::std::os::raw::c_uint;
pub const VipsAlign_VIPS_ALIGN_LOW: VipsAlign = 0;
pub const VipsAlign_VIPS_ALIGN_CENTRE: VipsAlign = 1;
pub const VipsAlign_VIPS_ALIGN_HIGH: VipsAlign = 2;
pub const VipsAlign_VIPS_ALIGN_LAST: VipsAlign = 3;
pub type VipsAlign = ::std::os::raw::c_uint;
pub const VipsAngle_VIPS_ANGLE_D0: VipsAngle = 0;
pub const VipsAngle_VIPS_ANGLE_D90: VipsAngle = 1;
pub const VipsAngle_VIPS_ANGLE_D180: VipsAngle = 2;
pub const VipsAngle_VIPS_ANGLE_D270: VipsAngle = 3;
pub const VipsAngle_VIPS_ANGLE_LAST: VipsAngle = 4;
pub type VipsAngle = ::std::os::raw::c_uint;
pub const VipsAngle45_VIPS_ANGLE45_D0: VipsAngle45 = 0;
pub const VipsAngle45_VIPS_ANGLE45_D45: VipsAngle45 = 1;
pub const VipsAngle45_VIPS_ANGLE45_D90: VipsAngle45 = 2;
pub const VipsAngle45_VIPS_ANGLE45_D135: VipsAngle45 = 3;
pub const VipsAngle45_VIPS_ANGLE45_D180: VipsAngle45 = 4;
pub const VipsAngle45_VIPS_ANGLE45_D225: VipsAngle45 = 5;
pub const VipsAngle45_VIPS_ANGLE45_D270: VipsAngle45 = 6;
pub const VipsAngle45_VIPS_ANGLE45_D315: VipsAngle45 = 7;
pub const VipsAngle45_VIPS_ANGLE45_LAST: VipsAngle45 = 8;
pub type VipsAngle45 = ::std::os::raw::c_uint;
pub const VipsInteresting_VIPS_INTERESTING_NONE: VipsInteresting = 0;
pub const VipsInteresting_VIPS_INTERESTING_CENTRE: VipsInteresting = 1;
pub const VipsInteresting_VIPS_INTERESTING_ENTROPY: VipsInteresting = 2;
pub const VipsInteresting_VIPS_INTERESTING_ATTENTION: VipsInteresting = 3;
pub const VipsInteresting_VIPS_INTERESTING_LOW: VipsInteresting = 4;
pub const VipsInteresting_VIPS_INTERESTING_HIGH: VipsInteresting = 5;
pub const VipsInteresting_VIPS_INTERESTING_ALL: VipsInteresting = 6;
pub const VipsInteresting_VIPS_INTERESTING_LAST: VipsInteresting = 7;
pub type VipsInteresting = ::std::os::raw::c_uint;
pub const VipsBlendMode_VIPS_BLEND_MODE_CLEAR: VipsBlendMode = 0;
pub const VipsBlendMode_VIPS_BLEND_MODE_SOURCE: VipsBlendMode = 1;
pub const VipsBlendMode_VIPS_BLEND_MODE_OVER: VipsBlendMode = 2;
pub const VipsBlendMode_VIPS_BLEND_MODE_IN: VipsBlendMode = 3;
pub const VipsBlendMode_VIPS_BLEND_MODE_OUT: VipsBlendMode = 4;
pub const VipsBlendMode_VIPS_BLEND_MODE_ATOP: VipsBlendMode = 5;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST: VipsBlendMode = 6;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_OVER: VipsBlendMode = 7;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_IN: VipsBlendMode = 8;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_OUT: VipsBlendMode = 9;
pub const VipsBlendMode_VIPS_BLEND_MODE_DEST_ATOP: VipsBlendMode = 10;
pub const VipsBlendMode_VIPS_BLEND_MODE_XOR: VipsBlendMode = 11;
pub const VipsBlendMode_VIPS_BLEND_MODE_ADD: VipsBlendMode = 12;
pub const VipsBlendMode_VIPS_BLEND_MODE_SATURATE: VipsBlendMode = 13;
pub const VipsBlendMode_VIPS_BLEND_MODE_MULTIPLY: VipsBlendMode = 14;
pub const VipsBlendMode_VIPS_BLEND_MODE_SCREEN: VipsBlendMode = 15;
pub const VipsBlendMode_VIPS_BLEND_MODE_OVERLAY: VipsBlendMode = 16;
pub const VipsBlendMode_VIPS_BLEND_MODE_DARKEN: VipsBlendMode = 17;
pub const VipsBlendMode_VIPS_BLEND_MODE_LIGHTEN: VipsBlendMode = 18;
pub const VipsBlendMode_VIPS_BLEND_MODE_COLOUR_DODGE: VipsBlendMode = 19;
pub const VipsBlendMode_VIPS_BLEND_MODE_COLOUR_BURN: VipsBlendMode = 20;
pub const VipsBlendMode_VIPS_BLEND_MODE_HARD_LIGHT: VipsBlendMode = 21;
pub const VipsBlendMode_VIPS_BLEND_MODE_SOFT_LIGHT: VipsBlendMode = 22;
pub const VipsBlendMode_VIPS_BLEND_MODE_DIFFERENCE: VipsBlendMode = 23;
pub const VipsBlendMode_VIPS_BLEND_MODE_EXCLUSION: VipsBlendMode = 24;
pub const VipsBlendMode_VIPS_BLEND_MODE_LAST: VipsBlendMode = 25;
pub type VipsBlendMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_copy(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tilecache(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_linecache(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sequential(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cache(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_copy_file(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_embed(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gravity(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsCompassDirection,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_flip(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_insert(
        main: *mut VipsImage,
        sub: *mut VipsImage,
        out: *mut *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_join(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_arrayjoin(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_extract_area(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_crop(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_smartcrop(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_extract_band(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        band: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_replicate(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        across: ::std::os::raw::c_int,
        down: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_grid(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        tile_height: ::std::os::raw::c_int,
        across: ::std::os::raw::c_int,
        down: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_transpose3d(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_wrap(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        angle: VipsAngle,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rot90(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rot180(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rot270(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rot45(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_autorot_remove_angle(image: *mut VipsImage);
}
unsafe extern "C" {
    pub fn vips_autorot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_zoom(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        xfac: ::std::os::raw::c_int,
        yfac: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_subsample(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        xfac: ::std::os::raw::c_int,
        yfac: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        format: VipsBandFormat,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_uchar(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_char(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_ushort(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_short(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_uint(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_int(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_float(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_double(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_complex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_cast_dpcomplex(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_scale(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_msb(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_byteswap(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandjoin(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandjoin2(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandjoin_const(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: *mut f64,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandjoin_const1(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        c: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandrank(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandfold(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandunfold(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandbool(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        boolean: VipsOperationBoolean,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandand(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandor(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandeor(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_bandmean(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_recomb(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        m: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_ifthenelse(
        cond: *mut VipsImage,
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_switch(
        tests: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_flatten(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_addalpha(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_premultiply(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_unpremultiply(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_composite(
        in_: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        mode: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_composite2(
        base: *mut VipsImage,
        overlay: *mut VipsImage,
        out: *mut *mut VipsImage,
        mode: VipsBlendMode,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_falsecolour(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gamma(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsCombine_VIPS_COMBINE_MAX: VipsCombine = 0;
pub const VipsCombine_VIPS_COMBINE_SUM: VipsCombine = 1;
pub const VipsCombine_VIPS_COMBINE_MIN: VipsCombine = 2;
pub const VipsCombine_VIPS_COMBINE_LAST: VipsCombine = 3;
pub type VipsCombine = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_conv(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_convf(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_convi(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_conva(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_convsep(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_convasep(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_compass(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gaussblur(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        sigma: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sharpen(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_spcor(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_fastcor(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sobel(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_scharr(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_prewitt(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_canny(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
pub const VipsOperationMorphology_VIPS_OPERATION_MORPHOLOGY_ERODE: VipsOperationMorphology = 0;
pub const VipsOperationMorphology_VIPS_OPERATION_MORPHOLOGY_DILATE: VipsOperationMorphology = 1;
pub const VipsOperationMorphology_VIPS_OPERATION_MORPHOLOGY_LAST: VipsOperationMorphology = 2;
pub type VipsOperationMorphology = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_morph(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        mask: *mut VipsImage,
        morph: VipsOperationMorphology,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rank(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_median(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        size: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_countlines(
        in_: *mut VipsImage,
        nolines: *mut f64,
        direction: VipsDirection,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_labelregions(
        in_: *mut VipsImage,
        mask: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_fill_nearest(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_merge(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        dx: ::std::os::raw::c_int,
        dy: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mosaic(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        xref: ::std::os::raw::c_int,
        yref: ::std::os::raw::c_int,
        xsec: ::std::os::raw::c_int,
        ysec: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mosaic1(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        direction: VipsDirection,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xs1: ::std::os::raw::c_int,
        ys1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
        xs2: ::std::os::raw::c_int,
        ys2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_match(
        ref_: *mut VipsImage,
        sec: *mut VipsImage,
        out: *mut *mut VipsImage,
        xr1: ::std::os::raw::c_int,
        yr1: ::std::os::raw::c_int,
        xs1: ::std::os::raw::c_int,
        ys1: ::std::os::raw::c_int,
        xr2: ::std::os::raw::c_int,
        yr2: ::std::os::raw::c_int,
        xs2: ::std::os::raw::c_int,
        ys2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_globalbalance(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_remosaic(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        old_str: *const ::std::os::raw::c_char,
        new_str: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_matrixinvert(
        m: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_maplut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        lut: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_percent(
        in_: *mut VipsImage,
        percent: f64,
        threshold: *mut ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_stdif(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_cum(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_norm(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_equal(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_plot(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_match(
        in_: *mut VipsImage,
        ref_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_local(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_ismonotonic(
        in_: *mut VipsImage,
        out: *mut gboolean,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_hist_entropy(in_: *mut VipsImage, out: *mut f64, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_case(
        index: *mut VipsImage,
        cases: *mut *mut VipsImage,
        out: *mut *mut VipsImage,
        n: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_fwfft(in_: *mut VipsImage, out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_invfft(in_: *mut VipsImage, out: *mut *mut VipsImage, ...)
        -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_freqmult(
        in_: *mut VipsImage,
        mask: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_spectrum(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_phasecor(
        in1: *mut VipsImage,
        in2: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsKernel_VIPS_KERNEL_NEAREST: VipsKernel = 0;
pub const VipsKernel_VIPS_KERNEL_LINEAR: VipsKernel = 1;
pub const VipsKernel_VIPS_KERNEL_CUBIC: VipsKernel = 2;
pub const VipsKernel_VIPS_KERNEL_MITCHELL: VipsKernel = 3;
pub const VipsKernel_VIPS_KERNEL_LANCZOS2: VipsKernel = 4;
pub const VipsKernel_VIPS_KERNEL_LANCZOS3: VipsKernel = 5;
pub const VipsKernel_VIPS_KERNEL_LAST: VipsKernel = 6;
pub type VipsKernel = ::std::os::raw::c_uint;
pub const VipsSize_VIPS_SIZE_BOTH: VipsSize = 0;
pub const VipsSize_VIPS_SIZE_UP: VipsSize = 1;
pub const VipsSize_VIPS_SIZE_DOWN: VipsSize = 2;
pub const VipsSize_VIPS_SIZE_FORCE: VipsSize = 3;
pub const VipsSize_VIPS_SIZE_LAST: VipsSize = 4;
pub type VipsSize = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_shrink(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_shrinkh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_shrinkv(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        vshrink: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_reduce(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_reduceh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        hshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_reducev(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        vshrink: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_thumbnail(
        filename: *const ::std::os::raw::c_char,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_thumbnail_buffer(
        buf: *mut ::std::os::raw::c_void,
        len: usize,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_thumbnail_image(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_thumbnail_source(
        source: *mut VipsSource,
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_similarity(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rotate(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        angle: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_affine(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        a: f64,
        b: f64,
        c: f64,
        d: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_resize(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        scale: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mapim(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        index: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_quadratic(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        coeff: *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsIntent_VIPS_INTENT_PERCEPTUAL: VipsIntent = 0;
pub const VipsIntent_VIPS_INTENT_RELATIVE: VipsIntent = 1;
pub const VipsIntent_VIPS_INTENT_SATURATION: VipsIntent = 2;
pub const VipsIntent_VIPS_INTENT_ABSOLUTE: VipsIntent = 3;
pub const VipsIntent_VIPS_INTENT_LAST: VipsIntent = 4;
pub type VipsIntent = ::std::os::raw::c_uint;
pub const VipsPCS_VIPS_PCS_LAB: VipsPCS = 0;
pub const VipsPCS_VIPS_PCS_XYZ: VipsPCS = 1;
pub const VipsPCS_VIPS_PCS_LAST: VipsPCS = 2;
pub type VipsPCS = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_colourspace_issupported(image: *const VipsImage) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_colourspace(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        space: VipsInterpretation,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LabQ2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_rad2float(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_float2rad(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LabS2LabQ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LabQ2LabS(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LabQ2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_Lab2LabQ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LCh2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_Lab2LCh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_Yxy2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_CMC2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_Lab2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_XYZ2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_XYZ2scRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_scRGB2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_scRGB2BW(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sRGB2scRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_scRGB2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_HSV2sRGB(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sRGB2HSV(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LCh2CMC(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_CMC2LCh(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_XYZ2Yxy(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_Yxy2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_LabS2Lab(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_Lab2LabS(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_CMYK2XYZ(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_XYZ2CMYK(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_profile_load(
        name: *const ::std::os::raw::c_char,
        profile: *mut *mut VipsBlob,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_icc_present() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_icc_transform(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        output_profile: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_icc_import(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_icc_export(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_icc_ac2rc(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        profile_filename: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_icc_is_compatible_profile(
        image: *mut VipsImage,
        data: *const ::std::os::raw::c_void,
        data_length: usize,
    ) -> gboolean;
}
unsafe extern "C" {
    pub fn vips_dE76(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_dE00(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_dECMC(
        left: *mut VipsImage,
        right: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_Lab2XYZ(L: f32, a: f32, b: f32, X: *mut f32, Y: *mut f32, Z: *mut f32);
}
unsafe extern "C" {
    pub fn vips_col_XYZ2Lab(X: f32, Y: f32, Z: f32, L: *mut f32, a: *mut f32, b: *mut f32);
}
unsafe extern "C" {
    pub fn vips_col_ab2h(a: f64, b: f64) -> f64;
}
unsafe extern "C" {
    pub fn vips_col_ab2Ch(a: f32, b: f32, C: *mut f32, h: *mut f32);
}
unsafe extern "C" {
    pub fn vips_col_Ch2ab(C: f32, h: f32, a: *mut f32, b: *mut f32);
}
unsafe extern "C" {
    pub fn vips_col_L2Lcmc(L: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_C2Ccmc(C: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_Ch2hcmc(C: f32, h: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_make_tables_CMC();
}
unsafe extern "C" {
    pub fn vips_col_Lcmc2L(Lcmc: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_Ccmc2C(Ccmc: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_Chcmc2h(C: f32, hcmc: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_sRGB2scRGB_8(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_sRGB2scRGB_16(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_sRGB2scRGB_8_noclip(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_sRGB2scRGB_16_noclip(
        r: ::std::os::raw::c_int,
        g: ::std::os::raw::c_int,
        b: ::std::os::raw::c_int,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_scRGB2XYZ(
        R: f32,
        G: f32,
        B: f32,
        X: *mut f32,
        Y: *mut f32,
        Z: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_XYZ2scRGB(
        X: f32,
        Y: f32,
        Z: f32,
        R: *mut f32,
        G: *mut f32,
        B: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_scRGB2sRGB_8(
        R: f32,
        G: f32,
        B: f32,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_scRGB2sRGB_16(
        R: f32,
        G: f32,
        B: f32,
        r: *mut ::std::os::raw::c_int,
        g: *mut ::std::os::raw::c_int,
        b: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_scRGB2BW_16(
        R: f32,
        G: f32,
        B: f32,
        g: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_col_scRGB2BW_8(
        R: f32,
        G: f32,
        B: f32,
        g: *mut ::std::os::raw::c_int,
        og: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_pythagoras(L1: f32, a1: f32, b1: f32, L2: f32, a2: f32, b2: f32) -> f32;
}
unsafe extern "C" {
    pub fn vips_col_dE00(L1: f32, a1: f32, b1: f32, L2: f32, a2: f32, b2: f32) -> f32;
}
pub const VipsCombineMode_VIPS_COMBINE_MODE_SET: VipsCombineMode = 0;
pub const VipsCombineMode_VIPS_COMBINE_MODE_ADD: VipsCombineMode = 1;
pub const VipsCombineMode_VIPS_COMBINE_MODE_LAST: VipsCombineMode = 2;
pub type VipsCombineMode = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_draw_rect(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_rect1(
        image: *mut VipsImage,
        ink: f64,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_point(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_point1(
        image: *mut VipsImage,
        ink: f64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_image(
        image: *mut VipsImage,
        sub: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_mask(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        mask: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_mask1(
        image: *mut VipsImage,
        ink: f64,
        mask: *mut VipsImage,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_line(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_line1(
        image: *mut VipsImage,
        ink: f64,
        x1: ::std::os::raw::c_int,
        y1: ::std::os::raw::c_int,
        x2: ::std::os::raw::c_int,
        y2: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_circle(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_circle1(
        image: *mut VipsImage,
        ink: f64,
        cx: ::std::os::raw::c_int,
        cy: ::std::os::raw::c_int,
        radius: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_flood(
        image: *mut VipsImage,
        ink: *mut f64,
        n: ::std::os::raw::c_int,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_flood1(
        image: *mut VipsImage,
        ink: f64,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_draw_smudge(
        image: *mut VipsImage,
        left: ::std::os::raw::c_int,
        top: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
pub const VipsTextWrap_VIPS_TEXT_WRAP_WORD: VipsTextWrap = 0;
pub const VipsTextWrap_VIPS_TEXT_WRAP_CHAR: VipsTextWrap = 1;
pub const VipsTextWrap_VIPS_TEXT_WRAP_WORD_CHAR: VipsTextWrap = 2;
pub const VipsTextWrap_VIPS_TEXT_WRAP_NONE: VipsTextWrap = 3;
pub const VipsTextWrap_VIPS_TEXT_WRAP_LAST: VipsTextWrap = 4;
pub type VipsTextWrap = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn vips_black(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_xyz(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_grey(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gaussmat(
        out: *mut *mut VipsImage,
        sigma: f64,
        min_ampl: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_logmat(
        out: *mut *mut VipsImage,
        sigma: f64,
        min_ampl: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_text(
        out: *mut *mut VipsImage,
        text: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_gaussnoise(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_eye(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_sines(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_zone(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_identity(out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_buildlut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_invertlut(
        in_: *mut VipsImage,
        out: *mut *mut VipsImage,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_tonelut(out: *mut *mut VipsImage, ...) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_ideal(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_ideal_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_ideal_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_butterworth(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_butterworth_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_butterworth_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        order: f64,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_gaussian(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_gaussian_ring(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff: f64,
        amplitude_cutoff: f64,
        ringwidth: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_gaussian_band(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        frequency_cutoff_x: f64,
        frequency_cutoff_y: f64,
        radius: f64,
        amplitude_cutoff: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_mask_fractal(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fractal_dimension: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_fractsurf(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        fractal_dimension: f64,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_worley(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_perlin(
        out: *mut *mut VipsImage,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_video_v4l1(
        im: *mut VipsImage,
        device: *const ::std::os::raw::c_char,
        channel: ::std::os::raw::c_int,
        brightness: ::std::os::raw::c_int,
        colour: ::std::os::raw::c_int,
        contrast: ::std::os::raw::c_int,
        hue: ::std::os::raw::c_int,
        ngrabs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn im_video_test(
        im: *mut VipsImage,
        brightness: ::std::os::raw::c_int,
        error: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_init(argv0: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_get_argv0() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_get_prgname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_shutdown();
}
unsafe extern "C" {
    pub fn vips_thread_shutdown();
}
unsafe extern "C" {
    pub fn vips_add_option_entries(option_group: *mut GOptionGroup);
}
unsafe extern "C" {
    pub fn vips_leak_set(leak: gboolean);
}
unsafe extern "C" {
    pub fn vips_block_untrusted_set(state: gboolean);
}
unsafe extern "C" {
    pub fn vips_version_string() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_version(flag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn vips_guess_prefix(
        argv0: *const ::std::os::raw::c_char,
        env_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn vips_guess_libdir(
        argv0: *const ::std::os::raw::c_char,
        env_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
